// TEMPLATE_TYPES: float, double
// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace Prowl.Vector.{{NAMESPACE_SUFFIX}}
{
    /// <summary>
    /// Represents an Axis-Aligned Bounding Box (AABB) in 3D space.
    /// </summary>
    public struct {{CLASS_NAME}} : IEquatable<{{CLASS_NAME}}>, IFormattable
    {
        /// <summary>The minimum corner of the AABB.</summary>
        public {{TYPE_PREFIX}}3 Min;

        /// <summary>The maximum corner of the AABB.</summary>
        public {{TYPE_PREFIX}}3 Max;

        /// <summary>
        /// Initializes a new AABB with the specified min and max corners.
        /// </summary>
        /// <param name="min">The minimum corner.</param>
        /// <param name="max">The maximum corner.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{CLASS_NAME}}({{TYPE_PREFIX}}3 min, {{TYPE_PREFIX}}3 max)
        {
            Min = new {{TYPE_PREFIX}}3(
                Maths.Min(min.X, max.X),
                Maths.Min(min.Y, max.Y),
                Maths.Min(min.Z, max.Z)
            );
            Max = new {{TYPE_PREFIX}}3(
                Maths.Max(min.X, max.X),
                Maths.Max(min.Y, max.Y),
                Maths.Max(min.Z, max.Z)
            );
        }

        /// <summary>
        /// Initializes a new AABB with individual min/max components.
        /// </summary>
        /// <param name="minX">Minimum X coordinate.</param>
        /// <param name="minY">Minimum Y coordinate.</param>
        /// <param name="minZ">Minimum Z coordinate.</param>
        /// <param name="maxX">Maximum X coordinate.</param>
        /// <param name="maxY">Maximum Y coordinate.</param>
        /// <param name="maxZ">Maximum Z coordinate.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{CLASS_NAME}}({{TYPE}} minX, {{TYPE}} minY, {{TYPE}} minZ, {{TYPE}} maxX, {{TYPE}} maxY, {{TYPE}} maxZ)
            : this(new {{TYPE_PREFIX}}3(minX, minY, minZ), new {{TYPE_PREFIX}}3(maxX, maxY, maxZ))
        {
        }

        /// <summary>
        /// Initializes a new AABB centered at a point with the specified size.
        /// </summary>
        /// <param name="center">The center point.</param>
        /// <param name="size">The size (width, height, depth).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static {{CLASS_NAME}} FromCenterAndSize({{TYPE_PREFIX}}3 center, {{TYPE_PREFIX}}3 size)
        {
            {{TYPE_PREFIX}}3 halfSize = size / {{TWO}};
            return new {{CLASS_NAME}}(center - halfSize, center + halfSize);
        }

        /// <summary>
        /// Gets the center point of the AABB.
        /// </summary>
        public {{TYPE_PREFIX}}3 Center
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Min + Max) / {{TWO}};
        }

        /// <summary>
        /// Gets the size (width, height, depth) of the AABB.
        /// </summary>
        public {{TYPE_PREFIX}}3 Size
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Max - Min;
        }

        /// <summary>
        /// Gets the extents (half-size) of the AABB.
        /// </summary>
        public {{TYPE_PREFIX}}3 Extents
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Size / {{TWO}};
        }

        /// <summary>
        /// Gets the volume of the AABB.
        /// </summary>
        public {{TYPE}} Volume
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                {{TYPE_PREFIX}}3 size = Size;
                return size.X * size.Y * size.Z;
            }
        }

        /// <summary>
        /// Gets the surface area of the AABB.
        /// </summary>
        public {{TYPE}} SurfaceArea
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                {{TYPE_PREFIX}}3 size = Size;
                return {{TWO}} * (size.X * size.Y + size.Y * size.Z + size.Z * size.X);
            }
        }

        /// <summary>
        /// Gets a corner of the AABB by index (0-7).
        /// </summary>
        /// <param name="index">Corner index (0-7).</param>
        /// <returns>The corner position.</returns>
        public {{TYPE_PREFIX}}3 GetCorner(int index)
        {
            switch (index)
            {
                case 0: return new {{TYPE_PREFIX}}3(Min.X, Min.Y, Min.Z);
                case 1: return new {{TYPE_PREFIX}}3(Max.X, Min.Y, Min.Z);
                case 2: return new {{TYPE_PREFIX}}3(Min.X, Max.Y, Min.Z);
                case 3: return new {{TYPE_PREFIX}}3(Max.X, Max.Y, Min.Z);
                case 4: return new {{TYPE_PREFIX}}3(Min.X, Min.Y, Max.Z);
                case 5: return new {{TYPE_PREFIX}}3(Max.X, Min.Y, Max.Z);
                case 6: return new {{TYPE_PREFIX}}3(Min.X, Max.Y, Max.Z);
                case 7: return new {{TYPE_PREFIX}}3(Max.X, Max.Y, Max.Z);
                default: throw new IndexOutOfRangeException("AABB corner index must be between 0 and 7.");
            }
        }

        /// <summary>
        /// Gets all 8 corners of the AABB.
        /// </summary>
        /// <returns>Array of 8 corner positions.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{TYPE_PREFIX}}3[] GetCorners()
        {
            return new {{TYPE_PREFIX}}3[]
            {
                new {{TYPE_PREFIX}}3(Min.X, Min.Y, Min.Z),
                new {{TYPE_PREFIX}}3(Max.X, Min.Y, Min.Z),
                new {{TYPE_PREFIX}}3(Min.X, Max.Y, Min.Z),
                new {{TYPE_PREFIX}}3(Max.X, Max.Y, Min.Z),
                new {{TYPE_PREFIX}}3(Min.X, Min.Y, Max.Z),
                new {{TYPE_PREFIX}}3(Max.X, Min.Y, Max.Z),
                new {{TYPE_PREFIX}}3(Min.X, Max.Y, Max.Z),
                new {{TYPE_PREFIX}}3(Max.X, Max.Y, Max.Z)
            };
        }

        /// <summary>
        /// Checks if this AABB contains a point.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>True if the point is inside or on the AABB boundary.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains({{TYPE_PREFIX}}3 point)
        {
            return point.X >= Min.X - {{EPSILON}} && point.X <= Max.X + {{EPSILON}} &&
                   point.Y >= Min.Y - {{EPSILON}} && point.Y <= Max.Y + {{EPSILON}} &&
                   point.Z >= Min.Z - {{EPSILON}} && point.Z <= Max.Z + {{EPSILON}};
        }

        /// <summary>
        /// Checks if this AABB completely contains another AABB.
        /// </summary>
        /// <param name="other">The other AABB to test.</param>
        /// <returns>True if the other AABB is completely inside this AABB.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains({{CLASS_NAME}} other)
        {
            return other.Min.X >= Min.X - {{EPSILON}} && other.Max.X <= Max.X + {{EPSILON}} &&
                   other.Min.Y >= Min.Y - {{EPSILON}} && other.Max.Y <= Max.Y + {{EPSILON}} &&
                   other.Min.Z >= Min.Z - {{EPSILON}} && other.Max.Z <= Max.Z + {{EPSILON}};
        }

        /// <summary>
        /// Checks if this AABB intersects with another AABB.
        /// </summary>
        /// <param name="other">The other AABB to test.</param>
        /// <returns>True if the AABBs intersect or touch.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects({{CLASS_NAME}} other)
        {
            return Intersection{{TEMPLATE_SUFFIX}}.AABBAABBOverlap(Min, Max, other.Min, other.Max);
        }

        /// <summary>
        /// Checks if this AABB intersects with a sphere.
        /// </summary>
        /// <param name="sphere">The sphere to test.</param>
        /// <returns>True if the AABB intersects the sphere.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(Sphere{{TEMPLATE_SUFFIX}} sphere)
        {
            return Intersection{{TEMPLATE_SUFFIX}}.SphereAABBOverlap(sphere.Center, sphere.Radius, Min, Max);
        }

        /// <summary>
        /// Gets the closest point on the AABB to a given point.
        /// </summary>
        /// <param name="point">The point to find the closest point to.</param>
        /// <returns>The closest point on the AABB.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{TYPE_PREFIX}}3 ClosestPointTo({{TYPE_PREFIX}}3 point)
        {
            {{TYPE_PREFIX}}3 closestPoint;
            Intersection{{TEMPLATE_SUFFIX}}.ClosestPointOnAABBToPoint(point, Min, Max, out closestPoint);
            return closestPoint;
        }

        /// <summary>
        /// Gets the squared distance from a point to the AABB.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>The squared distance (0 if point is inside).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{TYPE}} GetSqrDistanceToPoint({{TYPE_PREFIX}}3 point)
        {
            {{TYPE_PREFIX}}3 closest = ClosestPointTo(point);
            return Maths.LengthSquared(point - closest);
        }

        /// <summary>
        /// Gets the distance from a point to the AABB.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>The distance (0 if point is inside).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{TYPE}} GetDistanceToPoint({{TYPE_PREFIX}}3 point)
        {
            return Maths.Sqrt(GetSqrDistanceToPoint(point));
        }

        /// <summary>
        /// Expands the AABB to include a point.
        /// </summary>
        /// <param name="point">The point to include.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Encapsulate({{TYPE_PREFIX}}3 point)
        {
            Min = new {{TYPE_PREFIX}}3(
                Maths.Min(Min.X, point.X),
                Maths.Min(Min.Y, point.Y),
                Maths.Min(Min.Z, point.Z)
            );
            Max = new {{TYPE_PREFIX}}3(
                Maths.Max(Max.X, point.X),
                Maths.Max(Max.Y, point.Y),
                Maths.Max(Max.Z, point.Z)
            );
        }

        /// <summary>
        /// Expands the AABB to include another AABB.
        /// </summary>
        /// <param name="other">The AABB to include.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Encapsulate({{CLASS_NAME}} other)
        {
            Min = new {{TYPE_PREFIX}}3(
                Maths.Min(Min.X, other.Min.X),
                Maths.Min(Min.Y, other.Min.Y),
                Maths.Min(Min.Z, other.Min.Z)
            );
            Max = new {{TYPE_PREFIX}}3(
                Maths.Max(Max.X, other.Max.X),
                Maths.Max(Max.Y, other.Max.Y),
                Maths.Max(Max.Z, other.Max.Z)
            );
        }

        /// <summary>
        /// Returns an AABB that encapsulates both this AABB and a point.
        /// </summary>
        /// <param name="point">The point to include.</param>
        /// <returns>The encapsulating AABB.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{CLASS_NAME}} Encapsulating({{TYPE_PREFIX}}3 point)
        {
            var result = this;
            result.Encapsulate(point);
            return result;
        }

        /// <summary>
        /// Returns an AABB that encapsulates both this AABB and another AABB.
        /// </summary>
        /// <param name="other">The AABB to include.</param>
        /// <returns>The encapsulating AABB.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{CLASS_NAME}} Encapsulating({{CLASS_NAME}} other)
        {
            var result = this;
            result.Encapsulate(other);
            return result;
        }

        /// <summary>
        /// Expands the AABB by a given amount in all directions.
        /// </summary>
        /// <param name="amount">The amount to expand by.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Expand({{TYPE}} amount)
        {
            {{TYPE_PREFIX}}3 expansion = new {{TYPE_PREFIX}}3(amount, amount, amount);
            Min -= expansion;
            Max += expansion;
        }

        /// <summary>
        /// Expands the AABB by different amounts in each direction.
        /// </summary>
        /// <param name="expansion">The amount to expand by in each direction.</param>
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public void Expand({{TYPE_PREFIX}}3 expansion)
       {
           Min -= expansion;
           Max += expansion;
       }

       /// <summary>
       /// Returns an expanded version of this AABB.
       /// </summary>
       /// <param name="amount">The amount to expand by.</param>
       /// <returns>The expanded AABB.</returns>
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public {{CLASS_NAME}} Expanded({{TYPE}} amount)
       {
           var result = this;
           result.Expand(amount);
           return result;
       }

       /// <summary>
       /// Returns an expanded version of this AABB.
       /// </summary>
       /// <param name="expansion">The amount to expand by in each direction.</param>
       /// <returns>The expanded AABB.</returns>
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public {{CLASS_NAME}} Expanded({{TYPE_PREFIX}}3 expansion)
       {
           var result = this;
           result.Expand(expansion);
           return result;
       }

       /// <summary>
       /// Transforms the AABB by a 4x4 matrix.
       /// Results in an AABB that contains the transformed oriented bounding box.
       /// </summary>
       /// <param name="matrix">The transformation matrix.</param>
       /// <returns>The transformed AABB.</returns>
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public {{CLASS_NAME}} Transform({{TYPE_PREFIX}}4x4 matrix)
       {
           // Transform all 8 corners and find the new AABB
           {{TYPE_PREFIX}}3[] corners = GetCorners();
           {{TYPE_PREFIX}}3 newMin = Maths.TransformPoint(corners[0], matrix);
           {{TYPE_PREFIX}}3 newMax = newMin;

           for (int i = 1; i < 8; i++)
           {
               {{TYPE_PREFIX}}3 transformedCorner = Maths.TransformPoint(corners[i], matrix);
               newMin = new {{TYPE_PREFIX}}3(
                   Maths.Min(newMin.X, transformedCorner.X),
                   Maths.Min(newMin.Y, transformedCorner.Y),
                   Maths.Min(newMin.Z, transformedCorner.Z)
               );
               newMax = new {{TYPE_PREFIX}}3(
                   Maths.Max(newMax.X, transformedCorner.X),
                   Maths.Max(newMax.Y, transformedCorner.Y),
                   Maths.Max(newMax.Z, transformedCorner.Z)
               );
           }

           return new {{CLASS_NAME}}(newMin, newMax);
       }

       /// <summary>
       /// Clips this AABB against another AABB, returning the intersection.
       /// </summary>
       /// <param name="other">The AABB to clip against.</param>
       /// <returns>The clipped AABB, or an invalid AABB if no intersection.</returns>
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public {{CLASS_NAME}} ClippedBy({{CLASS_NAME}} other)
       {
           {{TYPE_PREFIX}}3 newMin = new {{TYPE_PREFIX}}3(
               Maths.Max(Min.X, other.Min.X),
               Maths.Max(Min.Y, other.Min.Y),
               Maths.Max(Min.Z, other.Min.Z)
           );
           {{TYPE_PREFIX}}3 newMax = new {{TYPE_PREFIX}}3(
               Maths.Min(Max.X, other.Max.X),
               Maths.Min(Max.Y, other.Max.Y),
               Maths.Min(Max.Z, other.Max.Z)
           );

           // If any dimension is invalid, return an empty AABB
           if (newMin.X > newMax.X || newMin.Y > newMax.Y || newMin.Z > newMax.Z)
           {
               return new {{CLASS_NAME}}({{TYPE_PREFIX}}3.Zero, {{TYPE_PREFIX}}3.Zero);
           }

           return new {{CLASS_NAME}}(newMin, newMax);
       }

       /// <summary>
       /// Checks if this AABB is valid (min <= max in all dimensions).
       /// </summary>
       /// <returns>True if the AABB is valid.</returns>
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public bool IsValid()
       {
           return Min.X <= Max.X && Min.Y <= Max.Y && Min.Z <= Max.Z;
       }

       /// <summary>
       /// Checks if this AABB has zero volume.
       /// </summary>
       /// <returns>True if the AABB has zero volume.</returns>
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public bool IsEmpty()
       {
           return Maths.Abs(Volume) < {{EPSILON}};
       }

       /// <summary>
       /// Samples a random point uniformly distributed inside the AABB.
       /// </summary>
       /// <returns>A uniformly distributed point inside the AABB.</returns>
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public {{TYPE_PREFIX}}3 SampleVolume()
       {
            {{TYPE}} u = RNG.Shared.Next{{TYPE_PREFIX}}();
            {{TYPE}} v = RNG.Shared.Next{{TYPE_PREFIX}}();
            {{TYPE}} w = RNG.Shared.Next{{TYPE_PREFIX}}();
           return new {{TYPE_PREFIX}}3(
               Maths.Lerp(Min.X, Max.X, u),
               Maths.Lerp(Min.Y, Max.Y, v),
               Maths.Lerp(Min.Z, Max.Z, w)
           );
       }

       /// <summary>
       /// Gets the face normal for the specified face index.
       /// </summary>
       /// <param name="faceIndex">Face index (0-5): -X, +X, -Y, +Y, -Z, +Z.</param>
       /// <returns>The face normal vector.</returns>
       public {{TYPE_PREFIX}}3 GetFaceNormal(int faceIndex)
       {
           switch (faceIndex)
           {
               case 0: return new {{TYPE_PREFIX}}3(-{{ONE}}, {{ZERO}}, {{ZERO}});  // -X face
               case 1: return new {{TYPE_PREFIX}}3({{ONE}}, {{ZERO}}, {{ZERO}});   // +X face
               case 2: return new {{TYPE_PREFIX}}3({{ZERO}}, -{{ONE}}, {{ZERO}});  // -Y face
               case 3: return new {{TYPE_PREFIX}}3({{ZERO}}, {{ONE}}, {{ZERO}});   // +Y face
               case 4: return new {{TYPE_PREFIX}}3({{ZERO}}, {{ZERO}}, -{{ONE}});  // -Z face
               case 5: return new {{TYPE_PREFIX}}3({{ZERO}}, {{ZERO}}, {{ONE}});   // +Z face
               default: throw new IndexOutOfRangeException("AABB face index must be between 0 and 5.");
           }
       }

       /// <summary>
       /// Gets the center point of the specified face.
       /// </summary>
       /// <param name="faceIndex">Face index (0-5): -X, +X, -Y, +Y, -Z, +Z.</param>
       /// <returns>The face center point.</returns>
       public {{TYPE_PREFIX}}3 GetFaceCenter(int faceIndex)
       {
           {{TYPE_PREFIX}}3 center = Center;
           switch (faceIndex)
           {
               case 0: return new {{TYPE_PREFIX}}3(Min.X, center.Y, center.Z);  // -X face
               case 1: return new {{TYPE_PREFIX}}3(Max.X, center.Y, center.Z);  // +X face
               case 2: return new {{TYPE_PREFIX}}3(center.X, Min.Y, center.Z);  // -Y face
               case 3: return new {{TYPE_PREFIX}}3(center.X, Max.Y, center.Z);  // +Y face
               case 4: return new {{TYPE_PREFIX}}3(center.X, center.Y, Min.Z);  // -Z face
               case 5: return new {{TYPE_PREFIX}}3(center.X, center.Y, Max.Z);  // +Z face
               default: throw new IndexOutOfRangeException("AABB face index must be between 0 and 5.");
           }
       }

       /// <summary>
       /// Creates an AABB from a collection of points.
       /// </summary>
       /// <param name="points">The points to encapsulate.</param>
       /// <returns>The smallest AABB that contains all points.</returns>
       public static {{CLASS_NAME}} FromPoints({{TYPE_PREFIX}}3[] points)
       {
           if (points == null || points.Length == 0)
               return new {{CLASS_NAME}}({{TYPE_PREFIX}}3.Zero, {{TYPE_PREFIX}}3.Zero);

           {{TYPE_PREFIX}}3 min = points[0];
           {{TYPE_PREFIX}}3 max = points[0];

           for (int i = 1; i < points.Length; i++)
           {
               min = new {{TYPE_PREFIX}}3(
                   Maths.Min(min.X, points[i].X),
                   Maths.Min(min.Y, points[i].Y),
                   Maths.Min(min.Z, points[i].Z)
               );
               max = new {{TYPE_PREFIX}}3(
                   Maths.Max(max.X, points[i].X),
                   Maths.Max(max.Y, points[i].Y),
                   Maths.Max(max.Z, points[i].Z)
               );
           }

           return new {{CLASS_NAME}}(min, max);
       }

       /// <summary>
       /// Creates an AABB that encompasses multiple AABBs.
       /// </summary>
       /// <param name="aabbs">The AABBs to encapsulate.</param>
       /// <returns>The smallest AABB that contains all input AABBs.</returns>
       public static {{CLASS_NAME}} FromAABBs({{CLASS_NAME}}[] aabbs)
       {
           if (aabbs == null || aabbs.Length == 0)
               return new {{CLASS_NAME}}({{TYPE_PREFIX}}3.Zero, {{TYPE_PREFIX}}3.Zero);

           {{CLASS_NAME}} result = aabbs[0];
           for (int i = 1; i < aabbs.Length; i++)
           {
               result.Encapsulate(aabbs[i]);
           }

           return result;
       }

       /// <summary>
       /// Creates an AABB from a sphere.
       /// </summary>
       /// <param name="sphere">The sphere to create an AABB from.</param>
       /// <returns>The AABB that tightly bounds the sphere.</returns>
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public static {{CLASS_NAME}} FromSphere(Sphere{{TEMPLATE_SUFFIX}} sphere)
       {
           {{TYPE_PREFIX}}3 radiusVector = new {{TYPE_PREFIX}}3(sphere.Radius, sphere.Radius, sphere.Radius);
           return new {{CLASS_NAME}}(sphere.Center - radiusVector, sphere.Center + radiusVector);
       }

       // --- IEquatable & IFormattable Implementation ---
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public bool Equals({{CLASS_NAME}} other) => Min.Equals(other.Min) && Max.Equals(other.Max);

       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public override bool Equals(object? obj) => obj is {{CLASS_NAME}} other && Equals(other);

       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public override int GetHashCode() => HashCode.Combine(Min, Max);

       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public override string ToString() => ToString(null, CultureInfo.CurrentCulture);

       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public string ToString(string? format, IFormatProvider? formatProvider = null)
       {
           return string.Format(formatProvider, "{{CLASS_NAME}}(Min: {0}, Max: {1})", 
               Min.ToString(format, formatProvider), Max.ToString(format, formatProvider));
       }

       public static bool operator ==({{CLASS_NAME}} left, {{CLASS_NAME}} right) => left.Equals(right);
       public static bool operator !=({{CLASS_NAME}} left, {{CLASS_NAME}} right) => !left.Equals(right);
   }
}
