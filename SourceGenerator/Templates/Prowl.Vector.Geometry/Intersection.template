// TEMPLATE_TYPES: float, double
// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;

namespace Prowl.Vector.{{NAMESPACE_SUFFIX}}
{
    /// <summary>
    /// Contains static methods for low-level 3D intersection, containment, and closest point tests
    /// All direction vectors (ray directions, plane normals) are assumed to be normalized unless specified.
    /// </summary>
    public static class {{CLASS_NAME}}
    {
        #region --- Ray Intersection Tests ---

        /// <summary>
        /// Calculates the intersection of a ray with a plane.
        /// </summary>
        /// <returns>True if the ray intersects the plane in the forward direction, false otherwise. Outputs the distance to intersection.</returns>
        public static bool RayPlane(
            {{TYPE_PREFIX}}3 rayOrigin,
            {{TYPE_PREFIX}}3 rayDir, // Assumed normalized
            {{TYPE_PREFIX}}3 planeNormal, // Assumed normalized
            {{TYPE}} planeD, // Distance from origin along the normal (Ax + By + Cz = D form)
            out {{TYPE}} distance)
        {
            {{TYPE}} nd = Maths.Dot(rayDir, planeNormal);
            {{TYPE}} pn = Maths.Dot(rayOrigin, planeNormal);

            if (Maths.Abs(nd) < {{EPSILON}}) // Ray is parallel to the plane
            {
                distance = {{ZERO}};
                return false;
            }

            distance = (planeD - pn) / nd;

            return distance >= {{ZERO}}; // Intersection must be in the forward direction of the ray
        }

        /// <summary>
        /// Calculates the intersection of a ray with a triangle (Moller-Trumbore algorithm).
        /// Outputs distance along the ray and barycentric coordinates (u,v). w = 1-u-v.
        /// </summary>
        /// <returns>True if the ray intersects the triangle (front or back face), false otherwise.</returns>
        public static bool RayTriangle(
            {{TYPE_PREFIX}}3 rayOrigin,
            {{TYPE_PREFIX}}3 rayDir, // Assumed normalized
            {{TYPE_PREFIX}}3 v0, {{TYPE_PREFIX}}3 v1, {{TYPE_PREFIX}}3 v2,
            out {{TYPE}} distance, out {{TYPE}} u, out {{TYPE}} v)
        {
            distance = {{ZERO}}; u = {{ZERO}}; v = {{ZERO}};

            {{TYPE_PREFIX}}3 edge1 = v1 - v0;
            {{TYPE_PREFIX}}3 edge2 = v2 - v0;

            {{TYPE_PREFIX}}3 pvec = Maths.Cross(rayDir, edge2);
            {{TYPE}} det = Maths.Dot(edge1, pvec);

            if (Maths.Abs(det) < {{EPSILON}}) // Ray is parallel to triangle plane or backface culling if det < Epsilon
                return false;

            {{TYPE}} invDet = {{ONE}} / det;

            {{TYPE_PREFIX}}3 tvec = rayOrigin - v0;
            u = Maths.Dot(tvec, pvec) * invDet;
            if (u < {{ZERO}} || u > {{ONE}})
                return false;

            {{TYPE_PREFIX}}3 qvec = Maths.Cross(tvec, edge1);
            v = Maths.Dot(rayDir, qvec) * invDet;
            if (v < {{ZERO}} || u + v > {{ONE}})
                return false;

            distance = Maths.Dot(edge2, qvec) * invDet;

            return distance >= {{ZERO}}; // Intersection must be in the forward direction
        }

        /// <summary>
        /// Calculates intersection of a ray with an Axis-Aligned Bounding Box (AABB).
        /// Uses the slabs method.
        /// </summary>
        /// <returns>True if intersection occurs. out tMin is entry distance, out tMax is exit distance.</returns>
        public static bool RayAABB(
            {{TYPE_PREFIX}}3 rayOrigin,
            {{TYPE_PREFIX}}3 rayDir, // Does not need to be normalized
            {{TYPE_PREFIX}}3 boxMin,
            {{TYPE_PREFIX}}3 boxMax,
            out {{TYPE}} tMin, out {{TYPE}} tMax)
        {
            tMin = {{ZERO}};
            tMax = {{TYPE}}.MaxValue;

            // X slab
            if (Maths.Abs(rayDir.X) < {{EPSILON}})
            {
                if (rayOrigin.X < boxMin.X || rayOrigin.X > boxMax.X) { return false; }
            }
            else
            {
                {{TYPE}} invDirX = {{ONE}} / rayDir.X;
                {{TYPE}} t1x = (boxMin.X - rayOrigin.X) * invDirX;
                {{TYPE}} t2x = (boxMax.X - rayOrigin.X) * invDirX;
                if (t1x > t2x) {
                    (t2x, t1x) = (t1x, t2x);
                }
                tMin = Maths.Max(tMin, t1x);
                tMax = Maths.Min(tMax, t2x);
                if (tMin > tMax) { return false; }
            }

            // Y slab
            if (Maths.Abs(rayDir.Y) < {{EPSILON}})
            {
                if (rayOrigin.Y < boxMin.Y || rayOrigin.Y > boxMax.Y) { return false; }
            }
            else
            {
                {{TYPE}} invDirY = {{ONE}} / rayDir.Y;
                {{TYPE}} t1y = (boxMin.Y - rayOrigin.Y) * invDirY;
                {{TYPE}} t2y = (boxMax.Y - rayOrigin.Y) * invDirY;
                if (t1y > t2y) {
                    (t2y, t1y) = (t1y, t2y);
                }
                tMin = Maths.Max(tMin, t1y);
                tMax = Maths.Min(tMax, t2y);
                if (tMin > tMax) { return false; }
            }

            // Z slab
            if (Maths.Abs(rayDir.Z) < {{EPSILON}})
            {
                if (rayOrigin.Z < boxMin.Z || rayOrigin.Z > boxMax.Z) { return false; }
            }
            else
            {
                {{TYPE}} invDirZ = {{ONE}} / rayDir.Z;
                {{TYPE}} t1z = (boxMin.Z - rayOrigin.Z) * invDirZ;
                {{TYPE}} t2z = (boxMax.Z - rayOrigin.Z) * invDirZ;
                if (t1z > t2z) {
                    (t2z, t1z) = (t1z, t2z);
                }
                tMin = Maths.Max(tMin, t1z);
                tMax = Maths.Min(tMax, t2z);
                if (tMin > tMax) { return false; }
            }

            return tMax >= {{ZERO}} && tMin <= tMax;
        }

        /// <summary>
        /// Calculates intersection of a ray with a sphere.
        /// </summary>
        /// <returns>True if intersection. out t0 and t1 are distances (t0 <= t1). If only one intersection (tangent) or ray starts inside, t0 may be negative.</returns>
        public static bool RaySphere(
            {{TYPE_PREFIX}}3 rayOrigin,
            {{TYPE_PREFIX}}3 rayDir, // Assumed normalized
            {{TYPE_PREFIX}}3 sphereCenter,
            {{TYPE}} sphereRadius,
            out {{TYPE}} t0, out {{TYPE}} t1)
        {
            t0 = t1 = {{ZERO}};

            {{TYPE_PREFIX}}3 oc = rayOrigin - sphereCenter;

            //{{TYPE}} a = Maths.Dot(rayDir, rayDir); // Should be 1.0 if rayDir is normalized
            const {{TYPE}} a = {{ONE}};

            {{TYPE}} b = {{TWO}} * Maths.Dot(oc, rayDir);
            {{TYPE}} c = oc.LengthSquared - sphereRadius * sphereRadius;

            {{TYPE}} discriminant = b * b - 4 * a * c; // a is 1.0

            if (discriminant < {{ZERO}}) return false;

            {{TYPE}} sqrtDiscriminant = Maths.Sqrt(discriminant);
            // Denominator is 2*a, which is 2.0 since a=1.0
            t0 = (-b - sqrtDiscriminant) / {{TWO}};
            t1 = (-b + sqrtDiscriminant) / {{TWO}};

            if (t0 > t1) {
                (t1, t0) = (t0, t1);
            }

            return true;
        }

        /// <summary>
        /// Calculates intersection of a ray with an infinite cylinder defined by an axis, radius, and a point on the axis.
        /// </summary>
        /// <returns>True if intersection. out t0 and t1 are distances along the ray (t0 <= t1).</returns>
        public static bool RayCylinderInfinite(
            {{TYPE_PREFIX}}3 rayOrigin, {{TYPE_PREFIX}}3 rayDir, // rayDir assumed normalized
            {{TYPE_PREFIX}}3 cylinderAxisPoint, {{TYPE_PREFIX}}3 cylinderAxisDir, // cylinderAxisDir assumed normalized
            {{TYPE}} cylinderRadius,
            out {{TYPE}} t0, out {{TYPE}} t1)
        {
            t0 = t1 = {{ZERO}};
            {{TYPE_PREFIX}}3 oc = rayOrigin - cylinderAxisPoint;

            {{TYPE}} card = Maths.Dot(cylinderAxisDir, rayDir);
            {{TYPE}} caoc = Maths.Dot(cylinderAxisDir, oc);

            {{TYPE}} a = {{ONE}} - card * card; // Since rayDir and cylinderAxisDir are normalized, Dot(rayDir,rayDir) = 1
            {{TYPE}} b = {{TWO}} * (Maths.Dot(oc, rayDir) - caoc * card);
            {{TYPE}} c = Maths.Dot(oc, oc) - caoc * caoc - cylinderRadius * cylinderRadius;

            if (Maths.Abs(a) < {{EPSILON}}) // Ray is parallel to cylinder axis
            {
                // Check if ray origin is inside the cylinder's radius projected onto the plane
                // perpendicular to the axis passing through cylinderAxisPoint.
                // Distance_sq(rayOrigin to line) = Dot(oc, oc) - caoc*caoc
                if (c > {{ZERO}}) return false; // Ray is outside and parallel
                // Ray is inside or on the surface and parallel
                t0 = {{TYPE}}.NegativeInfinity;
                t1 = {{TYPE}}.PositiveInfinity;
                return true;
            }

            {{TYPE}} discriminant = b * b - 4 * a * c;
            if (discriminant < {{ZERO}}) return false;

            {{TYPE}} sqrtDiscriminant = Maths.Sqrt(discriminant);
            t0 = (-b - sqrtDiscriminant) / ({{TWO}} * a);
            t1 = (-b + sqrtDiscriminant) / ({{TWO}} * a);

            if (t0 > t1) { {{TYPE}} temp = t0; t0 = t1; t1 = temp; }
            return true;
        }

        /// <summary>
        /// Calculates intersection of a ray with a capped cylinder.
        /// </summary>
        /// <returns>True if intersection. out distance is the closest valid intersection distance.</returns>
        public static bool RayCylinderCapped(
            {{TYPE_PREFIX}}3 rayOrigin, {{TYPE_PREFIX}}3 rayDir, // rayDir assumed normalized
            {{TYPE_PREFIX}}3 capA_Center, {{TYPE_PREFIX}}3 capB_Center, // Centers of the two end caps
            {{TYPE}} radius,
            out {{TYPE}} distance)
        {
            distance = {{TYPE}}.MaxValue;
            bool intersected = false;

            {{TYPE_PREFIX}}3 cylinderAxisDir = capB_Center - capA_Center;
            {{TYPE}} heightSq = cylinderAxisDir.LengthSquared;
            if (heightSq < {{EPSILON}} * {{EPSILON}})
            {
                {{TYPE}} t0, t1;
                if (RaySphere(rayOrigin, rayDir, capA_Center, radius, out t0, out t1))
                {
                    if (t0 >= {{ZERO}} && t0 < distance) { distance = t0; intersected = true; }
                    else if (t1 >= {{ZERO}} && t1 < distance) { distance = t1; intersected = true; }
                }
                return intersected;
            }
            cylinderAxisDir = cylinderAxisDir / Maths.Sqrt(heightSq); // Normalize

            {{TYPE}} t0_inf, t1_inf;
            if (RayCylinderInfinite(rayOrigin, rayDir, capA_Center, cylinderAxisDir, radius, out t0_inf, out t1_inf))
            {
                {{TYPE}} height = Maths.Sqrt(heightSq);
                if (t0_inf >= {{ZERO}})
                {
                    {{TYPE_PREFIX}}3 p0 = rayOrigin + t0_inf * rayDir;
                    {{TYPE}} proj0 = Maths.Dot(p0 - capA_Center, cylinderAxisDir);
                    if (proj0 >= -{{EPSILON}} && proj0 <= height + {{EPSILON}})
                    {
                        if (t0_inf < distance) { distance = t0_inf; intersected = true; }
                    }
                }
                if (t1_inf >= {{ZERO}})
                {
                    {{TYPE_PREFIX}}3 p1 = rayOrigin + t1_inf * rayDir;
                    {{TYPE}} proj1 = Maths.Dot(p1 - capA_Center, cylinderAxisDir);
                    if (proj1 >= -{{EPSILON}} && proj1 <= height + {{EPSILON}})
                    {
                        if (t1_inf < distance) { distance = t1_inf; intersected = true; }
                    }
                }
            }

            {{TYPE}} capDist;
            if (RayPlane(rayOrigin, rayDir, -cylinderAxisDir, Maths.Dot(-cylinderAxisDir, capA_Center), out capDist))
            {
                if (capDist >= {{ZERO}} && capDist < distance)
                {
                    {{TYPE_PREFIX}}3 p_capA = rayOrigin + capDist * rayDir;
                    if ((p_capA - capA_Center).LengthSquared <= radius * radius + {{EPSILON}})
                    {
                        distance = capDist;
                        intersected = true;
                    }
                }
            }
            if (RayPlane(rayOrigin, rayDir, cylinderAxisDir, Maths.Dot(cylinderAxisDir, capB_Center), out capDist))
            {
                if (capDist >= {{ZERO}} && capDist < distance)
                {
                    {{TYPE_PREFIX}}3 p_capB = rayOrigin + capDist * rayDir;
                    if ((p_capB - capB_Center).LengthSquared <= radius * radius + {{EPSILON}})
                    {
                        distance = capDist;
                        intersected = true;
                    }
                }
            }
            return intersected;
        }

        #endregion

        #region --- Closest Point / Distance Tests ---

        /// <summary>
        /// Calculates the signed distance from a point to a plane.
        /// Distance is positive if point is on the side of the normal, negative otherwise.
        /// </summary>
        public static {{TYPE}} SignedDistancePointToPlane(
            {{TYPE_PREFIX}}3 point,
            {{TYPE_PREFIX}}3 planeNormal, // Assumed normalized
            {{TYPE}} planeD) // Ax + By + Cz = D form (D is dot(Normal, PointOnPlane))
        {
            return Maths.Dot(planeNormal, point) - planeD;
        }

        /// <summary>
        /// Calculates the closest point on a plane to a given point.
        /// </summary>
        public static void ClosestPointOnPlaneToPoint(
            {{TYPE_PREFIX}}3 point,
            {{TYPE_PREFIX}}3 planeNormal, // Assumed normalized
            {{TYPE}} planeD,
            out {{TYPE_PREFIX}}3 closestPoint)
        {
            {{TYPE}} signedDist = SignedDistancePointToPlane(point, planeNormal, planeD);
            closestPoint = point - signedDist * planeNormal;
        }

        /// <summary>
        /// Calculates the closest point on an infinite line (defined by two points) to a given point.
        /// </summary>
        public static void ClosestPointOnLineToPoint(
            {{TYPE_PREFIX}}3 lineA, {{TYPE_PREFIX}}3 lineB,
            {{TYPE_PREFIX}}3 point,
            out {{TYPE_PREFIX}}3 closestPoint)
        {
            {{TYPE_PREFIX}}3 ab = lineB - lineA;
            {{TYPE_PREFIX}}3 ap = point - lineA;

            {{TYPE}} dot_ab_ap = Maths.Dot(ab, ap);
            {{TYPE}} dot_ab_ab = ab.LengthSquared;

            {{TYPE}} t = {{ZERO}};
            if (dot_ab_ab > {{EPSILON}})
                t = dot_ab_ap / dot_ab_ab;

            closestPoint = lineA + t * ab;
        }

        /// <summary>
        /// Calculates the closest point on a line segment to a given point.
        /// </summary>
        public static void ClosestPointOnLineSegmentToPoint(
            {{TYPE_PREFIX}}3 segA, {{TYPE_PREFIX}}3 segB,
            {{TYPE_PREFIX}}3 point,
            out {{TYPE_PREFIX}}3 closestPoint)
        {
            {{TYPE_PREFIX}}3 ab = segB - segA;
            {{TYPE_PREFIX}}3 ap = point - segA;

            {{TYPE}} dot_ab_ap = Maths.Dot(ab, ap);

            if (dot_ab_ap <= {{ZERO}})
            {
                closestPoint = segA;
                return;
            }

            {{TYPE}} dot_ab_ab = ab.LengthSquared;

            if (dot_ab_ap >= dot_ab_ab)
            {
                closestPoint = segB;
                return;
            }

            {{TYPE}} t = {{ZERO}};
            if (dot_ab_ab > {{EPSILON}})
                t = dot_ab_ap / dot_ab_ab;

            closestPoint = segA + t * ab;
        }

        /// <summary>
        /// Calculates the square of the distance from a point to a line segment.
        /// </summary>
        public static {{TYPE}} DistanceSqPointToLineSegment(
            {{TYPE_PREFIX}}3 segA, {{TYPE_PREFIX}}3 segB,
            {{TYPE_PREFIX}}3 point)
        {
            ClosestPointOnLineSegmentToPoint(segA, segB, point, out {{TYPE_PREFIX}}3 closestPoint);
            {{TYPE_PREFIX}}3 diff = point - closestPoint;
            return diff.LengthSquared;
        }

        /// <summary>
        /// Calculates the closest point on a triangle to a given point.
        /// </summary>
        public static void ClosestPointOnTriangleToPoint(
            {{TYPE_PREFIX}}3 point,
            {{TYPE_PREFIX}}3 v0, {{TYPE_PREFIX}}3 v1, {{TYPE_PREFIX}}3 v2,
            out {{TYPE_PREFIX}}3 result)
        {
            {{TYPE_PREFIX}}3 ab = v1 - v0;
            {{TYPE_PREFIX}}3 ac = v2 - v0;
            {{TYPE_PREFIX}}3 ap = point - v0;

            {{TYPE}} d1 = Maths.Dot(ab, ap);
            {{TYPE}} d2 = Maths.Dot(ac, ap);
            if (d1 <= {{ZERO}} && d2 <= {{ZERO}}) { result = v0; return; }

            {{TYPE_PREFIX}}3 bp = point - v1;
            {{TYPE}} d3 = Maths.Dot(ab, bp);
            {{TYPE}} d4 = Maths.Dot(ac, bp);
            if (d3 >= {{ZERO}} && d4 <= d3) { result = v1; return; }

            {{TYPE}} vc = d1 * d4 - d3 * d2;
            if (vc <= {{ZERO}} && d1 >= {{ZERO}} && d3 <= {{ZERO}})
            {
                {{TYPE}} v_param = (Maths.Abs(d1 - d3) < {{EPSILON}}) ? {{ZERO}} : d1 / (d1 - d3);
                result = v0 + v_param * ab;
                return;
            }

            {{TYPE_PREFIX}}3 cp = point - v2;
            {{TYPE}} d5 = Maths.Dot(ab, cp);
            {{TYPE}} d6 = Maths.Dot(ac, cp);
            if (d6 >= {{ZERO}} && d5 <= d6) { result = v2; return; }

            {{TYPE}} vb = d5 * d2 - d1 * d6;
            if (vb <= {{ZERO}} && d2 >= {{ZERO}} && d6 <= {{ZERO}})
            {
                {{TYPE}} w_param = (Maths.Abs(d2 - d6) < {{EPSILON}}) ? {{ZERO}} : d2 / (d2 - d6);
                result = v0 + w_param * ac;
                return;
            }

            {{TYPE}} va = d3 * d6 - d5 * d4;
            if (va <= {{ZERO}} && (d4 - d3) >= {{ZERO}} && (d5 - d6) >= {{ZERO}})
            {
                {{TYPE}} denom_bc = (d4 - d3) + (d5 - d6);
                {{TYPE}} w_param = (Maths.Abs(denom_bc) < {{EPSILON}}) ? {{ZERO}} : (d4 - d3) / denom_bc;
                result = v1 + w_param * (v2 - v1);
                return;
            }

            {{TYPE}} denom_bary = va + vb + vc;
            if (Maths.Abs(denom_bary) < {{EPSILON}}) { result = v0; return; }
            {{TYPE}} v_bary = vb / denom_bary;
            {{TYPE}} w_bary = vc / denom_bary;
            result = v0 + ab * v_bary + ac * w_bary;
        }

        /// <summary>
        /// Calculates the closest point on an AABB to a given point.
        /// </summary>
        public static void ClosestPointOnAABBToPoint(
            {{TYPE_PREFIX}}3 point,
            {{TYPE_PREFIX}}3 boxMin, {{TYPE_PREFIX}}3 boxMax,
            out {{TYPE_PREFIX}}3 closestPoint)
        {
            // Assuming Maths.Clamp(value, min, max) exists for scalars
            {{TYPE}} x = Maths.Clamp(point.X, boxMin.X, boxMax.X);
            {{TYPE}} y = Maths.Clamp(point.Y, boxMin.Y, boxMax.Y);
            {{TYPE}} z = Maths.Clamp(point.Z, boxMin.Z, boxMax.Z);
            closestPoint = new {{TYPE_PREFIX}}3(x, y, z);
        }

        /// <summary>
        /// Calculates the closest point on the surface of a sphere to a given point.
        /// If the point is at the center of the sphere, returns a point on the surface (e.g., center + radius on X axis).
        /// </summary>
        public static void ClosestPointOnSphereToPoint(
            {{TYPE_PREFIX}}3 point,
            {{TYPE_PREFIX}}3 sphereCenter,
            {{TYPE}} sphereRadius,
            out {{TYPE_PREFIX}}3 closestPoint)
        {
            {{TYPE_PREFIX}}3 dir = point - sphereCenter;
            {{TYPE}} distSq = dir.LengthSquared;

            if (distSq < {{EPSILON}} * {{EPSILON}})
            {
                closestPoint = sphereCenter + new {{TYPE_PREFIX}}3(sphereRadius, {{ZERO}}, {{ZERO}});
                return;
            }

            // dir.Normalize() * sphereRadius + sphereCenter
            closestPoint = sphereCenter + (dir / Maths.Sqrt(distSq)) * sphereRadius;
        }

        /// <summary>
        /// Computes the closest points on two line segments.
        /// Outputs the points c1 on segment p1-q1 and c2 on segment p2-q2,
        /// and parameters s and t for these points along their respective segments.
        /// </summary>
        public static void ClosestPointsLineSegmentLineSegment(
            {{TYPE_PREFIX}}3 p1, {{TYPE_PREFIX}}3 q1, // Segment 1
            {{TYPE_PREFIX}}3 p2, {{TYPE_PREFIX}}3 q2, // Segment 2
            out {{TYPE_PREFIX}}3 c1, out {{TYPE_PREFIX}}3 c2,
            out {{TYPE}} s, out {{TYPE}} t)
        {
            {{TYPE_PREFIX}}3 d1 = q1 - p1; // Direction vector of segment S1
            {{TYPE_PREFIX}}3 d2 = q2 - p2; // Direction vector of segment S2
            {{TYPE_PREFIX}}3 r = p1 - p2;  // Vector between segment starts

            {{TYPE}} a = Maths.Dot(d1, d1); // Squared length of segment S1
            {{TYPE}} e = Maths.Dot(d2, d2); // Squared length of segment S2
            {{TYPE}} f = Maths.Dot(d2, r);

            // Check if either or both segments are points
            if (a <= {{EPSILON}} && e <= {{EPSILON}}) // Both segments are points
            {
                s = t = {{ZERO}};
                c1 = p1;
                c2 = p2;
                return;
            }
            if (a <= {{EPSILON}}) // First segment is a point
            {
                s = {{ZERO}};
                t = Maths.Clamp(f / e, {{ZERO}}, {{ONE}}); // Clamp t to 0..1
            }
            else
            {
                {{TYPE}} c_val = Maths.Dot(d1, r);
                if (e <= {{EPSILON}}) // Second segment is a point
                {
                    t = {{ZERO}};
                    s = Maths.Clamp(-c_val / a, {{ZERO}}, {{ONE}}); // Clamp s to 0..1
                }
                else // General case
                {
                    {{TYPE}} b = Maths.Dot(d1, d2);
                    {{TYPE}} denom = a * e - b * b; // Denominator

                    // If segments are parallel, handle specially
                    if (denom <= {{EPSILON}})
                    {
                        s = {{ZERO}}; // Arbitrarily pick s=0
                        t = (b > e) ? f / b : f / e; // Simplified handling for parallel lines
                    }
                    else
                    {
                        s = (b * f - c_val * e) / denom;
                        t = (a * f - b * c_val) / denom;
                    }

                    // Clamp parameters to the segment lengths [0,1]
                    s = Maths.Clamp(s, {{ZERO}}, {{ONE}});
                    t = Maths.Clamp(t, {{ZERO}}, {{ONE}});
                }
            }

            c1 = p1 + d1 * s;
            c2 = p2 + d2 * t;
        }

        /// <summary>
        /// Computes the square of the shortest distance between two line segments.
        /// </summary>
        public static {{TYPE}} DistanceSqSegmentSegment({{TYPE_PREFIX}}3 p1, {{TYPE_PREFIX}}3 q1, {{TYPE_PREFIX}}3 p2, {{TYPE_PREFIX}}3 q2)
        {
            {{TYPE_PREFIX}}3 c1, c2;
            {{TYPE}} s, t;
            ClosestPointsLineSegmentLineSegment(p1, q1, p2, q2, out c1, out c2, out s, out t);
            return (c1 - c2).LengthSquared;
        }

        #endregion

        #region --- Shape vs. Shape Overlap/Intersection Tests (Boolean) ---

        /// <summary>
        /// Checks if two spheres overlap or touch.
        /// </summary>
        public static bool SphereSphereOverlap(
            {{TYPE_PREFIX}}3 centerA, {{TYPE}} radiusA,
            {{TYPE_PREFIX}}3 centerB, {{TYPE}} radiusB)
        {
            {{TYPE}} distSq = (centerA - centerB).LengthSquared;
            {{TYPE}} sumRadii = radiusA + radiusB;
            return distSq <= sumRadii * sumRadii;
        }

        /// <summary>
        /// Checks if two AABBs overlap or touch.
        /// </summary>
        public static bool AABBAABBOverlap(
            {{TYPE_PREFIX}}3 minA, {{TYPE_PREFIX}}3 maxA,
            {{TYPE_PREFIX}}3 minB, {{TYPE_PREFIX}}3 maxB)
        {
            if (maxA.X < minB.X || minA.X > maxB.X) return false;
            if (maxA.Y < minB.Y || minA.Y > maxB.Y) return false;
            if (maxA.Z < minB.Z || minA.Z > maxB.Z) return false;
            return true;
        }

        /// <summary>
        /// Checks if a sphere and an AABB overlap or touch.
        /// </summary>
        public static bool SphereAABBOverlap(
            {{TYPE_PREFIX}}3 sphereCenter, {{TYPE}} sphereRadius,
            {{TYPE_PREFIX}}3 boxMin, {{TYPE_PREFIX}}3 boxMax)
        {
            ClosestPointOnAABBToPoint(sphereCenter, boxMin, boxMax, out {{TYPE_PREFIX}}3 closestPointOnBox);
            {{TYPE}} distSq = (sphereCenter - closestPointOnBox).LengthSquared;
            return distSq <= sphereRadius * sphereRadius;
        }

        /// <summary>
        /// Checks if a line segment and a plane overlap or touch, If so outputs the intersection point.
        /// </summary>
        /// <returns>True if the segment intersects the plane, false otherwise.</returns>
        public static bool LineSegmentPlane(
            {{TYPE_PREFIX}}3 segA, {{TYPE_PREFIX}}3 segB,
            {{TYPE_PREFIX}}3 planeNormal, {{TYPE}} planeD, // Assumed planeNormal is normalized
            out {{TYPE_PREFIX}}3 intersectionPoint)
        {
            intersectionPoint = {{TYPE_PREFIX}}3.Zero;
           {{TYPE_PREFIX}}3 ab = segB - segA;
           {{TYPE}} ab_dot_n = Maths.Dot(ab, planeNormal);

           if (Maths.Abs(ab_dot_n) < {{EPSILON}}) // Segment is parallel to plane
           {
               // Check if segment start point is on the plane (coplanar)
               if (Maths.Abs(SignedDistancePointToPlane(segA, planeNormal, planeD)) < {{EPSILON}})
               {
                   // Segment is coplanar with the plane.
                   // This Could be considered an intersection.
                   // But for now let's just say it doesn't produce an intersection point.
                   return false;
               }
               return false;
           }

           {{TYPE}} t = (planeD - Maths.Dot(segA, planeNormal)) / ab_dot_n;

           if (t >= -{{EPSILON}} && t <= {{ONE}} + {{EPSILON}}) // Intersection point lies on the segment
           {
               intersectionPoint = segA + t * ab;
               return true;
           }
           return false;
        }
        
        /// <summary>
        /// Tests if two triangles intersect in 3D space.
        /// Uses the separating axis theorem with cross products of triangle edges.
        /// </summary>
        /// <param name="a0">First triangle vertex 0.</param>
        /// <param name="a1">First triangle vertex 1.</param>
        /// <param name="a2">First triangle vertex 2.</param>
        /// <param name="b0">Second triangle vertex 0.</param>
        /// <param name="b1">Second triangle vertex 1.</param>
        /// <param name="b2">Second triangle vertex 2.</param>
        /// <returns>True if the triangles intersect or touch.</returns>
        public static bool TriangleTriangle({{TYPE_PREFIX}}3 a0, {{TYPE_PREFIX}}3 a1, {{TYPE_PREFIX}}3 a2, {{TYPE_PREFIX}}3 b0, {{TYPE_PREFIX}}3 b1, {{TYPE_PREFIX}}3 b2)
        {
            // Compute triangle normals
            {{TYPE_PREFIX}}3 normalA = Maths.Cross(a1 - a0, a2 - a0);
            {{TYPE_PREFIX}}3 normalB = Maths.Cross(b1 - b0, b2 - b0);
        
            // Check if triangles are degenerate
            if (normalA.LengthSquared < {{EPSILON}} * {{EPSILON}} ||
                normalB.LengthSquared < {{EPSILON}} * {{EPSILON}})
                return false;
        
            normalA = Maths.Normalize(normalA);
            normalB = Maths.Normalize(normalB);
        
            // Test separation along triangle A's normal
            {{TYPE}} dA = Maths.Dot(normalA, a0);
            {{TYPE}} minB, maxB;
            ProjectTriangleOntoAxis(b0, b1, b2, normalA, out minB, out maxB);
            if (dA < minB - {{EPSILON}} || dA > maxB + {{EPSILON}})
                return false;
        
            // Test separation along triangle B's normal
            {{TYPE}} dB = Maths.Dot(normalB, b0);
            {{TYPE}} minA, maxA;
            ProjectTriangleOntoAxis(a0, a1, a2, normalB, out minA, out maxA);
            if (dB < minA - {{EPSILON}} || dB > maxA + {{EPSILON}})
                return false;
        
            // Test separation along cross products of triangle edges
            {{TYPE_PREFIX}}3[] edgesA = { a1 - a0, a2 - a1, a0 - a2 };
            {{TYPE_PREFIX}}3[] edgesB = { b1 - b0, b2 - b1, b0 - b2 };
        
            for (int i = 0; i < 3; i++)
            {
                for (int j = 0; j < 3; j++)
                {
                    {{TYPE_PREFIX}}3 axis = Maths.Cross(edgesA[i], edgesB[j]);
        
                    // Skip if axis is too small (edges are parallel)
                    if (axis.LengthSquared < {{EPSILON}} * {{EPSILON}})
                        continue;
        
                    axis = Maths.Normalize(axis);
        
                    // Project both triangles onto this axis
                    ProjectTriangleOntoAxis(a0, a1, a2, axis, out minA, out maxA);
                    ProjectTriangleOntoAxis(b0, b1, b2, axis, out minB, out maxB);
        
                    // Check for separation
                    if (maxA < minB - {{EPSILON}} || maxB < minA - {{EPSILON}})
                        return false;
                }
            }
        
            // No separating axis found, triangles must intersect
            return true;
        }
        
        /// <summary>
        /// Projects a triangle onto an axis and returns the min/max projection values.
        /// </summary>
        /// <param name="v0">Triangle vertex 0.</param>
        /// <param name="v1">Triangle vertex 1.</param>
        /// <param name="v2">Triangle vertex 2.</param>
        /// <param name="axis">The axis to project onto (assumed normalized).</param>
        /// <param name="min">Minimum projection value.</param>
        /// <param name="max">Maximum projection value.</param>
        private static void ProjectTriangleOntoAxis({{TYPE_PREFIX}}3 v0, {{TYPE_PREFIX}}3 v1, {{TYPE_PREFIX}}3 v2, {{TYPE_PREFIX}}3 axis, out {{TYPE}} min, out {{TYPE}} max)
        {
            {{TYPE}} p0 = Maths.Dot(v0, axis);
            {{TYPE}} p1 = Maths.Dot(v1, axis);
            {{TYPE}} p2 = Maths.Dot(v2, axis);
        
            min = Maths.Min(p0, Maths.Min(p1, p2));
            max = Maths.Max(p0, Maths.Max(p1, p2));
        }
        
        #region --- Plane Classification ---
        
        public enum PlaneIntersectionType { Front, Back, Intersecting }
        
        /// <summary>
        /// Classifies a point with respect to a plane.
        /// </summary>
        public static PlaneIntersectionType ClassifyPointToPlane(
             {{TYPE_PREFIX}}3 point,
             {{TYPE_PREFIX}}3 planeNormal, {{TYPE}} planeD)
        {
            {{TYPE}} dist = SignedDistancePointToPlane(point, planeNormal, planeD);
            if (dist > {{EPSILON}}) return PlaneIntersectionType.Front;
            if (dist < -{{EPSILON}}) return PlaneIntersectionType.Back;
            return PlaneIntersectionType.Intersecting;
        }
        
        /// <summary>
        /// Classifies a sphere with respect to a plane.
        /// </summary>
        public static PlaneIntersectionType ClassifySphereToPlane(
            {{TYPE_PREFIX}}3 sphereCenter, {{TYPE}} sphereRadius,
            {{TYPE_PREFIX}}3 planeNormal, {{TYPE}} planeD)
        {
            {{TYPE}} signedDist = SignedDistancePointToPlane(sphereCenter, planeNormal, planeD);
            if (signedDist > sphereRadius) return PlaneIntersectionType.Front;
            if (signedDist < -sphereRadius) return PlaneIntersectionType.Back;
            return PlaneIntersectionType.Intersecting;
        }
        
        /// <summary>
        /// Classifies an AABB with respect to a plane.
        /// </summary>
        public static PlaneIntersectionType ClassifyAABBToPlane(
            {{TYPE_PREFIX}}3 boxMin, {{TYPE_PREFIX}}3 boxMax,
            {{TYPE_PREFIX}}3 planeNormal, {{TYPE}} planeD)
        {
            {{TYPE_PREFIX}}3 center = (boxMin + boxMax) * ({{ONE}} / {{TWO}});
            {{TYPE_PREFIX}}3 extents = (boxMax - boxMin) * ({{ONE}} / {{TWO}});
        
            {{TYPE}} r = extents.X * Maths.Abs(planeNormal.X) +
                      extents.Y * Maths.Abs(planeNormal.Y) +
                      extents.Z * Maths.Abs(planeNormal.Z);
        
            {{TYPE}} s = SignedDistancePointToPlane(center, planeNormal, planeD);
        
            if (s > r) return PlaneIntersectionType.Front;
            if (s < -r) return PlaneIntersectionType.Back;
            return PlaneIntersectionType.Intersecting;
        }
        
        #endregion
        
        #region --- Frustum Intersection/Containment Tests ---
        
        // FrustumPlanes should be an array of 6 planes (normals and D values)
        // Order could be: Near, Far, Left, Right, Top, Bottom
        
        /// <summary>
        /// Checks if a point is contained within a frustum defined by 6 planes.
        /// </summary>
        /// <param name="planeNormals">Array of 6 plane normals.</param>
        /// <param name="planeDs">Array of 6 plane D values.</param>
        /// <param name="point">The point to test.</param>
        /// <returns>True if the point is inside or on all planes (on the positive/normal side), false otherwise.</returns>
        public static bool FrustumContainsPoint({{TYPE_PREFIX}}3[] planeNormals, {{TYPE}}[] planeDs, {{TYPE_PREFIX}}3 point)
        {
            if (planeNormals == null || planeNormals.Length < 6 || planeDs == null || planeDs.Length < 6)
                throw new ArgumentException("Frustum planes must be provided as 6 normals and 6 D values.");
        
            for (int i = 0; i < 6; i++)
            {
                if (SignedDistancePointToPlane(point, planeNormals[i], planeDs[i]) < -{{EPSILON}}) // Point is outside (behind) this plane
                {
                    return false;
                }
            }
            return true; // Point is inside or on all planes
        }
        
        /// <summary>
        /// Checks if a sphere intersects or is contained within a frustum.
        /// </summary>
        /// <returns>True if the sphere intersects the frustum, false if it's completely outside.</returns>
        public static bool FrustumIntersectsSphere({{TYPE_PREFIX}}3[] planeNormals, {{TYPE}}[] planeDs, {{TYPE_PREFIX}}3 sphereCenter, {{TYPE}} sphereRadius)
        {
            if (planeNormals == null || planeNormals.Length < 6 || planeDs == null || planeDs.Length < 6)
                throw new ArgumentException("Frustum planes must be provided as 6 normals and 6 D values.");
        
            for (int i = 0; i < 6; i++)
            {
                // If sphere is completely behind any plane, it's outside the frustum
                if (SignedDistancePointToPlane(sphereCenter, planeNormals[i], planeDs[i]) < -sphereRadius)
                {
                    return false;
                }
            }
            // If not completely behind any plane, it must be intersecting or inside.
            // A more precise test for full containment would check if sphere center + radius is inside all planes.
            return true;
        }
        
        /// <summary>
        /// Checks if an AABB intersects or is contained within a frustum.
        /// </summary>
        /// <returns>True if the AABB intersects the frustum, false if it's completely outside.</returns>
        public static bool FrustumIntersectsAABB({{TYPE_PREFIX}}3[] planeNormals, {{TYPE}}[] planeDs, {{TYPE_PREFIX}}3 boxMin, {{TYPE_PREFIX}}3 boxMax)
        {
            if (planeNormals == null || planeNormals.Length < 6 || planeDs == null || planeDs.Length < 6)
                throw new ArgumentException("Frustum planes must be provided as 6 normals and 6 D values.");
        
            for (int i = 0; i < 6; i++)
            {
                // Use the p-vertex/n-vertex test.
                // Find the vertex of the AABB that is "most positive" in the direction of the plane normal (p-vertex)
                // Find the vertex of the AABB that is "most negative" in the direction of the plane normal (n-vertex)
        
                {{TYPE_PREFIX}}3 pVertex = boxMin; // Start with min
                if (planeNormals[i].X >= {{ZERO}}) pVertex.X = boxMax.X;
                if (planeNormals[i].Y >= {{ZERO}}) pVertex.Y = boxMax.Y;
                if (planeNormals[i].Z >= {{ZERO}}) pVertex.Z = boxMax.Z;
        
                // If p-vertex is behind the plane, the entire box is behind (outside)
                if (SignedDistancePointToPlane(pVertex, planeNormals[i], planeDs[i]) < -{{EPSILON}})
                {
                    return false;
                }
            }
            // If not completely behind any plane, it must be intersecting or inside.
            // A full containment test is more complex (all 8 corners inside all planes).
            return true;
        }
        
        #endregion
        
        #region --- Point in Triangle & Barycentric ---
        
        /// <summary>
        /// Computes the barycentric coordinates of a point with respect to a triangle.
        /// The point is projected onto the triangle's plane first.
        /// </summary>
        /// <param name="point">The point to compute coordinates for.</param>
        /// <param name="v0">Triangle vertex 0.</param>
        /// <param name="v1">Triangle vertex 1.</param>
        /// <param name="v2">Triangle vertex 2.</param>
        /// <param name="u">Barycentric coordinate u (weight for v1).</param>
        /// <param name="v">Barycentric coordinate v (weight for v2).</param>
        /// <remarks>w (weight for v0) = 1 - u - v.</remarks>
        public static void PointTriangleBarycentric({{TYPE_PREFIX}}3 point, {{TYPE_PREFIX}}3 v0, {{TYPE_PREFIX}}3 v1, {{TYPE_PREFIX}}3 v2, out {{TYPE}} u, out {{TYPE}} v)
        {
            {{TYPE_PREFIX}}3 edge1 = v1 - v0; // v1 - v0
            {{TYPE_PREFIX}}3 edge2 = v2 - v0; // v2 - v0
            {{TYPE_PREFIX}}3 pv = point - v0;
        
            {{TYPE}} d00 = Maths.Dot(edge1, edge1);
            {{TYPE}} d01 = Maths.Dot(edge1, edge2);
            {{TYPE}} d11 = Maths.Dot(edge2, edge2);
            {{TYPE}} d20 = Maths.Dot(pv, edge1);
            {{TYPE}} d21 = Maths.Dot(pv, edge2);
        
            {{TYPE}} denom = d00 * d11 - d01 * d01;
            if (Maths.Abs(denom) < {{EPSILON}}) // Triangle is degenerate
            {
                u = {{ZERO}}; v = {{ZERO}};
                return;
            }
        
            {{TYPE}} invDenom = {{ONE}} / denom;
            u = (d11 * d20 - d01 * d21) * invDenom;
            v = (d00 * d21 - d01 * d20) * invDenom;
        }
        
        /// <summary>
        /// Checks if a point (defined by its barycentric coordinates u,v) is inside the triangle.
        /// Assumes the point is coplanar with the triangle.
        /// </summary>
        /// <param name="u">Barycentric coordinate u (weight for v1).</param>
        /// <param name="v">Barycentric coordinate v (weight for v2).</param>
        /// <returns>True if the point is inside or on the edge of the triangle.</returns>
        public static bool IsPointInTriangle({{TYPE}} u, {{TYPE}} v)
        {
            return (u >= -{{EPSILON}}) && (v >= -{{EPSILON}}) && (u + v <= {{ONE}} + {{EPSILON}});
        }
        
        #endregion
        
        #endregion
    }
}
