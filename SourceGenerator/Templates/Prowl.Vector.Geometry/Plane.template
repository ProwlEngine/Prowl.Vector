// TEMPLATE_TYPES: float, double
// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace Prowl.Vector.{{NAMESPACE_SUFFIX}}
{
    /// <summary>
    /// Represents a 3D plane defined by a normal vector and distance from origin.
    /// The plane equation is: Normal · Point = D
    /// </summary>
    public struct {{CLASS_NAME}} : IEquatable<{{CLASS_NAME}}>, IFormattable
    {
        /// <summary>The normalized normal vector of the plane.</summary>
        public {{TYPE_PREFIX}}3 Normal;

        /// <summary>The distance from the origin to the plane along the normal.</summary>
        public {{TYPE}} D;

        /// <summary>
        /// Initializes a new plane from a normal vector and distance.
        /// The normal will be normalized.
        /// </summary>
        /// <param name="normal">The normal vector (will be normalized).</param>
        /// <param name="d">The distance from origin.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{CLASS_NAME}}({{TYPE_PREFIX}}3 normal, {{TYPE}} d)
        {
            Normal = Maths.Normalize(normal);
            D = d;
        }

        /// <summary>
        /// Initializes a new plane from three points.
        /// Points should be in counter-clockwise order for outward-facing normal.
        /// </summary>
        /// <param name="point1">First point on the plane.</param>
        /// <param name="point2">Second point on the plane.</param>
        /// <param name="point3">Third point on the plane.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{CLASS_NAME}}({{TYPE_PREFIX}}3 point1, {{TYPE_PREFIX}}3 point2, {{TYPE_PREFIX}}3 point3)
        {
            {{TYPE_PREFIX}}3 edge1 = point2 - point1;
            {{TYPE_PREFIX}}3 edge2 = point3 - point1;
            Normal = Maths.Normalize(Maths.Cross(edge1, edge2));
            D = Maths.Dot(Normal, point1);
        }

        /// <summary>
        /// Initializes a new plane from a normal vector and a point on the plane.
        /// </summary>
        /// <param name="normal">The normal vector (will be normalized).</param>
        /// <param name="pointOnPlane">A point that lies on the plane.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static {{CLASS_NAME}} FromNormalAndPoint({{TYPE_PREFIX}}3 normal, {{TYPE_PREFIX}}3 pointOnPlane)
        {
            {{TYPE_PREFIX}}3 normalizedNormal = Maths.Normalize(normal);
            return new {{CLASS_NAME}}(normalizedNormal, Maths.Dot(normalizedNormal, pointOnPlane));
        }

        /// <summary>
        /// Gets the signed distance from a point to this plane.
        /// Positive if the point is on the side of the normal, negative otherwise.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>The signed distance.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{TYPE}} GetSignedDistanceToPoint({{TYPE_PREFIX}}3 point)
        {
            return Maths.Dot(Normal, point) - D;
        }

        /// <summary>
        /// Gets the absolute distance from a point to this plane.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>The absolute distance.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{TYPE}} GetDistanceToPoint({{TYPE_PREFIX}}3 point)
        {
            return Maths.Abs(GetSignedDistanceToPoint(point));
        }

        /// <summary>
        /// Projects a point onto this plane.
        /// </summary>
        /// <param name="point">The point to project.</param>
        /// <returns>The closest point on the plane.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{TYPE_PREFIX}}3 ClosestPointOnPlane({{TYPE_PREFIX}}3 point)
        {
            {{TYPE}} distance = GetSignedDistanceToPoint(point);
            return point - Normal * distance;
        }

        /// <summary>
        /// Determines which side of the plane a point is on.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>True if the point is on the positive side (normal side) of the plane.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool GetSide({{TYPE_PREFIX}}3 point)
        {
            return GetSignedDistanceToPoint(point) > {{ZERO}};
        }

        /// <summary>
        /// Checks if two points are on the same side of the plane.
        /// </summary>
        /// <param name="point1">First point.</param>
        /// <param name="point2">Second point.</param>
        /// <returns>True if both points are on the same side.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool SameSide({{TYPE_PREFIX}}3 point1, {{TYPE_PREFIX}}3 point2)
        {
            {{TYPE}} d1 = GetSignedDistanceToPoint(point1);
            {{TYPE}} d2 = GetSignedDistanceToPoint(point2);
            return (d1 > {{ZERO}}) == (d2 > {{ZERO}});
        }

        /// <summary>
        /// Flips the plane to face the opposite direction.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Flip()
        {
            Normal = -Normal;
            D = -D;
        }

        /// <summary>
        /// Returns a flipped version of this plane.
        /// </summary>
        /// <returns>A plane facing the opposite direction.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{CLASS_NAME}} Flipped()
        {
            return new {{CLASS_NAME}}(-Normal, -D);
        }

        /// <summary>
        /// Translates the plane by a given offset.
        /// </summary>
        /// <param name="translation">The translation vector.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Translate({{TYPE_PREFIX}}3 translation)
        {
            D += Maths.Dot(Normal, translation);
        }

        /// <summary>
        /// Returns a translated version of this plane.
        /// </summary>
        /// <param name="translation">The translation vector.</param>
        /// <returns>The translated plane.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public {{CLASS_NAME}} Translated({{TYPE_PREFIX}}3 translation)
        {
            return new {{CLASS_NAME}}(Normal, D + Maths.Dot(Normal, translation));
        }

        // --- IEquatable & IFormattable Implementation ---
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals({{CLASS_NAME}} other) => Normal.Equals(other.Normal) && D.Equals(other.D);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj) => obj is {{CLASS_NAME}} other && Equals(other);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode() => HashCode.Combine(Normal, D);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string ToString() => ToString(null, CultureInfo.CurrentCulture);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToString(string? format, IFormatProvider? formatProvider = null)
        {
            return string.Format(formatProvider, "{{CLASS_NAME}}(Normal: {0}, D: {1})", 
                Normal.ToString(format, formatProvider), D.ToString(format, formatProvider));
        }

        public static bool operator ==({{CLASS_NAME}} left, {{CLASS_NAME}} right) => left.Equals(right);
        public static bool operator !=({{CLASS_NAME}} left, {{CLASS_NAME}} right) => !left.Equals(right);
    }
}
