//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-07-02 20:54:16
//

using Xunit;
using Prowl.Vector;
using System;

namespace Prowl.Vector.Tests
{
    public class GeneratedMathTests
    {
        [Fact]
        public void Abs_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Abs(x);
            float expected = System.MathF.Abs((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Abs_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Abs(x);
            double expected = System.Math.Abs((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Abs_IntScalarTest()
        {
            int x = 2;
            int result = Maths.Abs(x);
            int expected = System.Math.Abs((int)2);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Abs_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Abs(x);
            Float2 expected = new Float2(System.MathF.Abs((float)1.5f), System.MathF.Abs((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Abs_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Abs(x);
            Float3 expected = new Float3(System.MathF.Abs((float)1.5f), System.MathF.Abs((float)-1f), System.MathF.Abs((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Abs_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Abs(x);
            Float4 expected = new Float4(System.MathF.Abs((float)1.5f), System.MathF.Abs((float)-1f), System.MathF.Abs((float)4.5f), System.MathF.Abs((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Abs_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Abs(x);
            Double2 expected = new Double2(System.Math.Abs((double)1.5), System.Math.Abs((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Abs_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Abs(x);
            Double3 expected = new Double3(System.Math.Abs((double)1.5), System.Math.Abs((double)-1), System.Math.Abs((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Abs_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Abs(x);
            Double4 expected = new Double4(System.Math.Abs((double)1.5), System.Math.Abs((double)-1), System.Math.Abs((double)4.5), System.Math.Abs((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Abs_Int2Test()
        {
            Int2 x = new Int2(2, -2);
            Int2 result = Maths.Abs(x);
            Int2 expected = new Int2(System.Math.Abs((int)2), System.Math.Abs((int)-2));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Abs_Int3Test()
        {
            Int3 x = new Int3(2, -2, 6);
            Int3 result = Maths.Abs(x);
            Int3 expected = new Int3(System.Math.Abs((int)2), System.Math.Abs((int)-2), System.Math.Abs((int)6));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Abs_Int4Test()
        {
            Int4 x = new Int4(2, -2, 6, -4);
            Int4 result = Maths.Abs(x);
            Int4 expected = new Int4(System.Math.Abs((int)2), System.Math.Abs((int)-2), System.Math.Abs((int)6), System.Math.Abs((int)-4));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Acos_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Acos(x);
            float expected = System.MathF.Acos((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Acos_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Acos(x);
            double expected = System.Math.Acos((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Acos_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Acos(x);
            Float2 expected = new Float2(System.MathF.Acos((float)1.5f), System.MathF.Acos((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Acos_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Acos(x);
            Float3 expected = new Float3(System.MathF.Acos((float)1.5f), System.MathF.Acos((float)-1f), System.MathF.Acos((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Acos_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Acos(x);
            Float4 expected = new Float4(System.MathF.Acos((float)1.5f), System.MathF.Acos((float)-1f), System.MathF.Acos((float)4.5f), System.MathF.Acos((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Acos_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Acos(x);
            Double2 expected = new Double2(System.Math.Acos((double)1.5), System.Math.Acos((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Acos_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Acos(x);
            Double3 expected = new Double3(System.Math.Acos((double)1.5), System.Math.Acos((double)-1), System.Math.Acos((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Acos_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Acos(x);
            Double4 expected = new Double4(System.Math.Acos((double)1.5), System.Math.Acos((double)-1), System.Math.Acos((double)4.5), System.Math.Acos((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Asin_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Asin(x);
            float expected = System.MathF.Asin((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Asin_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Asin(x);
            double expected = System.Math.Asin((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Asin_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Asin(x);
            Float2 expected = new Float2(System.MathF.Asin((float)1.5f), System.MathF.Asin((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Asin_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Asin(x);
            Float3 expected = new Float3(System.MathF.Asin((float)1.5f), System.MathF.Asin((float)-1f), System.MathF.Asin((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Asin_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Asin(x);
            Float4 expected = new Float4(System.MathF.Asin((float)1.5f), System.MathF.Asin((float)-1f), System.MathF.Asin((float)4.5f), System.MathF.Asin((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Asin_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Asin(x);
            Double2 expected = new Double2(System.Math.Asin((double)1.5), System.Math.Asin((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Asin_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Asin(x);
            Double3 expected = new Double3(System.Math.Asin((double)1.5), System.Math.Asin((double)-1), System.Math.Asin((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Asin_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Asin(x);
            Double4 expected = new Double4(System.Math.Asin((double)1.5), System.Math.Asin((double)-1), System.Math.Asin((double)4.5), System.Math.Asin((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Atan_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Atan(x);
            float expected = System.MathF.Atan((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Atan_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Atan(x);
            double expected = System.Math.Atan((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Atan_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Atan(x);
            Float2 expected = new Float2(System.MathF.Atan((float)1.5f), System.MathF.Atan((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Atan_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Atan(x);
            Float3 expected = new Float3(System.MathF.Atan((float)1.5f), System.MathF.Atan((float)-1f), System.MathF.Atan((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Atan_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Atan(x);
            Float4 expected = new Float4(System.MathF.Atan((float)1.5f), System.MathF.Atan((float)-1f), System.MathF.Atan((float)4.5f), System.MathF.Atan((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Atan_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Atan(x);
            Double2 expected = new Double2(System.Math.Atan((double)1.5), System.Math.Atan((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Atan_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Atan(x);
            Double3 expected = new Double3(System.Math.Atan((double)1.5), System.Math.Atan((double)-1), System.Math.Atan((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Atan_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Atan(x);
            Double4 expected = new Double4(System.Math.Atan((double)1.5), System.Math.Atan((double)-1), System.Math.Atan((double)4.5), System.Math.Atan((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Atan2_FloatScalarTest()
        {
            float x = 1.5f;
            float y = -1f;
            float result = Maths.Atan2(x, y);
            float expected = System.MathF.Atan2((float)1.5f, (float)-1f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Atan2_DoubleScalarTest()
        {
            double x = 1.5;
            double y = -1;
            double result = Maths.Atan2(x, y);
            double expected = System.Math.Atan2((double)1.5, (double)-1);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Atan2_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 y = new Float2(4.5f, -2f);
            Float2 result = Maths.Atan2(x, y);
            Float2 expected = new Float2(System.MathF.Atan2((float)1.5f, (float)4.5f), System.MathF.Atan2((float)-1f, (float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Atan2_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 y = new Float3(-2f, 7.5f, -3f);
            Float3 result = Maths.Atan2(x, y);
            Float3 expected = new Float3(System.MathF.Atan2((float)1.5f, (float)-2f), System.MathF.Atan2((float)-1f, (float)7.5f), System.MathF.Atan2((float)4.5f, (float)-3f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Atan2_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 y = new Float4(7.5f, -3f, 10.5f, -4f);
            Float4 result = Maths.Atan2(x, y);
            Float4 expected = new Float4(System.MathF.Atan2((float)1.5f, (float)7.5f), System.MathF.Atan2((float)-1f, (float)-3f), System.MathF.Atan2((float)4.5f, (float)10.5f), System.MathF.Atan2((float)-2f, (float)-4f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Atan2_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 y = new Double2(4.5, -2);
            Double2 result = Maths.Atan2(x, y);
            Double2 expected = new Double2(System.Math.Atan2((double)1.5, (double)4.5), System.Math.Atan2((double)-1, (double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Atan2_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 y = new Double3(-2, 7.5, -3);
            Double3 result = Maths.Atan2(x, y);
            Double3 expected = new Double3(System.Math.Atan2((double)1.5, (double)-2), System.Math.Atan2((double)-1, (double)7.5), System.Math.Atan2((double)4.5, (double)-3));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Atan2_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 y = new Double4(7.5, -3, 10.5, -4);
            Double4 result = Maths.Atan2(x, y);
            Double4 expected = new Double4(System.Math.Atan2((double)1.5, (double)7.5), System.Math.Atan2((double)-1, (double)-3), System.Math.Atan2((double)4.5, (double)10.5), System.Math.Atan2((double)-2, (double)-4));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Ceiling_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Ceiling(x);
            float expected = System.MathF.Ceiling((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Ceiling_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Ceiling(x);
            double expected = System.Math.Ceiling((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Ceiling_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Ceiling(x);
            Float2 expected = new Float2(System.MathF.Ceiling((float)1.5f), System.MathF.Ceiling((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Ceiling_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Ceiling(x);
            Float3 expected = new Float3(System.MathF.Ceiling((float)1.5f), System.MathF.Ceiling((float)-1f), System.MathF.Ceiling((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Ceiling_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Ceiling(x);
            Float4 expected = new Float4(System.MathF.Ceiling((float)1.5f), System.MathF.Ceiling((float)-1f), System.MathF.Ceiling((float)4.5f), System.MathF.Ceiling((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Ceiling_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Ceiling(x);
            Double2 expected = new Double2(System.Math.Ceiling((double)1.5), System.Math.Ceiling((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Ceiling_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Ceiling(x);
            Double3 expected = new Double3(System.Math.Ceiling((double)1.5), System.Math.Ceiling((double)-1), System.Math.Ceiling((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Ceiling_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Ceiling(x);
            Double4 expected = new Double4(System.Math.Ceiling((double)1.5), System.Math.Ceiling((double)-1), System.Math.Ceiling((double)4.5), System.Math.Ceiling((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Cos_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Cos(x);
            float expected = System.MathF.Cos((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Cos_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Cos(x);
            double expected = System.Math.Cos((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Cos_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Cos(x);
            Float2 expected = new Float2(System.MathF.Cos((float)1.5f), System.MathF.Cos((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Cos_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Cos(x);
            Float3 expected = new Float3(System.MathF.Cos((float)1.5f), System.MathF.Cos((float)-1f), System.MathF.Cos((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Cos_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Cos(x);
            Float4 expected = new Float4(System.MathF.Cos((float)1.5f), System.MathF.Cos((float)-1f), System.MathF.Cos((float)4.5f), System.MathF.Cos((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Cos_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Cos(x);
            Double2 expected = new Double2(System.Math.Cos((double)1.5), System.Math.Cos((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Cos_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Cos(x);
            Double3 expected = new Double3(System.Math.Cos((double)1.5), System.Math.Cos((double)-1), System.Math.Cos((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Cos_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Cos(x);
            Double4 expected = new Double4(System.Math.Cos((double)1.5), System.Math.Cos((double)-1), System.Math.Cos((double)4.5), System.Math.Cos((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Exp_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Exp(x);
            float expected = System.MathF.Exp((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Exp_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Exp(x);
            double expected = System.Math.Exp((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Exp_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Exp(x);
            Float2 expected = new Float2(System.MathF.Exp((float)1.5f), System.MathF.Exp((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Exp_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Exp(x);
            Float3 expected = new Float3(System.MathF.Exp((float)1.5f), System.MathF.Exp((float)-1f), System.MathF.Exp((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Exp_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Exp(x);
            Float4 expected = new Float4(System.MathF.Exp((float)1.5f), System.MathF.Exp((float)-1f), System.MathF.Exp((float)4.5f), System.MathF.Exp((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Exp_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Exp(x);
            Double2 expected = new Double2(System.Math.Exp((double)1.5), System.Math.Exp((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Exp_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Exp(x);
            Double3 expected = new Double3(System.Math.Exp((double)1.5), System.Math.Exp((double)-1), System.Math.Exp((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Exp_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Exp(x);
            Double4 expected = new Double4(System.Math.Exp((double)1.5), System.Math.Exp((double)-1), System.Math.Exp((double)4.5), System.Math.Exp((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Floor_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Floor(x);
            float expected = System.MathF.Floor((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Floor_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Floor(x);
            double expected = System.Math.Floor((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Floor_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Floor(x);
            Float2 expected = new Float2(System.MathF.Floor((float)1.5f), System.MathF.Floor((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Floor_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Floor(x);
            Float3 expected = new Float3(System.MathF.Floor((float)1.5f), System.MathF.Floor((float)-1f), System.MathF.Floor((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Floor_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Floor(x);
            Float4 expected = new Float4(System.MathF.Floor((float)1.5f), System.MathF.Floor((float)-1f), System.MathF.Floor((float)4.5f), System.MathF.Floor((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Floor_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Floor(x);
            Double2 expected = new Double2(System.Math.Floor((double)1.5), System.Math.Floor((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Floor_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Floor(x);
            Double3 expected = new Double3(System.Math.Floor((double)1.5), System.Math.Floor((double)-1), System.Math.Floor((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Floor_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Floor(x);
            Double4 expected = new Double4(System.Math.Floor((double)1.5), System.Math.Floor((double)-1), System.Math.Floor((double)4.5), System.Math.Floor((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Inverse_Float2x2_Identity_Test()
        {
            // Test inverse of identity matrix - should return identity
            Float2x2 identity = new Float2x2(new Float2(1.0f, 0.0f), new Float2(0.0f, 1.0f));
            
            Float2x2 inverse = Maths.Inverse(identity);
            
            // Inverse of identity should be identity
            Assert.Equal(1.0f, inverse.c0.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.X, 0.0001f);
            Assert.Equal(1.0f, inverse.c1.Y, 0.0001f);
        }

        [Fact]
        public void Inverse_Float2x2_Diagonal_Test()
        {
            // Test inverse of diagonal matrix
            Float2x2 diagonal = new Float2x2(new Float2(2.0f, 0.0f), new Float2(0.0f, 3.0f));
            
            Float2x2 inverse = Maths.Inverse(diagonal);
            
            // Inverse of diagonal matrix should have reciprocal diagonal elements
            Assert.Equal(1.0f / 2.0f, inverse.c0.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.X, 0.0001f);
            Assert.Equal(1.0f / 3.0f, inverse.c1.Y, 0.0001f);
        }

        [Fact]
        public void Inverse_Float2x2_Known_Test()
        {
            // Test known 2x2 matrix: [[1, 2], [3, 4]]
            // Determinant = 1*4 - 2*3 = -2
            // Inverse = (1/det) * [[4, -2], [-3, 1]] = [[-2, 1], [1.5, -0.5]]
            Float2x2 matrix = new Float2x2(
                new Float2(1.0f, 3.0f),
                new Float2(2.0f, 4.0f)
            );
            
            Float2x2 inverse = Maths.Inverse(matrix);
            
            // Check expected inverse values
            Assert.Equal(-2.0f, inverse.c0.X, 0.0001f);
            Assert.Equal(1.5f, inverse.c0.Y, 0.0001f);
            Assert.Equal(1.0f, inverse.c1.X, 0.0001f);
            Assert.Equal(-0.5f, inverse.c1.Y, 0.0001f);
        }

        [Fact]
        public void Inverse_Float2x2_InverseTimesOriginal_Test()
        {
            // Test that Inverse(M) * M = Identity
            Float2x2 original = new Float2x2(new Float2(2.0f, 0.1f), new Float2(0.1f, 3.0f));
            
            Float2x2 inverse = Maths.Inverse(original);
            Float2x2 product = Maths.Mul(inverse, original);
            
            // Product should be approximately identity matrix
            Assert.Equal(1.0f, product.c0.X, 0.0001f);
            Assert.Equal(0.0f, product.c0.Y, 0.0001f);
            Assert.Equal(0.0f, product.c1.X, 0.0001f);
            Assert.Equal(1.0f, product.c1.Y, 0.0001f);
        }

        [Fact]
        public void Inverse_Float2x2_SingularMatrix_ThrowsException()
        {
            // Test that singular (non-invertible) matrix throws ArgumentException
            Float2x2 singular = new Float2x2(new Float2(1.0f, 2.0f), new Float2(2.0f, 4.0f));
            
            Assert.Throws<ArgumentException>(() => Maths.Inverse(singular));
        }

        [Fact]
        public void Inverse_Float3x3_Identity_Test()
        {
            // Test inverse of identity matrix - should return identity
            Float3x3 identity = new Float3x3(new Float3(1.0f, 0.0f, 0.0f), new Float3(0.0f, 1.0f, 0.0f), new Float3(0.0f, 0.0f, 1.0f));
            
            Float3x3 inverse = Maths.Inverse(identity);
            
            // Inverse of identity should be identity
            Assert.Equal(1.0f, inverse.c0.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.X, 0.0001f);
            Assert.Equal(1.0f, inverse.c1.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.Y, 0.0001f);
            Assert.Equal(1.0f, inverse.c2.Z, 0.0001f);
        }

        [Fact]
        public void Inverse_Float3x3_Diagonal_Test()
        {
            // Test inverse of diagonal matrix
            Float3x3 diagonal = new Float3x3(new Float3(2.0f, 0.0f, 0.0f), new Float3(0.0f, 3.0f, 0.0f), new Float3(0.0f, 0.0f, 4.0f));
            
            Float3x3 inverse = Maths.Inverse(diagonal);
            
            // Inverse of diagonal matrix should have reciprocal diagonal elements
            Assert.Equal(1.0f / 2.0f, inverse.c0.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.X, 0.0001f);
            Assert.Equal(1.0f / 3.0f, inverse.c1.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.Y, 0.0001f);
            Assert.Equal(1.0f / 4.0f, inverse.c2.Z, 0.0001f);
        }

        [Fact]
        public void Inverse_Float3x3_Known_Test()
        {
            // Test known 3x3 matrix with simple values
            Float3x3 matrix = new Float3x3(
                new Float3(2.0f, 0.0f, 0.0f),
                new Float3(0.0f, 3.0f, 0.0f),
                new Float3(0.0f, 0.0f, 4.0f)
            );
            
            Float3x3 inverse = Maths.Inverse(matrix);
            
            // This is a diagonal matrix, so inverse should be reciprocals
            Assert.Equal(0.5f, inverse.c0.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.X, 0.0001f);
            Assert.Equal(1.0f / 3.0f, inverse.c1.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.Y, 0.0001f);
            Assert.Equal(0.25f, inverse.c2.Z, 0.0001f);
        }

        [Fact]
        public void Inverse_Float3x3_InverseTimesOriginal_Test()
        {
            // Test that Inverse(M) * M = Identity
            Float3x3 original = new Float3x3(new Float3(2.0f, 0.1f, 0.2f), new Float3(0.1f, 3.0f, 0f), new Float3(0.2f, 0f, 4.0f));
            
            Float3x3 inverse = Maths.Inverse(original);
            Float3x3 product = Maths.Mul(inverse, original);
            
            // Product should be approximately identity matrix
            Assert.Equal(1.0f, product.c0.X, 0.0001f);
            Assert.Equal(0.0f, product.c0.Y, 0.0001f);
            Assert.Equal(0.0f, product.c0.Z, 0.0001f);
            Assert.Equal(0.0f, product.c1.X, 0.0001f);
            Assert.Equal(1.0f, product.c1.Y, 0.0001f);
            Assert.Equal(0.0f, product.c1.Z, 0.0001f);
            Assert.Equal(0.0f, product.c2.X, 0.0001f);
            Assert.Equal(0.0f, product.c2.Y, 0.0001f);
            Assert.Equal(1.0f, product.c2.Z, 0.0001f);
        }

        [Fact]
        public void Inverse_Float3x3_SingularMatrix_ThrowsException()
        {
            // Test that singular (non-invertible) matrix throws ArgumentException
            Float3x3 singular = new Float3x3(new Float3(1.0f, 2.0f, 3.0f), new Float3(4.0f, 5.0f, 6.0f), new Float3(5.0f, 7.0f, 9.0f));
            
            Assert.Throws<ArgumentException>(() => Maths.Inverse(singular));
        }

        [Fact]
        public void Inverse_Float4x4_Identity_Test()
        {
            // Test inverse of identity matrix - should return identity
            Float4x4 identity = new Float4x4(new Float4(1.0f, 0.0f, 0.0f, 0.0f), new Float4(0.0f, 1.0f, 0.0f, 0.0f), new Float4(0.0f, 0.0f, 1.0f, 0.0f), new Float4(0.0f, 0.0f, 0.0f, 1.0f));
            
            Float4x4 inverse = Maths.Inverse(identity);
            
            // Inverse of identity should be identity
            Assert.Equal(1.0f, inverse.c0.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.W, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.X, 0.0001f);
            Assert.Equal(1.0f, inverse.c1.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.W, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.Y, 0.0001f);
            Assert.Equal(1.0f, inverse.c2.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.W, 0.0001f);
            Assert.Equal(0.0f, inverse.c3.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c3.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c3.Z, 0.0001f);
            Assert.Equal(1.0f, inverse.c3.W, 0.0001f);
        }

        [Fact]
        public void Inverse_Float4x4_Diagonal_Test()
        {
            // Test inverse of diagonal matrix
            Float4x4 diagonal = new Float4x4(new Float4(2.0f, 0.0f, 0.0f, 0.0f), new Float4(0.0f, 3.0f, 0.0f, 0.0f), new Float4(0.0f, 0.0f, 4.0f, 0.0f), new Float4(0.0f, 0.0f, 0.0f, 5.0f));
            
            Float4x4 inverse = Maths.Inverse(diagonal);
            
            // Inverse of diagonal matrix should have reciprocal diagonal elements
            Assert.Equal(1.0f / 2.0f, inverse.c0.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.W, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.X, 0.0001f);
            Assert.Equal(1.0f / 3.0f, inverse.c1.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.W, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.Y, 0.0001f);
            Assert.Equal(1.0f / 4.0f, inverse.c2.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.W, 0.0001f);
            Assert.Equal(0.0f, inverse.c3.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c3.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c3.Z, 0.0001f);
            Assert.Equal(1.0f / 5.0f, inverse.c3.W, 0.0001f);
        }

        [Fact]
        public void Inverse_Float4x4_Known_Test()
        {
            // Test known 4x4 diagonal matrix
            Float4x4 matrix = new Float4x4(
                new Float4(2.0f, 0.0f, 0.0f, 0.0f),
                new Float4(0.0f, 4.0f, 0.0f, 0.0f),
                new Float4(0.0f, 0.0f, 8.0f, 0.0f),
                new Float4(0.0f, 0.0f, 0.0f, 0.5f)
            );
            
            Float4x4 inverse = Maths.Inverse(matrix);
            
            // Diagonal matrix inverse should be reciprocals
            Assert.Equal(0.5f, inverse.c0.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c0.W, 0.0001f);
            
            Assert.Equal(0.0f, inverse.c1.X, 0.0001f);
            Assert.Equal(0.25f, inverse.c1.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c1.W, 0.0001f);
            
            Assert.Equal(0.0f, inverse.c2.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.Y, 0.0001f);
            Assert.Equal(0.125f, inverse.c2.Z, 0.0001f);
            Assert.Equal(0.0f, inverse.c2.W, 0.0001f);
            
            Assert.Equal(0.0f, inverse.c3.X, 0.0001f);
            Assert.Equal(0.0f, inverse.c3.Y, 0.0001f);
            Assert.Equal(0.0f, inverse.c3.Z, 0.0001f);
            Assert.Equal(2.0f, inverse.c3.W, 0.0001f);
        }

        [Fact]
        public void Inverse_Float4x4_InverseTimesOriginal_Test()
        {
            // Test that Inverse(M) * M = Identity
            Float4x4 original = new Float4x4(new Float4(2.0f, 0.1f, 0.2f, 0f), new Float4(0.1f, 3.0f, 0f, 0.1f), new Float4(0.2f, 0f, 4.0f, 0.2f), new Float4(0f, 0.1f, 0.2f, 5.0f));
            
            Float4x4 inverse = Maths.Inverse(original);
            Float4x4 product = Maths.Mul(inverse, original);
            
            // Product should be approximately identity matrix
            Assert.Equal(1.0f, product.c0.X, 0.0001f);
            Assert.Equal(0.0f, product.c0.Y, 0.0001f);
            Assert.Equal(0.0f, product.c0.Z, 0.0001f);
            Assert.Equal(0.0f, product.c0.W, 0.0001f);
            Assert.Equal(0.0f, product.c1.X, 0.0001f);
            Assert.Equal(1.0f, product.c1.Y, 0.0001f);
            Assert.Equal(0.0f, product.c1.Z, 0.0001f);
            Assert.Equal(0.0f, product.c1.W, 0.0001f);
            Assert.Equal(0.0f, product.c2.X, 0.0001f);
            Assert.Equal(0.0f, product.c2.Y, 0.0001f);
            Assert.Equal(1.0f, product.c2.Z, 0.0001f);
            Assert.Equal(0.0f, product.c2.W, 0.0001f);
            Assert.Equal(0.0f, product.c3.X, 0.0001f);
            Assert.Equal(0.0f, product.c3.Y, 0.0001f);
            Assert.Equal(0.0f, product.c3.Z, 0.0001f);
            Assert.Equal(1.0f, product.c3.W, 0.0001f);
        }

        [Fact]
        public void Inverse_Float4x4_SingularMatrix_ThrowsException()
        {
            // Test that singular (non-invertible) matrix throws ArgumentException
            Float4x4 singular = new Float4x4(new Float4(1.0f, 0.0f, 0.0f, 0.0f), new Float4(0.0f, 1.0f, 0.0f, 0.0f), new Float4(0.0f, 0.0f, 1.0f, 0.0f), new Float4(0.0f, 0.0f, 0.0f, 0.0f));
            
            Assert.Throws<ArgumentException>(() => Maths.Inverse(singular));
        }

        [Fact]
        public void Inverse_Double2x2_Identity_Test()
        {
            // Test inverse of identity matrix - should return identity
            Double2x2 identity = new Double2x2(new Double2(1.0, 0.0), new Double2(0.0, 1.0));
            
            Double2x2 inverse = Maths.Inverse(identity);
            
            // Inverse of identity should be identity
            Assert.Equal(1.0, inverse.c0.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.X, 0.0000000001);
            Assert.Equal(1.0, inverse.c1.Y, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double2x2_Diagonal_Test()
        {
            // Test inverse of diagonal matrix
            Double2x2 diagonal = new Double2x2(new Double2(2.0, 0.0), new Double2(0.0, 3.0));
            
            Double2x2 inverse = Maths.Inverse(diagonal);
            
            // Inverse of diagonal matrix should have reciprocal diagonal elements
            Assert.Equal(1.0 / 2.0, inverse.c0.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.X, 0.0000000001);
            Assert.Equal(1.0 / 3.0, inverse.c1.Y, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double2x2_Known_Test()
        {
            // Test known 2x2 matrix: [[1, 2], [3, 4]]
            // Determinant = 1*4 - 2*3 = -2
            // Inverse = (1/det) * [[4, -2], [-3, 1]] = [[-2, 1], [1.5, -0.5]]
            Double2x2 matrix = new Double2x2(
                new Double2(1.0, 3.0),
                new Double2(2.0, 4.0)
            );
            
            Double2x2 inverse = Maths.Inverse(matrix);
            
            // Check expected inverse values
            Assert.Equal(-2.0, inverse.c0.X, 0.0000000001);
            Assert.Equal(1.5, inverse.c0.Y, 0.0000000001);
            Assert.Equal(1.0, inverse.c1.X, 0.0000000001);
            Assert.Equal(-0.5, inverse.c1.Y, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double2x2_InverseTimesOriginal_Test()
        {
            // Test that Inverse(M) * M = Identity
            Double2x2 original = new Double2x2(new Double2(2.0, 0.1), new Double2(0.1, 3.0));
            
            Double2x2 inverse = Maths.Inverse(original);
            Double2x2 product = Maths.Mul(inverse, original);
            
            // Product should be approximately identity matrix
            Assert.Equal(1.0, product.c0.X, 0.0000000001);
            Assert.Equal(0.0, product.c0.Y, 0.0000000001);
            Assert.Equal(0.0, product.c1.X, 0.0000000001);
            Assert.Equal(1.0, product.c1.Y, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double2x2_SingularMatrix_ThrowsException()
        {
            // Test that singular (non-invertible) matrix throws ArgumentException
            Double2x2 singular = new Double2x2(new Double2(1.0, 2.0), new Double2(2.0, 4.0));
            
            Assert.Throws<ArgumentException>(() => Maths.Inverse(singular));
        }

        [Fact]
        public void Inverse_Double3x3_Identity_Test()
        {
            // Test inverse of identity matrix - should return identity
            Double3x3 identity = new Double3x3(new Double3(1.0, 0.0, 0.0), new Double3(0.0, 1.0, 0.0), new Double3(0.0, 0.0, 1.0));
            
            Double3x3 inverse = Maths.Inverse(identity);
            
            // Inverse of identity should be identity
            Assert.Equal(1.0, inverse.c0.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.X, 0.0000000001);
            Assert.Equal(1.0, inverse.c1.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.Y, 0.0000000001);
            Assert.Equal(1.0, inverse.c2.Z, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double3x3_Diagonal_Test()
        {
            // Test inverse of diagonal matrix
            Double3x3 diagonal = new Double3x3(new Double3(2.0, 0.0, 0.0), new Double3(0.0, 3.0, 0.0), new Double3(0.0, 0.0, 4.0));
            
            Double3x3 inverse = Maths.Inverse(diagonal);
            
            // Inverse of diagonal matrix should have reciprocal diagonal elements
            Assert.Equal(1.0 / 2.0, inverse.c0.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.X, 0.0000000001);
            Assert.Equal(1.0 / 3.0, inverse.c1.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.Y, 0.0000000001);
            Assert.Equal(1.0 / 4.0, inverse.c2.Z, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double3x3_Known_Test()
        {
            // Test known 3x3 matrix with simple values
            Double3x3 matrix = new Double3x3(
                new Double3(2.0, 0.0, 0.0),
                new Double3(0.0, 3.0, 0.0),
                new Double3(0.0, 0.0, 4.0)
            );
            
            Double3x3 inverse = Maths.Inverse(matrix);
            
            // This is a diagonal matrix, so inverse should be reciprocals
            Assert.Equal(0.5, inverse.c0.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.X, 0.0000000001);
            Assert.Equal(1.0 / 3.0, inverse.c1.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.Y, 0.0000000001);
            Assert.Equal(0.25, inverse.c2.Z, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double3x3_InverseTimesOriginal_Test()
        {
            // Test that Inverse(M) * M = Identity
            Double3x3 original = new Double3x3(new Double3(2.0, 0.1, 0.2), new Double3(0.1, 3.0, 0), new Double3(0.2, 0, 4.0));
            
            Double3x3 inverse = Maths.Inverse(original);
            Double3x3 product = Maths.Mul(inverse, original);
            
            // Product should be approximately identity matrix
            Assert.Equal(1.0, product.c0.X, 0.0000000001);
            Assert.Equal(0.0, product.c0.Y, 0.0000000001);
            Assert.Equal(0.0, product.c0.Z, 0.0000000001);
            Assert.Equal(0.0, product.c1.X, 0.0000000001);
            Assert.Equal(1.0, product.c1.Y, 0.0000000001);
            Assert.Equal(0.0, product.c1.Z, 0.0000000001);
            Assert.Equal(0.0, product.c2.X, 0.0000000001);
            Assert.Equal(0.0, product.c2.Y, 0.0000000001);
            Assert.Equal(1.0, product.c2.Z, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double3x3_SingularMatrix_ThrowsException()
        {
            // Test that singular (non-invertible) matrix throws ArgumentException
            Double3x3 singular = new Double3x3(new Double3(1.0, 2.0, 3.0), new Double3(4.0, 5.0, 6.0), new Double3(5.0, 7.0, 9.0));
            
            Assert.Throws<ArgumentException>(() => Maths.Inverse(singular));
        }

        [Fact]
        public void Inverse_Double4x4_Identity_Test()
        {
            // Test inverse of identity matrix - should return identity
            Double4x4 identity = new Double4x4(new Double4(1.0, 0.0, 0.0, 0.0), new Double4(0.0, 1.0, 0.0, 0.0), new Double4(0.0, 0.0, 1.0, 0.0), new Double4(0.0, 0.0, 0.0, 1.0));
            
            Double4x4 inverse = Maths.Inverse(identity);
            
            // Inverse of identity should be identity
            Assert.Equal(1.0, inverse.c0.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.W, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.X, 0.0000000001);
            Assert.Equal(1.0, inverse.c1.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.W, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.Y, 0.0000000001);
            Assert.Equal(1.0, inverse.c2.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.W, 0.0000000001);
            Assert.Equal(0.0, inverse.c3.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c3.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c3.Z, 0.0000000001);
            Assert.Equal(1.0, inverse.c3.W, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double4x4_Diagonal_Test()
        {
            // Test inverse of diagonal matrix
            Double4x4 diagonal = new Double4x4(new Double4(2.0, 0.0, 0.0, 0.0), new Double4(0.0, 3.0, 0.0, 0.0), new Double4(0.0, 0.0, 4.0, 0.0), new Double4(0.0, 0.0, 0.0, 5.0));
            
            Double4x4 inverse = Maths.Inverse(diagonal);
            
            // Inverse of diagonal matrix should have reciprocal diagonal elements
            Assert.Equal(1.0 / 2.0, inverse.c0.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.W, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.X, 0.0000000001);
            Assert.Equal(1.0 / 3.0, inverse.c1.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.W, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.Y, 0.0000000001);
            Assert.Equal(1.0 / 4.0, inverse.c2.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.W, 0.0000000001);
            Assert.Equal(0.0, inverse.c3.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c3.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c3.Z, 0.0000000001);
            Assert.Equal(1.0 / 5.0, inverse.c3.W, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double4x4_Known_Test()
        {
            // Test known 4x4 diagonal matrix
            Double4x4 matrix = new Double4x4(
                new Double4(2.0, 0.0, 0.0, 0.0),
                new Double4(0.0, 4.0, 0.0, 0.0),
                new Double4(0.0, 0.0, 8.0, 0.0),
                new Double4(0.0, 0.0, 0.0, 0.5)
            );
            
            Double4x4 inverse = Maths.Inverse(matrix);
            
            // Diagonal matrix inverse should be reciprocals
            Assert.Equal(0.5, inverse.c0.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c0.W, 0.0000000001);
            
            Assert.Equal(0.0, inverse.c1.X, 0.0000000001);
            Assert.Equal(0.25, inverse.c1.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c1.W, 0.0000000001);
            
            Assert.Equal(0.0, inverse.c2.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.Y, 0.0000000001);
            Assert.Equal(0.125, inverse.c2.Z, 0.0000000001);
            Assert.Equal(0.0, inverse.c2.W, 0.0000000001);
            
            Assert.Equal(0.0, inverse.c3.X, 0.0000000001);
            Assert.Equal(0.0, inverse.c3.Y, 0.0000000001);
            Assert.Equal(0.0, inverse.c3.Z, 0.0000000001);
            Assert.Equal(2.0, inverse.c3.W, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double4x4_InverseTimesOriginal_Test()
        {
            // Test that Inverse(M) * M = Identity
            Double4x4 original = new Double4x4(new Double4(2.0, 0.1, 0.2, 0), new Double4(0.1, 3.0, 0, 0.1), new Double4(0.2, 0, 4.0, 0.2), new Double4(0, 0.1, 0.2, 5.0));
            
            Double4x4 inverse = Maths.Inverse(original);
            Double4x4 product = Maths.Mul(inverse, original);
            
            // Product should be approximately identity matrix
            Assert.Equal(1.0, product.c0.X, 0.0000000001);
            Assert.Equal(0.0, product.c0.Y, 0.0000000001);
            Assert.Equal(0.0, product.c0.Z, 0.0000000001);
            Assert.Equal(0.0, product.c0.W, 0.0000000001);
            Assert.Equal(0.0, product.c1.X, 0.0000000001);
            Assert.Equal(1.0, product.c1.Y, 0.0000000001);
            Assert.Equal(0.0, product.c1.Z, 0.0000000001);
            Assert.Equal(0.0, product.c1.W, 0.0000000001);
            Assert.Equal(0.0, product.c2.X, 0.0000000001);
            Assert.Equal(0.0, product.c2.Y, 0.0000000001);
            Assert.Equal(1.0, product.c2.Z, 0.0000000001);
            Assert.Equal(0.0, product.c2.W, 0.0000000001);
            Assert.Equal(0.0, product.c3.X, 0.0000000001);
            Assert.Equal(0.0, product.c3.Y, 0.0000000001);
            Assert.Equal(0.0, product.c3.Z, 0.0000000001);
            Assert.Equal(1.0, product.c3.W, 0.0000000001);
        }

        [Fact]
        public void Inverse_Double4x4_SingularMatrix_ThrowsException()
        {
            // Test that singular (non-invertible) matrix throws ArgumentException
            Double4x4 singular = new Double4x4(new Double4(1.0, 0.0, 0.0, 0.0), new Double4(0.0, 1.0, 0.0, 0.0), new Double4(0.0, 0.0, 1.0, 0.0), new Double4(0.0, 0.0, 0.0, 0.0));
            
            Assert.Throws<ArgumentException>(() => Maths.Inverse(singular));
        }

        [Fact]
        public void Log_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Log(x);
            float expected = System.MathF.Log((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Log_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Log(x);
            double expected = System.Math.Log((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Log_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Log(x);
            Float2 expected = new Float2(System.MathF.Log((float)1.5f), System.MathF.Log((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Log_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Log(x);
            Float3 expected = new Float3(System.MathF.Log((float)1.5f), System.MathF.Log((float)-1f), System.MathF.Log((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Log_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Log(x);
            Float4 expected = new Float4(System.MathF.Log((float)1.5f), System.MathF.Log((float)-1f), System.MathF.Log((float)4.5f), System.MathF.Log((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Log_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Log(x);
            Double2 expected = new Double2(System.Math.Log((double)1.5), System.Math.Log((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Log_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Log(x);
            Double3 expected = new Double3(System.Math.Log((double)1.5), System.Math.Log((double)-1), System.Math.Log((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Log_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Log(x);
            Double4 expected = new Double4(System.Math.Log((double)1.5), System.Math.Log((double)-1), System.Math.Log((double)4.5), System.Math.Log((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Max_FloatScalarTest()
        {
            float x = 1.5f;
            float y = -1f;
            float result = Maths.Max(x, y);
            float expected = System.MathF.Max((float)1.5f, (float)-1f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Max_DoubleScalarTest()
        {
            double x = 1.5;
            double y = -1;
            double result = Maths.Max(x, y);
            double expected = System.Math.Max((double)1.5, (double)-1);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Max_IntScalarTest()
        {
            int x = 2;
            int y = -2;
            int result = Maths.Max(x, y);
            int expected = System.Math.Max((int)2, (int)-2);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Max_ByteScalarTest()
        {
            byte x = (byte)1;
            byte y = (byte)2;
            byte result = Maths.Max(x, y);
            byte expected = System.Math.Max((byte)1, (byte)2);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Max_UShortScalarTest()
        {
            ushort x = (ushort)10;
            ushort y = (ushort)20;
            ushort result = Maths.Max(x, y);
            ushort expected = System.Math.Max((ushort)10, (ushort)20);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Max_UIntScalarTest()
        {
            uint x = (uint)100;
            uint y = (uint)200;
            uint result = Maths.Max(x, y);
            uint expected = System.Math.Max((uint)100, (uint)200);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Max_ULongScalarTest()
        {
            ulong x = (ulong)1000;
            ulong y = (ulong)2000;
            ulong result = Maths.Max(x, y);
            ulong expected = System.Math.Max((ulong)1000, (ulong)2000);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Max_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 y = new Float2(4.5f, -2f);
            Float2 result = Maths.Max(x, y);
            Float2 expected = new Float2(System.MathF.Max((float)1.5f, (float)4.5f), System.MathF.Max((float)-1f, (float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Max_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 y = new Float3(-2f, 7.5f, -3f);
            Float3 result = Maths.Max(x, y);
            Float3 expected = new Float3(System.MathF.Max((float)1.5f, (float)-2f), System.MathF.Max((float)-1f, (float)7.5f), System.MathF.Max((float)4.5f, (float)-3f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Max_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 y = new Float4(7.5f, -3f, 10.5f, -4f);
            Float4 result = Maths.Max(x, y);
            Float4 expected = new Float4(System.MathF.Max((float)1.5f, (float)7.5f), System.MathF.Max((float)-1f, (float)-3f), System.MathF.Max((float)4.5f, (float)10.5f), System.MathF.Max((float)-2f, (float)-4f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Max_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 y = new Double2(4.5, -2);
            Double2 result = Maths.Max(x, y);
            Double2 expected = new Double2(System.Math.Max((double)1.5, (double)4.5), System.Math.Max((double)-1, (double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Max_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 y = new Double3(-2, 7.5, -3);
            Double3 result = Maths.Max(x, y);
            Double3 expected = new Double3(System.Math.Max((double)1.5, (double)-2), System.Math.Max((double)-1, (double)7.5), System.Math.Max((double)4.5, (double)-3));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Max_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 y = new Double4(7.5, -3, 10.5, -4);
            Double4 result = Maths.Max(x, y);
            Double4 expected = new Double4(System.Math.Max((double)1.5, (double)7.5), System.Math.Max((double)-1, (double)-3), System.Math.Max((double)4.5, (double)10.5), System.Math.Max((double)-2, (double)-4));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Max_Int2Test()
        {
            Int2 x = new Int2(2, -2);
            Int2 y = new Int2(6, -4);
            Int2 result = Maths.Max(x, y);
            Int2 expected = new Int2(System.Math.Max((int)2, (int)6), System.Math.Max((int)-2, (int)-4));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Max_Int3Test()
        {
            Int3 x = new Int3(2, -2, 6);
            Int3 y = new Int3(-4, 10, -6);
            Int3 result = Maths.Max(x, y);
            Int3 expected = new Int3(System.Math.Max((int)2, (int)-4), System.Math.Max((int)-2, (int)10), System.Math.Max((int)6, (int)-6));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Max_Int4Test()
        {
            Int4 x = new Int4(2, -2, 6, -4);
            Int4 y = new Int4(10, -6, 14, -8);
            Int4 result = Maths.Max(x, y);
            Int4 expected = new Int4(System.Math.Max((int)2, (int)10), System.Math.Max((int)-2, (int)-6), System.Math.Max((int)6, (int)14), System.Math.Max((int)-4, (int)-8));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Max_Byte2Test()
        {
            Byte2 x = new Byte2((byte)1, (byte)2);
            Byte2 y = new Byte2((byte)3, (byte)4);
            Byte2 result = Maths.Max(x, y);
            Byte2 expected = new Byte2(System.Math.Max((byte)1, (byte)3), System.Math.Max((byte)2, (byte)4));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Max_Byte3Test()
        {
            Byte3 x = new Byte3((byte)1, (byte)2, (byte)3);
            Byte3 y = new Byte3((byte)4, (byte)5, (byte)6);
            Byte3 result = Maths.Max(x, y);
            Byte3 expected = new Byte3(System.Math.Max((byte)1, (byte)4), System.Math.Max((byte)2, (byte)5), System.Math.Max((byte)3, (byte)6));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Max_Byte4Test()
        {
            Byte4 x = new Byte4((byte)1, (byte)2, (byte)3, (byte)4);
            Byte4 y = new Byte4((byte)5, (byte)6, (byte)7, (byte)8);
            Byte4 result = Maths.Max(x, y);
            Byte4 expected = new Byte4(System.Math.Max((byte)1, (byte)5), System.Math.Max((byte)2, (byte)6), System.Math.Max((byte)3, (byte)7), System.Math.Max((byte)4, (byte)8));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Max_UShort2Test()
        {
            UShort2 x = new UShort2((ushort)10, (ushort)20);
            UShort2 y = new UShort2((ushort)30, (ushort)40);
            UShort2 result = Maths.Max(x, y);
            UShort2 expected = new UShort2(System.Math.Max((ushort)10, (ushort)30), System.Math.Max((ushort)20, (ushort)40));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Max_UShort3Test()
        {
            UShort3 x = new UShort3((ushort)10, (ushort)20, (ushort)30);
            UShort3 y = new UShort3((ushort)40, (ushort)50, (ushort)60);
            UShort3 result = Maths.Max(x, y);
            UShort3 expected = new UShort3(System.Math.Max((ushort)10, (ushort)40), System.Math.Max((ushort)20, (ushort)50), System.Math.Max((ushort)30, (ushort)60));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Max_UShort4Test()
        {
            UShort4 x = new UShort4((ushort)10, (ushort)20, (ushort)30, (ushort)40);
            UShort4 y = new UShort4((ushort)50, (ushort)60, (ushort)70, (ushort)80);
            UShort4 result = Maths.Max(x, y);
            UShort4 expected = new UShort4(System.Math.Max((ushort)10, (ushort)50), System.Math.Max((ushort)20, (ushort)60), System.Math.Max((ushort)30, (ushort)70), System.Math.Max((ushort)40, (ushort)80));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Max_UInt2Test()
        {
            UInt2 x = new UInt2((uint)100, (uint)200);
            UInt2 y = new UInt2((uint)300, (uint)400);
            UInt2 result = Maths.Max(x, y);
            UInt2 expected = new UInt2(System.Math.Max((uint)100, (uint)300), System.Math.Max((uint)200, (uint)400));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Max_UInt3Test()
        {
            UInt3 x = new UInt3((uint)100, (uint)200, (uint)300);
            UInt3 y = new UInt3((uint)400, (uint)500, (uint)600);
            UInt3 result = Maths.Max(x, y);
            UInt3 expected = new UInt3(System.Math.Max((uint)100, (uint)400), System.Math.Max((uint)200, (uint)500), System.Math.Max((uint)300, (uint)600));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Max_UInt4Test()
        {
            UInt4 x = new UInt4((uint)100, (uint)200, (uint)300, (uint)400);
            UInt4 y = new UInt4((uint)500, (uint)600, (uint)700, (uint)800);
            UInt4 result = Maths.Max(x, y);
            UInt4 expected = new UInt4(System.Math.Max((uint)100, (uint)500), System.Math.Max((uint)200, (uint)600), System.Math.Max((uint)300, (uint)700), System.Math.Max((uint)400, (uint)800));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Max_ULong2Test()
        {
            ULong2 x = new ULong2((ulong)1000, (ulong)2000);
            ULong2 y = new ULong2((ulong)3000, (ulong)4000);
            ULong2 result = Maths.Max(x, y);
            ULong2 expected = new ULong2(System.Math.Max((ulong)1000, (ulong)3000), System.Math.Max((ulong)2000, (ulong)4000));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Max_ULong3Test()
        {
            ULong3 x = new ULong3((ulong)1000, (ulong)2000, (ulong)3000);
            ULong3 y = new ULong3((ulong)4000, (ulong)5000, (ulong)6000);
            ULong3 result = Maths.Max(x, y);
            ULong3 expected = new ULong3(System.Math.Max((ulong)1000, (ulong)4000), System.Math.Max((ulong)2000, (ulong)5000), System.Math.Max((ulong)3000, (ulong)6000));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Max_ULong4Test()
        {
            ULong4 x = new ULong4((ulong)1000, (ulong)2000, (ulong)3000, (ulong)4000);
            ULong4 y = new ULong4((ulong)5000, (ulong)6000, (ulong)7000, (ulong)8000);
            ULong4 result = Maths.Max(x, y);
            ULong4 expected = new ULong4(System.Math.Max((ulong)1000, (ulong)5000), System.Math.Max((ulong)2000, (ulong)6000), System.Math.Max((ulong)3000, (ulong)7000), System.Math.Max((ulong)4000, (ulong)8000));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Min_FloatScalarTest()
        {
            float x = 1.5f;
            float y = -1f;
            float result = Maths.Min(x, y);
            float expected = System.MathF.Min((float)1.5f, (float)-1f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Min_DoubleScalarTest()
        {
            double x = 1.5;
            double y = -1;
            double result = Maths.Min(x, y);
            double expected = System.Math.Min((double)1.5, (double)-1);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Min_IntScalarTest()
        {
            int x = 2;
            int y = -2;
            int result = Maths.Min(x, y);
            int expected = System.Math.Min((int)2, (int)-2);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Min_ByteScalarTest()
        {
            byte x = (byte)1;
            byte y = (byte)2;
            byte result = Maths.Min(x, y);
            byte expected = System.Math.Min((byte)1, (byte)2);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Min_UShortScalarTest()
        {
            ushort x = (ushort)10;
            ushort y = (ushort)20;
            ushort result = Maths.Min(x, y);
            ushort expected = System.Math.Min((ushort)10, (ushort)20);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Min_UIntScalarTest()
        {
            uint x = (uint)100;
            uint y = (uint)200;
            uint result = Maths.Min(x, y);
            uint expected = System.Math.Min((uint)100, (uint)200);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Min_ULongScalarTest()
        {
            ulong x = (ulong)1000;
            ulong y = (ulong)2000;
            ulong result = Maths.Min(x, y);
            ulong expected = System.Math.Min((ulong)1000, (ulong)2000);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Min_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 y = new Float2(4.5f, -2f);
            Float2 result = Maths.Min(x, y);
            Float2 expected = new Float2(System.MathF.Min((float)1.5f, (float)4.5f), System.MathF.Min((float)-1f, (float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Min_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 y = new Float3(-2f, 7.5f, -3f);
            Float3 result = Maths.Min(x, y);
            Float3 expected = new Float3(System.MathF.Min((float)1.5f, (float)-2f), System.MathF.Min((float)-1f, (float)7.5f), System.MathF.Min((float)4.5f, (float)-3f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Min_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 y = new Float4(7.5f, -3f, 10.5f, -4f);
            Float4 result = Maths.Min(x, y);
            Float4 expected = new Float4(System.MathF.Min((float)1.5f, (float)7.5f), System.MathF.Min((float)-1f, (float)-3f), System.MathF.Min((float)4.5f, (float)10.5f), System.MathF.Min((float)-2f, (float)-4f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Min_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 y = new Double2(4.5, -2);
            Double2 result = Maths.Min(x, y);
            Double2 expected = new Double2(System.Math.Min((double)1.5, (double)4.5), System.Math.Min((double)-1, (double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Min_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 y = new Double3(-2, 7.5, -3);
            Double3 result = Maths.Min(x, y);
            Double3 expected = new Double3(System.Math.Min((double)1.5, (double)-2), System.Math.Min((double)-1, (double)7.5), System.Math.Min((double)4.5, (double)-3));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Min_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 y = new Double4(7.5, -3, 10.5, -4);
            Double4 result = Maths.Min(x, y);
            Double4 expected = new Double4(System.Math.Min((double)1.5, (double)7.5), System.Math.Min((double)-1, (double)-3), System.Math.Min((double)4.5, (double)10.5), System.Math.Min((double)-2, (double)-4));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Min_Int2Test()
        {
            Int2 x = new Int2(2, -2);
            Int2 y = new Int2(6, -4);
            Int2 result = Maths.Min(x, y);
            Int2 expected = new Int2(System.Math.Min((int)2, (int)6), System.Math.Min((int)-2, (int)-4));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Min_Int3Test()
        {
            Int3 x = new Int3(2, -2, 6);
            Int3 y = new Int3(-4, 10, -6);
            Int3 result = Maths.Min(x, y);
            Int3 expected = new Int3(System.Math.Min((int)2, (int)-4), System.Math.Min((int)-2, (int)10), System.Math.Min((int)6, (int)-6));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Min_Int4Test()
        {
            Int4 x = new Int4(2, -2, 6, -4);
            Int4 y = new Int4(10, -6, 14, -8);
            Int4 result = Maths.Min(x, y);
            Int4 expected = new Int4(System.Math.Min((int)2, (int)10), System.Math.Min((int)-2, (int)-6), System.Math.Min((int)6, (int)14), System.Math.Min((int)-4, (int)-8));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Min_Byte2Test()
        {
            Byte2 x = new Byte2((byte)1, (byte)2);
            Byte2 y = new Byte2((byte)3, (byte)4);
            Byte2 result = Maths.Min(x, y);
            Byte2 expected = new Byte2(System.Math.Min((byte)1, (byte)3), System.Math.Min((byte)2, (byte)4));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Min_Byte3Test()
        {
            Byte3 x = new Byte3((byte)1, (byte)2, (byte)3);
            Byte3 y = new Byte3((byte)4, (byte)5, (byte)6);
            Byte3 result = Maths.Min(x, y);
            Byte3 expected = new Byte3(System.Math.Min((byte)1, (byte)4), System.Math.Min((byte)2, (byte)5), System.Math.Min((byte)3, (byte)6));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Min_Byte4Test()
        {
            Byte4 x = new Byte4((byte)1, (byte)2, (byte)3, (byte)4);
            Byte4 y = new Byte4((byte)5, (byte)6, (byte)7, (byte)8);
            Byte4 result = Maths.Min(x, y);
            Byte4 expected = new Byte4(System.Math.Min((byte)1, (byte)5), System.Math.Min((byte)2, (byte)6), System.Math.Min((byte)3, (byte)7), System.Math.Min((byte)4, (byte)8));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Min_UShort2Test()
        {
            UShort2 x = new UShort2((ushort)10, (ushort)20);
            UShort2 y = new UShort2((ushort)30, (ushort)40);
            UShort2 result = Maths.Min(x, y);
            UShort2 expected = new UShort2(System.Math.Min((ushort)10, (ushort)30), System.Math.Min((ushort)20, (ushort)40));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Min_UShort3Test()
        {
            UShort3 x = new UShort3((ushort)10, (ushort)20, (ushort)30);
            UShort3 y = new UShort3((ushort)40, (ushort)50, (ushort)60);
            UShort3 result = Maths.Min(x, y);
            UShort3 expected = new UShort3(System.Math.Min((ushort)10, (ushort)40), System.Math.Min((ushort)20, (ushort)50), System.Math.Min((ushort)30, (ushort)60));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Min_UShort4Test()
        {
            UShort4 x = new UShort4((ushort)10, (ushort)20, (ushort)30, (ushort)40);
            UShort4 y = new UShort4((ushort)50, (ushort)60, (ushort)70, (ushort)80);
            UShort4 result = Maths.Min(x, y);
            UShort4 expected = new UShort4(System.Math.Min((ushort)10, (ushort)50), System.Math.Min((ushort)20, (ushort)60), System.Math.Min((ushort)30, (ushort)70), System.Math.Min((ushort)40, (ushort)80));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Min_UInt2Test()
        {
            UInt2 x = new UInt2((uint)100, (uint)200);
            UInt2 y = new UInt2((uint)300, (uint)400);
            UInt2 result = Maths.Min(x, y);
            UInt2 expected = new UInt2(System.Math.Min((uint)100, (uint)300), System.Math.Min((uint)200, (uint)400));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Min_UInt3Test()
        {
            UInt3 x = new UInt3((uint)100, (uint)200, (uint)300);
            UInt3 y = new UInt3((uint)400, (uint)500, (uint)600);
            UInt3 result = Maths.Min(x, y);
            UInt3 expected = new UInt3(System.Math.Min((uint)100, (uint)400), System.Math.Min((uint)200, (uint)500), System.Math.Min((uint)300, (uint)600));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Min_UInt4Test()
        {
            UInt4 x = new UInt4((uint)100, (uint)200, (uint)300, (uint)400);
            UInt4 y = new UInt4((uint)500, (uint)600, (uint)700, (uint)800);
            UInt4 result = Maths.Min(x, y);
            UInt4 expected = new UInt4(System.Math.Min((uint)100, (uint)500), System.Math.Min((uint)200, (uint)600), System.Math.Min((uint)300, (uint)700), System.Math.Min((uint)400, (uint)800));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Min_ULong2Test()
        {
            ULong2 x = new ULong2((ulong)1000, (ulong)2000);
            ULong2 y = new ULong2((ulong)3000, (ulong)4000);
            ULong2 result = Maths.Min(x, y);
            ULong2 expected = new ULong2(System.Math.Min((ulong)1000, (ulong)3000), System.Math.Min((ulong)2000, (ulong)4000));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Min_ULong3Test()
        {
            ULong3 x = new ULong3((ulong)1000, (ulong)2000, (ulong)3000);
            ULong3 y = new ULong3((ulong)4000, (ulong)5000, (ulong)6000);
            ULong3 result = Maths.Min(x, y);
            ULong3 expected = new ULong3(System.Math.Min((ulong)1000, (ulong)4000), System.Math.Min((ulong)2000, (ulong)5000), System.Math.Min((ulong)3000, (ulong)6000));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Min_ULong4Test()
        {
            ULong4 x = new ULong4((ulong)1000, (ulong)2000, (ulong)3000, (ulong)4000);
            ULong4 y = new ULong4((ulong)5000, (ulong)6000, (ulong)7000, (ulong)8000);
            ULong4 result = Maths.Min(x, y);
            ULong4 expected = new ULong4(System.Math.Min((ulong)1000, (ulong)5000), System.Math.Min((ulong)2000, (ulong)6000), System.Math.Min((ulong)3000, (ulong)7000), System.Math.Min((ulong)4000, (ulong)8000));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Mul_FloatScalarTest()
        {
            float a = 1.5f;
            float b = -1f;
            float result = Maths.Mul(a, b);
            float expected = a * b;
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Mul_Float2ComponentWiseTest()
        {
            Float2 a = new Float2(1.5f, -1f);
            Float2 b = new Float2(4.5f, -2f);
            Float2 result = Maths.Mul(a, b);
            
            float expectedX = 1.5f * 4.5f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = -1f * -2f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
        }

        [Fact]
        public void Mul_Float3ComponentWiseTest()
        {
            Float3 a = new Float3(1.5f, -1f, 4.5f);
            Float3 b = new Float3(-2f, 7.5f, -3f);
            Float3 result = Maths.Mul(a, b);
            
            float expectedX = 1.5f * -2f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = -1f * 7.5f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
            float expectedZ = 4.5f * -3f;
            Assert.Equal(expectedZ, result.Z, 0.0001f);
        }

        [Fact]
        public void Mul_Float4ComponentWiseTest()
        {
            Float4 a = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 b = new Float4(7.5f, -3f, 10.5f, -4f);
            Float4 result = Maths.Mul(a, b);
            
            float expectedX = 1.5f * 7.5f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = -1f * -3f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
            float expectedZ = 4.5f * 10.5f;
            Assert.Equal(expectedZ, result.Z, 0.0001f);
            float expectedW = -2f * -4f;
            Assert.Equal(expectedW, result.W, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix2x2Vector2_FloatTest()
        {
            Float2x2 matrix = new Float2x2(new Float2(16.5f, -6f), new Float2(19.5f, -7f));
            Float2 vector = new Float2(1.5f, -1f);
            Float2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            float expectedX = 16.5f * 1.5f + 19.5f * -1f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = -6f * 1.5f + -7f * -1f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
        }

        [Fact]
        public void Mul_Vector2Matrix2x2_FloatTest()
        {
            Float2 rowVector = new Float2(31.5f, -11f);
            Float2x2 matrix = new Float2x2(new Float2(46.5f, -16f), new Float2(49.5f, -17f));
            Float2 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            float expectedX = 31.5f * 46.5f + -11f * -16f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = 31.5f * 49.5f + -11f * -17f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix3x3Vector3_FloatTest()
        {
            Float3x3 matrix = new Float3x3(new Float3(16.5f, -6f, 19.5f), new Float3(-7f, 22.5f, -8f), new Float3(25.5f, -9f, 28.5f));
            Float3 vector = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            float expectedX = 16.5f * 1.5f + -7f * -1f + 25.5f * 4.5f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = -6f * 1.5f + 22.5f * -1f + -9f * 4.5f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
            float expectedZ = 19.5f * 1.5f + -8f * -1f + 28.5f * 4.5f;
            Assert.Equal(expectedZ, result.Z, 0.0001f);
        }

        [Fact]
        public void Mul_Vector3Matrix3x3_FloatTest()
        {
            Float3 rowVector = new Float3(31.5f, -11f, 34.5f);
            Float3x3 matrix = new Float3x3(new Float3(46.5f, -16f, 49.5f), new Float3(-17f, 52.5f, -18f), new Float3(55.5f, -19f, 58.5f));
            Float3 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            float expectedX = 31.5f * 46.5f + -11f * -16f + 34.5f * 49.5f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = 31.5f * -17f + -11f * 52.5f + 34.5f * -18f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
            float expectedZ = 31.5f * 55.5f + -11f * -19f + 34.5f * 58.5f;
            Assert.Equal(expectedZ, result.Z, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix4x4Vector4_FloatTest()
        {
            Float4x4 matrix = new Float4x4(new Float4(16.5f, -6f, 19.5f, -7f), new Float4(22.5f, -8f, 25.5f, -9f), new Float4(28.5f, -10f, 31.5f, -11f), new Float4(34.5f, -12f, 37.5f, -13f));
            Float4 vector = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            float expectedX = 16.5f * 1.5f + 22.5f * -1f + 28.5f * 4.5f + 34.5f * -2f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = -6f * 1.5f + -8f * -1f + -10f * 4.5f + -12f * -2f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
            float expectedZ = 19.5f * 1.5f + 25.5f * -1f + 31.5f * 4.5f + 37.5f * -2f;
            Assert.Equal(expectedZ, result.Z, 0.0001f);
            float expectedW = -7f * 1.5f + -9f * -1f + -11f * 4.5f + -13f * -2f;
            Assert.Equal(expectedW, result.W, 0.0001f);
        }

        [Fact]
        public void Mul_Vector4Matrix4x4_FloatTest()
        {
            Float4 rowVector = new Float4(31.5f, -11f, 34.5f, -12f);
            Float4x4 matrix = new Float4x4(new Float4(46.5f, -16f, 49.5f, -17f), new Float4(52.5f, -18f, 55.5f, -19f), new Float4(58.5f, -20f, 61.5f, -21f), new Float4(64.5f, -22f, 67.5f, -23f));
            Float4 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            float expectedX = 31.5f * 46.5f + -11f * -16f + 34.5f * 49.5f + -12f * -17f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = 31.5f * 52.5f + -11f * -18f + 34.5f * 55.5f + -12f * -19f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
            float expectedZ = 31.5f * 58.5f + -11f * -20f + 34.5f * 61.5f + -12f * -21f;
            Assert.Equal(expectedZ, result.Z, 0.0001f);
            float expectedW = 31.5f * 64.5f + -11f * -22f + 34.5f * 67.5f + -12f * -23f;
            Assert.Equal(expectedW, result.W, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix2x3Vector3_FloatTest()
        {
            Float2x3 matrix = new Float2x3(new Float2(106.5f, -36f), new Float2(109.5f, -37f), new Float2(112.5f, -38f));
            Float3 vector = new Float3(91.5f, -31f, 94.5f);
            Float2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            float expectedX = 106.5f * 91.5f + 109.5f * -31f + 112.5f * 94.5f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = -36f * 91.5f + -37f * -31f + -38f * 94.5f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix3x2Vector2_FloatTest()
        {
            Float3x2 matrix = new Float3x2(new Float3(106.5f, -36f, 109.5f), new Float3(-37f, 112.5f, -38f));
            Float2 vector = new Float2(91.5f, -31f);
            Float3 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            float expectedX = 106.5f * 91.5f + -37f * -31f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = -36f * 91.5f + 112.5f * -31f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
            float expectedZ = 109.5f * 91.5f + -38f * -31f;
            Assert.Equal(expectedZ, result.Z, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix2x4Vector4_FloatTest()
        {
            Float2x4 matrix = new Float2x4(new Float2(106.5f, -36f), new Float2(109.5f, -37f), new Float2(112.5f, -38f), new Float2(115.5f, -39f));
            Float4 vector = new Float4(91.5f, -31f, 94.5f, -32f);
            Float2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            float expectedX = 106.5f * 91.5f + 109.5f * -31f + 112.5f * 94.5f + 115.5f * -32f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = -36f * 91.5f + -37f * -31f + -38f * 94.5f + -39f * -32f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix4x2Vector2_FloatTest()
        {
            Float4x2 matrix = new Float4x2(new Float4(106.5f, -36f, 109.5f, -37f), new Float4(112.5f, -38f, 115.5f, -39f));
            Float2 vector = new Float2(91.5f, -31f);
            Float4 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            float expectedX = 106.5f * 91.5f + 112.5f * -31f;
            Assert.Equal(expectedX, result.X, 0.0001f);
            float expectedY = -36f * 91.5f + -38f * -31f;
            Assert.Equal(expectedY, result.Y, 0.0001f);
            float expectedZ = 109.5f * 91.5f + 115.5f * -31f;
            Assert.Equal(expectedZ, result.Z, 0.0001f);
            float expectedW = -37f * 91.5f + -39f * -31f;
            Assert.Equal(expectedW, result.W, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix2x2Matrix2x2_FloatTest()
        {
            Float2x2 a = new Float2x2(new Float2(61.5f, -21f), new Float2(64.5f, -22f));
            Float2x2 b = new Float2x2(new Float2(76.5f, -26f), new Float2(79.5f, -27f));
            Float2x2 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            float expectedC0X = 61.5f * 76.5f + 64.5f * -26f;
            Assert.Equal(expectedC0X, result.c0.X, 0.0001f);
            float expectedC0Y = -21f * 76.5f + -22f * -26f;
            Assert.Equal(expectedC0Y, result.c0.Y, 0.0001f);
            float expectedC1X = 61.5f * 79.5f + 64.5f * -27f;
            Assert.Equal(expectedC1X, result.c1.X, 0.0001f);
            float expectedC1Y = -21f * 79.5f + -22f * -27f;
            Assert.Equal(expectedC1Y, result.c1.Y, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix3x3Matrix3x3_FloatTest()
        {
            Float3x3 a = new Float3x3(new Float3(61.5f, -21f, 64.5f), new Float3(-22f, 67.5f, -23f), new Float3(70.5f, -24f, 73.5f));
            Float3x3 b = new Float3x3(new Float3(76.5f, -26f, 79.5f), new Float3(-27f, 82.5f, -28f), new Float3(85.5f, -29f, 88.5f));
            Float3x3 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            float expectedC0X = 61.5f * 76.5f + -22f * -26f + 70.5f * 79.5f;
            Assert.Equal(expectedC0X, result.c0.X, 0.0001f);
            float expectedC0Y = -21f * 76.5f + 67.5f * -26f + -24f * 79.5f;
            Assert.Equal(expectedC0Y, result.c0.Y, 0.0001f);
            float expectedC0Z = 64.5f * 76.5f + -23f * -26f + 73.5f * 79.5f;
            Assert.Equal(expectedC0Z, result.c0.Z, 0.0001f);
            float expectedC1X = 61.5f * -27f + -22f * 82.5f + 70.5f * -28f;
            Assert.Equal(expectedC1X, result.c1.X, 0.0001f);
            float expectedC1Y = -21f * -27f + 67.5f * 82.5f + -24f * -28f;
            Assert.Equal(expectedC1Y, result.c1.Y, 0.0001f);
            float expectedC1Z = 64.5f * -27f + -23f * 82.5f + 73.5f * -28f;
            Assert.Equal(expectedC1Z, result.c1.Z, 0.0001f);
            float expectedC2X = 61.5f * 85.5f + -22f * -29f + 70.5f * 88.5f;
            Assert.Equal(expectedC2X, result.c2.X, 0.0001f);
            float expectedC2Y = -21f * 85.5f + 67.5f * -29f + -24f * 88.5f;
            Assert.Equal(expectedC2Y, result.c2.Y, 0.0001f);
            float expectedC2Z = 64.5f * 85.5f + -23f * -29f + 73.5f * 88.5f;
            Assert.Equal(expectedC2Z, result.c2.Z, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix4x4Matrix4x4_FloatTest()
        {
            Float4x4 a = new Float4x4(new Float4(61.5f, -21f, 64.5f, -22f), new Float4(67.5f, -23f, 70.5f, -24f), new Float4(73.5f, -25f, 76.5f, -26f), new Float4(79.5f, -27f, 82.5f, -28f));
            Float4x4 b = new Float4x4(new Float4(76.5f, -26f, 79.5f, -27f), new Float4(82.5f, -28f, 85.5f, -29f), new Float4(88.5f, -30f, 91.5f, -31f), new Float4(94.5f, -32f, 97.5f, -33f));
            Float4x4 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            float expectedC0X = 61.5f * 76.5f + 67.5f * -26f + 73.5f * 79.5f + 79.5f * -27f;
            Assert.Equal(expectedC0X, result.c0.X, 0.0001f);
            float expectedC0Y = -21f * 76.5f + -23f * -26f + -25f * 79.5f + -27f * -27f;
            Assert.Equal(expectedC0Y, result.c0.Y, 0.0001f);
            float expectedC0Z = 64.5f * 76.5f + 70.5f * -26f + 76.5f * 79.5f + 82.5f * -27f;
            Assert.Equal(expectedC0Z, result.c0.Z, 0.0001f);
            float expectedC0W = -22f * 76.5f + -24f * -26f + -26f * 79.5f + -28f * -27f;
            Assert.Equal(expectedC0W, result.c0.W, 0.0001f);
            float expectedC1X = 61.5f * 82.5f + 67.5f * -28f + 73.5f * 85.5f + 79.5f * -29f;
            Assert.Equal(expectedC1X, result.c1.X, 0.0001f);
            float expectedC1Y = -21f * 82.5f + -23f * -28f + -25f * 85.5f + -27f * -29f;
            Assert.Equal(expectedC1Y, result.c1.Y, 0.0001f);
            float expectedC1Z = 64.5f * 82.5f + 70.5f * -28f + 76.5f * 85.5f + 82.5f * -29f;
            Assert.Equal(expectedC1Z, result.c1.Z, 0.0001f);
            float expectedC1W = -22f * 82.5f + -24f * -28f + -26f * 85.5f + -28f * -29f;
            Assert.Equal(expectedC1W, result.c1.W, 0.0001f);
            float expectedC2X = 61.5f * 88.5f + 67.5f * -30f + 73.5f * 91.5f + 79.5f * -31f;
            Assert.Equal(expectedC2X, result.c2.X, 0.0001f);
            float expectedC2Y = -21f * 88.5f + -23f * -30f + -25f * 91.5f + -27f * -31f;
            Assert.Equal(expectedC2Y, result.c2.Y, 0.0001f);
            float expectedC2Z = 64.5f * 88.5f + 70.5f * -30f + 76.5f * 91.5f + 82.5f * -31f;
            Assert.Equal(expectedC2Z, result.c2.Z, 0.0001f);
            float expectedC2W = -22f * 88.5f + -24f * -30f + -26f * 91.5f + -28f * -31f;
            Assert.Equal(expectedC2W, result.c2.W, 0.0001f);
            float expectedC3X = 61.5f * 94.5f + 67.5f * -32f + 73.5f * 97.5f + 79.5f * -33f;
            Assert.Equal(expectedC3X, result.c3.X, 0.0001f);
            float expectedC3Y = -21f * 94.5f + -23f * -32f + -25f * 97.5f + -27f * -33f;
            Assert.Equal(expectedC3Y, result.c3.Y, 0.0001f);
            float expectedC3Z = 64.5f * 94.5f + 70.5f * -32f + 76.5f * 97.5f + 82.5f * -33f;
            Assert.Equal(expectedC3Z, result.c3.Z, 0.0001f);
            float expectedC3W = -22f * 94.5f + -24f * -32f + -26f * 97.5f + -28f * -33f;
            Assert.Equal(expectedC3W, result.c3.W, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix2x3Matrix3x2_FloatTest()
        {
            Float2x3 a = new Float2x3(new Float2(121.5f, -41f), new Float2(124.5f, -42f), new Float2(127.5f, -43f));
            Float3x2 b = new Float3x2(new Float3(136.5f, -46f, 139.5f), new Float3(-47f, 142.5f, -48f));
            Float2x2 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            float expectedC0X = 121.5f * 136.5f + 124.5f * -46f + 127.5f * 139.5f;
            Assert.Equal(expectedC0X, result.c0.X, 0.0001f);
            float expectedC0Y = -41f * 136.5f + -42f * -46f + -43f * 139.5f;
            Assert.Equal(expectedC0Y, result.c0.Y, 0.0001f);
            float expectedC1X = 121.5f * -47f + 124.5f * 142.5f + 127.5f * -48f;
            Assert.Equal(expectedC1X, result.c1.X, 0.0001f);
            float expectedC1Y = -41f * -47f + -42f * 142.5f + -43f * -48f;
            Assert.Equal(expectedC1Y, result.c1.Y, 0.0001f);
        }

        [Fact]
        public void Mul_Matrix3x2Matrix2x4_FloatTest()
        {
            Float3x2 a = new Float3x2(new Float3(121.5f, -41f, 124.5f), new Float3(-42f, 127.5f, -43f));
            Float2x4 b = new Float2x4(new Float2(136.5f, -46f), new Float2(139.5f, -47f), new Float2(142.5f, -48f), new Float2(145.5f, -49f));
            Float3x4 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            float expectedC0X = 121.5f * 136.5f + -42f * -46f;
            Assert.Equal(expectedC0X, result.c0.X, 0.0001f);
            float expectedC0Y = -41f * 136.5f + 127.5f * -46f;
            Assert.Equal(expectedC0Y, result.c0.Y, 0.0001f);
            float expectedC0Z = 124.5f * 136.5f + -43f * -46f;
            Assert.Equal(expectedC0Z, result.c0.Z, 0.0001f);
            float expectedC1X = 121.5f * 139.5f + -42f * -47f;
            Assert.Equal(expectedC1X, result.c1.X, 0.0001f);
            float expectedC1Y = -41f * 139.5f + 127.5f * -47f;
            Assert.Equal(expectedC1Y, result.c1.Y, 0.0001f);
            float expectedC1Z = 124.5f * 139.5f + -43f * -47f;
            Assert.Equal(expectedC1Z, result.c1.Z, 0.0001f);
            float expectedC2X = 121.5f * 142.5f + -42f * -48f;
            Assert.Equal(expectedC2X, result.c2.X, 0.0001f);
            float expectedC2Y = -41f * 142.5f + 127.5f * -48f;
            Assert.Equal(expectedC2Y, result.c2.Y, 0.0001f);
            float expectedC2Z = 124.5f * 142.5f + -43f * -48f;
            Assert.Equal(expectedC2Z, result.c2.Z, 0.0001f);
            float expectedC3X = 121.5f * 145.5f + -42f * -49f;
            Assert.Equal(expectedC3X, result.c3.X, 0.0001f);
            float expectedC3Y = -41f * 145.5f + 127.5f * -49f;
            Assert.Equal(expectedC3Y, result.c3.Y, 0.0001f);
            float expectedC3Z = 124.5f * 145.5f + -43f * -49f;
            Assert.Equal(expectedC3Z, result.c3.Z, 0.0001f);
        }

        [Fact]
        public void Mul_DoubleScalarTest()
        {
            double a = 1.5;
            double b = -1;
            double result = Maths.Mul(a, b);
            double expected = a * b;
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Mul_Double2ComponentWiseTest()
        {
            Double2 a = new Double2(1.5, -1);
            Double2 b = new Double2(4.5, -2);
            Double2 result = Maths.Mul(a, b);
            
            double expectedX = 1.5 * 4.5;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = -1 * -2;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
        }

        [Fact]
        public void Mul_Double3ComponentWiseTest()
        {
            Double3 a = new Double3(1.5, -1, 4.5);
            Double3 b = new Double3(-2, 7.5, -3);
            Double3 result = Maths.Mul(a, b);
            
            double expectedX = 1.5 * -2;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = -1 * 7.5;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
            double expectedZ = 4.5 * -3;
            Assert.Equal(expectedZ, result.Z, 0.0000000001);
        }

        [Fact]
        public void Mul_Double4ComponentWiseTest()
        {
            Double4 a = new Double4(1.5, -1, 4.5, -2);
            Double4 b = new Double4(7.5, -3, 10.5, -4);
            Double4 result = Maths.Mul(a, b);
            
            double expectedX = 1.5 * 7.5;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = -1 * -3;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
            double expectedZ = 4.5 * 10.5;
            Assert.Equal(expectedZ, result.Z, 0.0000000001);
            double expectedW = -2 * -4;
            Assert.Equal(expectedW, result.W, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix2x2Vector2_DoubleTest()
        {
            Double2x2 matrix = new Double2x2(new Double2(16.5, -6), new Double2(19.5, -7));
            Double2 vector = new Double2(1.5, -1);
            Double2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            double expectedX = 16.5 * 1.5 + 19.5 * -1;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = -6 * 1.5 + -7 * -1;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
        }

        [Fact]
        public void Mul_Vector2Matrix2x2_DoubleTest()
        {
            Double2 rowVector = new Double2(31.5, -11);
            Double2x2 matrix = new Double2x2(new Double2(46.5, -16), new Double2(49.5, -17));
            Double2 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            double expectedX = 31.5 * 46.5 + -11 * -16;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = 31.5 * 49.5 + -11 * -17;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix3x3Vector3_DoubleTest()
        {
            Double3x3 matrix = new Double3x3(new Double3(16.5, -6, 19.5), new Double3(-7, 22.5, -8), new Double3(25.5, -9, 28.5));
            Double3 vector = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            double expectedX = 16.5 * 1.5 + -7 * -1 + 25.5 * 4.5;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = -6 * 1.5 + 22.5 * -1 + -9 * 4.5;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
            double expectedZ = 19.5 * 1.5 + -8 * -1 + 28.5 * 4.5;
            Assert.Equal(expectedZ, result.Z, 0.0000000001);
        }

        [Fact]
        public void Mul_Vector3Matrix3x3_DoubleTest()
        {
            Double3 rowVector = new Double3(31.5, -11, 34.5);
            Double3x3 matrix = new Double3x3(new Double3(46.5, -16, 49.5), new Double3(-17, 52.5, -18), new Double3(55.5, -19, 58.5));
            Double3 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            double expectedX = 31.5 * 46.5 + -11 * -16 + 34.5 * 49.5;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = 31.5 * -17 + -11 * 52.5 + 34.5 * -18;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
            double expectedZ = 31.5 * 55.5 + -11 * -19 + 34.5 * 58.5;
            Assert.Equal(expectedZ, result.Z, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix4x4Vector4_DoubleTest()
        {
            Double4x4 matrix = new Double4x4(new Double4(16.5, -6, 19.5, -7), new Double4(22.5, -8, 25.5, -9), new Double4(28.5, -10, 31.5, -11), new Double4(34.5, -12, 37.5, -13));
            Double4 vector = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            double expectedX = 16.5 * 1.5 + 22.5 * -1 + 28.5 * 4.5 + 34.5 * -2;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = -6 * 1.5 + -8 * -1 + -10 * 4.5 + -12 * -2;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
            double expectedZ = 19.5 * 1.5 + 25.5 * -1 + 31.5 * 4.5 + 37.5 * -2;
            Assert.Equal(expectedZ, result.Z, 0.0000000001);
            double expectedW = -7 * 1.5 + -9 * -1 + -11 * 4.5 + -13 * -2;
            Assert.Equal(expectedW, result.W, 0.0000000001);
        }

        [Fact]
        public void Mul_Vector4Matrix4x4_DoubleTest()
        {
            Double4 rowVector = new Double4(31.5, -11, 34.5, -12);
            Double4x4 matrix = new Double4x4(new Double4(46.5, -16, 49.5, -17), new Double4(52.5, -18, 55.5, -19), new Double4(58.5, -20, 61.5, -21), new Double4(64.5, -22, 67.5, -23));
            Double4 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            double expectedX = 31.5 * 46.5 + -11 * -16 + 34.5 * 49.5 + -12 * -17;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = 31.5 * 52.5 + -11 * -18 + 34.5 * 55.5 + -12 * -19;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
            double expectedZ = 31.5 * 58.5 + -11 * -20 + 34.5 * 61.5 + -12 * -21;
            Assert.Equal(expectedZ, result.Z, 0.0000000001);
            double expectedW = 31.5 * 64.5 + -11 * -22 + 34.5 * 67.5 + -12 * -23;
            Assert.Equal(expectedW, result.W, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix2x3Vector3_DoubleTest()
        {
            Double2x3 matrix = new Double2x3(new Double2(106.5, -36), new Double2(109.5, -37), new Double2(112.5, -38));
            Double3 vector = new Double3(91.5, -31, 94.5);
            Double2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            double expectedX = 106.5 * 91.5 + 109.5 * -31 + 112.5 * 94.5;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = -36 * 91.5 + -37 * -31 + -38 * 94.5;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix3x2Vector2_DoubleTest()
        {
            Double3x2 matrix = new Double3x2(new Double3(106.5, -36, 109.5), new Double3(-37, 112.5, -38));
            Double2 vector = new Double2(91.5, -31);
            Double3 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            double expectedX = 106.5 * 91.5 + -37 * -31;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = -36 * 91.5 + 112.5 * -31;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
            double expectedZ = 109.5 * 91.5 + -38 * -31;
            Assert.Equal(expectedZ, result.Z, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix2x4Vector4_DoubleTest()
        {
            Double2x4 matrix = new Double2x4(new Double2(106.5, -36), new Double2(109.5, -37), new Double2(112.5, -38), new Double2(115.5, -39));
            Double4 vector = new Double4(91.5, -31, 94.5, -32);
            Double2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            double expectedX = 106.5 * 91.5 + 109.5 * -31 + 112.5 * 94.5 + 115.5 * -32;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = -36 * 91.5 + -37 * -31 + -38 * 94.5 + -39 * -32;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix4x2Vector2_DoubleTest()
        {
            Double4x2 matrix = new Double4x2(new Double4(106.5, -36, 109.5, -37), new Double4(112.5, -38, 115.5, -39));
            Double2 vector = new Double2(91.5, -31);
            Double4 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            double expectedX = 106.5 * 91.5 + 112.5 * -31;
            Assert.Equal(expectedX, result.X, 0.0000000001);
            double expectedY = -36 * 91.5 + -38 * -31;
            Assert.Equal(expectedY, result.Y, 0.0000000001);
            double expectedZ = 109.5 * 91.5 + 115.5 * -31;
            Assert.Equal(expectedZ, result.Z, 0.0000000001);
            double expectedW = -37 * 91.5 + -39 * -31;
            Assert.Equal(expectedW, result.W, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix2x2Matrix2x2_DoubleTest()
        {
            Double2x2 a = new Double2x2(new Double2(61.5, -21), new Double2(64.5, -22));
            Double2x2 b = new Double2x2(new Double2(76.5, -26), new Double2(79.5, -27));
            Double2x2 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            double expectedC0X = 61.5 * 76.5 + 64.5 * -26;
            Assert.Equal(expectedC0X, result.c0.X, 0.0000000001);
            double expectedC0Y = -21 * 76.5 + -22 * -26;
            Assert.Equal(expectedC0Y, result.c0.Y, 0.0000000001);
            double expectedC1X = 61.5 * 79.5 + 64.5 * -27;
            Assert.Equal(expectedC1X, result.c1.X, 0.0000000001);
            double expectedC1Y = -21 * 79.5 + -22 * -27;
            Assert.Equal(expectedC1Y, result.c1.Y, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix3x3Matrix3x3_DoubleTest()
        {
            Double3x3 a = new Double3x3(new Double3(61.5, -21, 64.5), new Double3(-22, 67.5, -23), new Double3(70.5, -24, 73.5));
            Double3x3 b = new Double3x3(new Double3(76.5, -26, 79.5), new Double3(-27, 82.5, -28), new Double3(85.5, -29, 88.5));
            Double3x3 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            double expectedC0X = 61.5 * 76.5 + -22 * -26 + 70.5 * 79.5;
            Assert.Equal(expectedC0X, result.c0.X, 0.0000000001);
            double expectedC0Y = -21 * 76.5 + 67.5 * -26 + -24 * 79.5;
            Assert.Equal(expectedC0Y, result.c0.Y, 0.0000000001);
            double expectedC0Z = 64.5 * 76.5 + -23 * -26 + 73.5 * 79.5;
            Assert.Equal(expectedC0Z, result.c0.Z, 0.0000000001);
            double expectedC1X = 61.5 * -27 + -22 * 82.5 + 70.5 * -28;
            Assert.Equal(expectedC1X, result.c1.X, 0.0000000001);
            double expectedC1Y = -21 * -27 + 67.5 * 82.5 + -24 * -28;
            Assert.Equal(expectedC1Y, result.c1.Y, 0.0000000001);
            double expectedC1Z = 64.5 * -27 + -23 * 82.5 + 73.5 * -28;
            Assert.Equal(expectedC1Z, result.c1.Z, 0.0000000001);
            double expectedC2X = 61.5 * 85.5 + -22 * -29 + 70.5 * 88.5;
            Assert.Equal(expectedC2X, result.c2.X, 0.0000000001);
            double expectedC2Y = -21 * 85.5 + 67.5 * -29 + -24 * 88.5;
            Assert.Equal(expectedC2Y, result.c2.Y, 0.0000000001);
            double expectedC2Z = 64.5 * 85.5 + -23 * -29 + 73.5 * 88.5;
            Assert.Equal(expectedC2Z, result.c2.Z, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix4x4Matrix4x4_DoubleTest()
        {
            Double4x4 a = new Double4x4(new Double4(61.5, -21, 64.5, -22), new Double4(67.5, -23, 70.5, -24), new Double4(73.5, -25, 76.5, -26), new Double4(79.5, -27, 82.5, -28));
            Double4x4 b = new Double4x4(new Double4(76.5, -26, 79.5, -27), new Double4(82.5, -28, 85.5, -29), new Double4(88.5, -30, 91.5, -31), new Double4(94.5, -32, 97.5, -33));
            Double4x4 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            double expectedC0X = 61.5 * 76.5 + 67.5 * -26 + 73.5 * 79.5 + 79.5 * -27;
            Assert.Equal(expectedC0X, result.c0.X, 0.0000000001);
            double expectedC0Y = -21 * 76.5 + -23 * -26 + -25 * 79.5 + -27 * -27;
            Assert.Equal(expectedC0Y, result.c0.Y, 0.0000000001);
            double expectedC0Z = 64.5 * 76.5 + 70.5 * -26 + 76.5 * 79.5 + 82.5 * -27;
            Assert.Equal(expectedC0Z, result.c0.Z, 0.0000000001);
            double expectedC0W = -22 * 76.5 + -24 * -26 + -26 * 79.5 + -28 * -27;
            Assert.Equal(expectedC0W, result.c0.W, 0.0000000001);
            double expectedC1X = 61.5 * 82.5 + 67.5 * -28 + 73.5 * 85.5 + 79.5 * -29;
            Assert.Equal(expectedC1X, result.c1.X, 0.0000000001);
            double expectedC1Y = -21 * 82.5 + -23 * -28 + -25 * 85.5 + -27 * -29;
            Assert.Equal(expectedC1Y, result.c1.Y, 0.0000000001);
            double expectedC1Z = 64.5 * 82.5 + 70.5 * -28 + 76.5 * 85.5 + 82.5 * -29;
            Assert.Equal(expectedC1Z, result.c1.Z, 0.0000000001);
            double expectedC1W = -22 * 82.5 + -24 * -28 + -26 * 85.5 + -28 * -29;
            Assert.Equal(expectedC1W, result.c1.W, 0.0000000001);
            double expectedC2X = 61.5 * 88.5 + 67.5 * -30 + 73.5 * 91.5 + 79.5 * -31;
            Assert.Equal(expectedC2X, result.c2.X, 0.0000000001);
            double expectedC2Y = -21 * 88.5 + -23 * -30 + -25 * 91.5 + -27 * -31;
            Assert.Equal(expectedC2Y, result.c2.Y, 0.0000000001);
            double expectedC2Z = 64.5 * 88.5 + 70.5 * -30 + 76.5 * 91.5 + 82.5 * -31;
            Assert.Equal(expectedC2Z, result.c2.Z, 0.0000000001);
            double expectedC2W = -22 * 88.5 + -24 * -30 + -26 * 91.5 + -28 * -31;
            Assert.Equal(expectedC2W, result.c2.W, 0.0000000001);
            double expectedC3X = 61.5 * 94.5 + 67.5 * -32 + 73.5 * 97.5 + 79.5 * -33;
            Assert.Equal(expectedC3X, result.c3.X, 0.0000000001);
            double expectedC3Y = -21 * 94.5 + -23 * -32 + -25 * 97.5 + -27 * -33;
            Assert.Equal(expectedC3Y, result.c3.Y, 0.0000000001);
            double expectedC3Z = 64.5 * 94.5 + 70.5 * -32 + 76.5 * 97.5 + 82.5 * -33;
            Assert.Equal(expectedC3Z, result.c3.Z, 0.0000000001);
            double expectedC3W = -22 * 94.5 + -24 * -32 + -26 * 97.5 + -28 * -33;
            Assert.Equal(expectedC3W, result.c3.W, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix2x3Matrix3x2_DoubleTest()
        {
            Double2x3 a = new Double2x3(new Double2(121.5, -41), new Double2(124.5, -42), new Double2(127.5, -43));
            Double3x2 b = new Double3x2(new Double3(136.5, -46, 139.5), new Double3(-47, 142.5, -48));
            Double2x2 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            double expectedC0X = 121.5 * 136.5 + 124.5 * -46 + 127.5 * 139.5;
            Assert.Equal(expectedC0X, result.c0.X, 0.0000000001);
            double expectedC0Y = -41 * 136.5 + -42 * -46 + -43 * 139.5;
            Assert.Equal(expectedC0Y, result.c0.Y, 0.0000000001);
            double expectedC1X = 121.5 * -47 + 124.5 * 142.5 + 127.5 * -48;
            Assert.Equal(expectedC1X, result.c1.X, 0.0000000001);
            double expectedC1Y = -41 * -47 + -42 * 142.5 + -43 * -48;
            Assert.Equal(expectedC1Y, result.c1.Y, 0.0000000001);
        }

        [Fact]
        public void Mul_Matrix3x2Matrix2x4_DoubleTest()
        {
            Double3x2 a = new Double3x2(new Double3(121.5, -41, 124.5), new Double3(-42, 127.5, -43));
            Double2x4 b = new Double2x4(new Double2(136.5, -46), new Double2(139.5, -47), new Double2(142.5, -48), new Double2(145.5, -49));
            Double3x4 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            double expectedC0X = 121.5 * 136.5 + -42 * -46;
            Assert.Equal(expectedC0X, result.c0.X, 0.0000000001);
            double expectedC0Y = -41 * 136.5 + 127.5 * -46;
            Assert.Equal(expectedC0Y, result.c0.Y, 0.0000000001);
            double expectedC0Z = 124.5 * 136.5 + -43 * -46;
            Assert.Equal(expectedC0Z, result.c0.Z, 0.0000000001);
            double expectedC1X = 121.5 * 139.5 + -42 * -47;
            Assert.Equal(expectedC1X, result.c1.X, 0.0000000001);
            double expectedC1Y = -41 * 139.5 + 127.5 * -47;
            Assert.Equal(expectedC1Y, result.c1.Y, 0.0000000001);
            double expectedC1Z = 124.5 * 139.5 + -43 * -47;
            Assert.Equal(expectedC1Z, result.c1.Z, 0.0000000001);
            double expectedC2X = 121.5 * 142.5 + -42 * -48;
            Assert.Equal(expectedC2X, result.c2.X, 0.0000000001);
            double expectedC2Y = -41 * 142.5 + 127.5 * -48;
            Assert.Equal(expectedC2Y, result.c2.Y, 0.0000000001);
            double expectedC2Z = 124.5 * 142.5 + -43 * -48;
            Assert.Equal(expectedC2Z, result.c2.Z, 0.0000000001);
            double expectedC3X = 121.5 * 145.5 + -42 * -49;
            Assert.Equal(expectedC3X, result.c3.X, 0.0000000001);
            double expectedC3Y = -41 * 145.5 + 127.5 * -49;
            Assert.Equal(expectedC3Y, result.c3.Y, 0.0000000001);
            double expectedC3Z = 124.5 * 145.5 + -43 * -49;
            Assert.Equal(expectedC3Z, result.c3.Z, 0.0000000001);
        }

        [Fact]
        public void Mul_IntScalarTest()
        {
            int a = 2;
            int b = -2;
            int result = Maths.Mul(a, b);
            int expected = a * b;
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Mul_Int2ComponentWiseTest()
        {
            Int2 a = new Int2(2, -2);
            Int2 b = new Int2(6, -4);
            Int2 result = Maths.Mul(a, b);
            
            int expectedX = 2 * 6;
            Assert.Equal(expectedX, result.X);
            int expectedY = -2 * -4;
            Assert.Equal(expectedY, result.Y);
        }

        [Fact]
        public void Mul_Int3ComponentWiseTest()
        {
            Int3 a = new Int3(2, -2, 6);
            Int3 b = new Int3(-4, 10, -6);
            Int3 result = Maths.Mul(a, b);
            
            int expectedX = 2 * -4;
            Assert.Equal(expectedX, result.X);
            int expectedY = -2 * 10;
            Assert.Equal(expectedY, result.Y);
            int expectedZ = 6 * -6;
            Assert.Equal(expectedZ, result.Z);
        }

        [Fact]
        public void Mul_Int4ComponentWiseTest()
        {
            Int4 a = new Int4(2, -2, 6, -4);
            Int4 b = new Int4(10, -6, 14, -8);
            Int4 result = Maths.Mul(a, b);
            
            int expectedX = 2 * 10;
            Assert.Equal(expectedX, result.X);
            int expectedY = -2 * -6;
            Assert.Equal(expectedY, result.Y);
            int expectedZ = 6 * 14;
            Assert.Equal(expectedZ, result.Z);
            int expectedW = -4 * -8;
            Assert.Equal(expectedW, result.W);
        }

        [Fact]
        public void Mul_Matrix2x2Vector2_IntTest()
        {
            Int2x2 matrix = new Int2x2(new Int2(22, -12), new Int2(26, -14));
            Int2 vector = new Int2(2, -2);
            Int2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            int expectedX = 22 * 2 + 26 * -2;
            Assert.Equal(expectedX, result.X);
            int expectedY = -12 * 2 + -14 * -2;
            Assert.Equal(expectedY, result.Y);
        }

        [Fact]
        public void Mul_Vector2Matrix2x2_IntTest()
        {
            Int2 rowVector = new Int2(42, -22);
            Int2x2 matrix = new Int2x2(new Int2(62, -32), new Int2(66, -34));
            Int2 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            int expectedX = 42 * 62 + -22 * -32;
            Assert.Equal(expectedX, result.X);
            int expectedY = 42 * 66 + -22 * -34;
            Assert.Equal(expectedY, result.Y);
        }

        [Fact]
        public void Mul_Matrix3x3Vector3_IntTest()
        {
            Int3x3 matrix = new Int3x3(new Int3(22, -12, 26), new Int3(-14, 30, -16), new Int3(34, -18, 38));
            Int3 vector = new Int3(2, -2, 6);
            Int3 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            int expectedX = 22 * 2 + -14 * -2 + 34 * 6;
            Assert.Equal(expectedX, result.X);
            int expectedY = -12 * 2 + 30 * -2 + -18 * 6;
            Assert.Equal(expectedY, result.Y);
            int expectedZ = 26 * 2 + -16 * -2 + 38 * 6;
            Assert.Equal(expectedZ, result.Z);
        }

        [Fact]
        public void Mul_Vector3Matrix3x3_IntTest()
        {
            Int3 rowVector = new Int3(42, -22, 46);
            Int3x3 matrix = new Int3x3(new Int3(62, -32, 66), new Int3(-34, 70, -36), new Int3(74, -38, 78));
            Int3 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            int expectedX = 42 * 62 + -22 * -32 + 46 * 66;
            Assert.Equal(expectedX, result.X);
            int expectedY = 42 * -34 + -22 * 70 + 46 * -36;
            Assert.Equal(expectedY, result.Y);
            int expectedZ = 42 * 74 + -22 * -38 + 46 * 78;
            Assert.Equal(expectedZ, result.Z);
        }

        [Fact]
        public void Mul_Matrix4x4Vector4_IntTest()
        {
            Int4x4 matrix = new Int4x4(new Int4(22, -12, 26, -14), new Int4(30, -16, 34, -18), new Int4(38, -20, 42, -22), new Int4(46, -24, 50, -26));
            Int4 vector = new Int4(2, -2, 6, -4);
            Int4 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            int expectedX = 22 * 2 + 30 * -2 + 38 * 6 + 46 * -4;
            Assert.Equal(expectedX, result.X);
            int expectedY = -12 * 2 + -16 * -2 + -20 * 6 + -24 * -4;
            Assert.Equal(expectedY, result.Y);
            int expectedZ = 26 * 2 + 34 * -2 + 42 * 6 + 50 * -4;
            Assert.Equal(expectedZ, result.Z);
            int expectedW = -14 * 2 + -18 * -2 + -22 * 6 + -26 * -4;
            Assert.Equal(expectedW, result.W);
        }

        [Fact]
        public void Mul_Vector4Matrix4x4_IntTest()
        {
            Int4 rowVector = new Int4(42, -22, 46, -24);
            Int4x4 matrix = new Int4x4(new Int4(62, -32, 66, -34), new Int4(70, -36, 74, -38), new Int4(78, -40, 82, -42), new Int4(86, -44, 90, -46));
            Int4 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            int expectedX = 42 * 62 + -22 * -32 + 46 * 66 + -24 * -34;
            Assert.Equal(expectedX, result.X);
            int expectedY = 42 * 70 + -22 * -36 + 46 * 74 + -24 * -38;
            Assert.Equal(expectedY, result.Y);
            int expectedZ = 42 * 78 + -22 * -40 + 46 * 82 + -24 * -42;
            Assert.Equal(expectedZ, result.Z);
            int expectedW = 42 * 86 + -22 * -44 + 46 * 90 + -24 * -46;
            Assert.Equal(expectedW, result.W);
        }

        [Fact]
        public void Mul_Matrix2x3Vector3_IntTest()
        {
            Int2x3 matrix = new Int2x3(new Int2(142, -72), new Int2(146, -74), new Int2(150, -76));
            Int3 vector = new Int3(122, -62, 126);
            Int2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            int expectedX = 142 * 122 + 146 * -62 + 150 * 126;
            Assert.Equal(expectedX, result.X);
            int expectedY = -72 * 122 + -74 * -62 + -76 * 126;
            Assert.Equal(expectedY, result.Y);
        }

        [Fact]
        public void Mul_Matrix3x2Vector2_IntTest()
        {
            Int3x2 matrix = new Int3x2(new Int3(142, -72, 146), new Int3(-74, 150, -76));
            Int2 vector = new Int2(122, -62);
            Int3 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            int expectedX = 142 * 122 + -74 * -62;
            Assert.Equal(expectedX, result.X);
            int expectedY = -72 * 122 + 150 * -62;
            Assert.Equal(expectedY, result.Y);
            int expectedZ = 146 * 122 + -76 * -62;
            Assert.Equal(expectedZ, result.Z);
        }

        [Fact]
        public void Mul_Matrix2x4Vector4_IntTest()
        {
            Int2x4 matrix = new Int2x4(new Int2(142, -72), new Int2(146, -74), new Int2(150, -76), new Int2(154, -78));
            Int4 vector = new Int4(122, -62, 126, -64);
            Int2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            int expectedX = 142 * 122 + 146 * -62 + 150 * 126 + 154 * -64;
            Assert.Equal(expectedX, result.X);
            int expectedY = -72 * 122 + -74 * -62 + -76 * 126 + -78 * -64;
            Assert.Equal(expectedY, result.Y);
        }

        [Fact]
        public void Mul_Matrix4x2Vector2_IntTest()
        {
            Int4x2 matrix = new Int4x2(new Int4(142, -72, 146, -74), new Int4(150, -76, 154, -78));
            Int2 vector = new Int2(122, -62);
            Int4 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            int expectedX = 142 * 122 + 150 * -62;
            Assert.Equal(expectedX, result.X);
            int expectedY = -72 * 122 + -76 * -62;
            Assert.Equal(expectedY, result.Y);
            int expectedZ = 146 * 122 + 154 * -62;
            Assert.Equal(expectedZ, result.Z);
            int expectedW = -74 * 122 + -78 * -62;
            Assert.Equal(expectedW, result.W);
        }

        [Fact]
        public void Mul_Matrix2x2Matrix2x2_IntTest()
        {
            Int2x2 a = new Int2x2(new Int2(82, -42), new Int2(86, -44));
            Int2x2 b = new Int2x2(new Int2(102, -52), new Int2(106, -54));
            Int2x2 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            int expectedC0X = 82 * 102 + 86 * -52;
            Assert.Equal(expectedC0X, result.c0.X);
            int expectedC0Y = -42 * 102 + -44 * -52;
            Assert.Equal(expectedC0Y, result.c0.Y);
            int expectedC1X = 82 * 106 + 86 * -54;
            Assert.Equal(expectedC1X, result.c1.X);
            int expectedC1Y = -42 * 106 + -44 * -54;
            Assert.Equal(expectedC1Y, result.c1.Y);
        }

        [Fact]
        public void Mul_Matrix3x3Matrix3x3_IntTest()
        {
            Int3x3 a = new Int3x3(new Int3(82, -42, 86), new Int3(-44, 90, -46), new Int3(94, -48, 98));
            Int3x3 b = new Int3x3(new Int3(102, -52, 106), new Int3(-54, 110, -56), new Int3(114, -58, 118));
            Int3x3 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            int expectedC0X = 82 * 102 + -44 * -52 + 94 * 106;
            Assert.Equal(expectedC0X, result.c0.X);
            int expectedC0Y = -42 * 102 + 90 * -52 + -48 * 106;
            Assert.Equal(expectedC0Y, result.c0.Y);
            int expectedC0Z = 86 * 102 + -46 * -52 + 98 * 106;
            Assert.Equal(expectedC0Z, result.c0.Z);
            int expectedC1X = 82 * -54 + -44 * 110 + 94 * -56;
            Assert.Equal(expectedC1X, result.c1.X);
            int expectedC1Y = -42 * -54 + 90 * 110 + -48 * -56;
            Assert.Equal(expectedC1Y, result.c1.Y);
            int expectedC1Z = 86 * -54 + -46 * 110 + 98 * -56;
            Assert.Equal(expectedC1Z, result.c1.Z);
            int expectedC2X = 82 * 114 + -44 * -58 + 94 * 118;
            Assert.Equal(expectedC2X, result.c2.X);
            int expectedC2Y = -42 * 114 + 90 * -58 + -48 * 118;
            Assert.Equal(expectedC2Y, result.c2.Y);
            int expectedC2Z = 86 * 114 + -46 * -58 + 98 * 118;
            Assert.Equal(expectedC2Z, result.c2.Z);
        }

        [Fact]
        public void Mul_Matrix4x4Matrix4x4_IntTest()
        {
            Int4x4 a = new Int4x4(new Int4(82, -42, 86, -44), new Int4(90, -46, 94, -48), new Int4(98, -50, 102, -52), new Int4(106, -54, 110, -56));
            Int4x4 b = new Int4x4(new Int4(102, -52, 106, -54), new Int4(110, -56, 114, -58), new Int4(118, -60, 122, -62), new Int4(126, -64, 130, -66));
            Int4x4 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            int expectedC0X = 82 * 102 + 90 * -52 + 98 * 106 + 106 * -54;
            Assert.Equal(expectedC0X, result.c0.X);
            int expectedC0Y = -42 * 102 + -46 * -52 + -50 * 106 + -54 * -54;
            Assert.Equal(expectedC0Y, result.c0.Y);
            int expectedC0Z = 86 * 102 + 94 * -52 + 102 * 106 + 110 * -54;
            Assert.Equal(expectedC0Z, result.c0.Z);
            int expectedC0W = -44 * 102 + -48 * -52 + -52 * 106 + -56 * -54;
            Assert.Equal(expectedC0W, result.c0.W);
            int expectedC1X = 82 * 110 + 90 * -56 + 98 * 114 + 106 * -58;
            Assert.Equal(expectedC1X, result.c1.X);
            int expectedC1Y = -42 * 110 + -46 * -56 + -50 * 114 + -54 * -58;
            Assert.Equal(expectedC1Y, result.c1.Y);
            int expectedC1Z = 86 * 110 + 94 * -56 + 102 * 114 + 110 * -58;
            Assert.Equal(expectedC1Z, result.c1.Z);
            int expectedC1W = -44 * 110 + -48 * -56 + -52 * 114 + -56 * -58;
            Assert.Equal(expectedC1W, result.c1.W);
            int expectedC2X = 82 * 118 + 90 * -60 + 98 * 122 + 106 * -62;
            Assert.Equal(expectedC2X, result.c2.X);
            int expectedC2Y = -42 * 118 + -46 * -60 + -50 * 122 + -54 * -62;
            Assert.Equal(expectedC2Y, result.c2.Y);
            int expectedC2Z = 86 * 118 + 94 * -60 + 102 * 122 + 110 * -62;
            Assert.Equal(expectedC2Z, result.c2.Z);
            int expectedC2W = -44 * 118 + -48 * -60 + -52 * 122 + -56 * -62;
            Assert.Equal(expectedC2W, result.c2.W);
            int expectedC3X = 82 * 126 + 90 * -64 + 98 * 130 + 106 * -66;
            Assert.Equal(expectedC3X, result.c3.X);
            int expectedC3Y = -42 * 126 + -46 * -64 + -50 * 130 + -54 * -66;
            Assert.Equal(expectedC3Y, result.c3.Y);
            int expectedC3Z = 86 * 126 + 94 * -64 + 102 * 130 + 110 * -66;
            Assert.Equal(expectedC3Z, result.c3.Z);
            int expectedC3W = -44 * 126 + -48 * -64 + -52 * 130 + -56 * -66;
            Assert.Equal(expectedC3W, result.c3.W);
        }

        [Fact]
        public void Mul_Matrix2x3Matrix3x2_IntTest()
        {
            Int2x3 a = new Int2x3(new Int2(162, -82), new Int2(166, -84), new Int2(170, -86));
            Int3x2 b = new Int3x2(new Int3(182, -92, 186), new Int3(-94, 190, -96));
            Int2x2 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            int expectedC0X = 162 * 182 + 166 * -92 + 170 * 186;
            Assert.Equal(expectedC0X, result.c0.X);
            int expectedC0Y = -82 * 182 + -84 * -92 + -86 * 186;
            Assert.Equal(expectedC0Y, result.c0.Y);
            int expectedC1X = 162 * -94 + 166 * 190 + 170 * -96;
            Assert.Equal(expectedC1X, result.c1.X);
            int expectedC1Y = -82 * -94 + -84 * 190 + -86 * -96;
            Assert.Equal(expectedC1Y, result.c1.Y);
        }

        [Fact]
        public void Mul_Matrix3x2Matrix2x4_IntTest()
        {
            Int3x2 a = new Int3x2(new Int3(162, -82, 166), new Int3(-84, 170, -86));
            Int2x4 b = new Int2x4(new Int2(182, -92), new Int2(186, -94), new Int2(190, -96), new Int2(194, -98));
            Int3x4 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            int expectedC0X = 162 * 182 + -84 * -92;
            Assert.Equal(expectedC0X, result.c0.X);
            int expectedC0Y = -82 * 182 + 170 * -92;
            Assert.Equal(expectedC0Y, result.c0.Y);
            int expectedC0Z = 166 * 182 + -86 * -92;
            Assert.Equal(expectedC0Z, result.c0.Z);
            int expectedC1X = 162 * 186 + -84 * -94;
            Assert.Equal(expectedC1X, result.c1.X);
            int expectedC1Y = -82 * 186 + 170 * -94;
            Assert.Equal(expectedC1Y, result.c1.Y);
            int expectedC1Z = 166 * 186 + -86 * -94;
            Assert.Equal(expectedC1Z, result.c1.Z);
            int expectedC2X = 162 * 190 + -84 * -96;
            Assert.Equal(expectedC2X, result.c2.X);
            int expectedC2Y = -82 * 190 + 170 * -96;
            Assert.Equal(expectedC2Y, result.c2.Y);
            int expectedC2Z = 166 * 190 + -86 * -96;
            Assert.Equal(expectedC2Z, result.c2.Z);
            int expectedC3X = 162 * 194 + -84 * -98;
            Assert.Equal(expectedC3X, result.c3.X);
            int expectedC3Y = -82 * 194 + 170 * -98;
            Assert.Equal(expectedC3Y, result.c3.Y);
            int expectedC3Z = 166 * 194 + -86 * -98;
            Assert.Equal(expectedC3Z, result.c3.Z);
        }

        [Fact]
        public void Mul_UIntScalarTest()
        {
            uint a = (uint)100;
            uint b = (uint)200;
            uint result = Maths.Mul(a, b);
            uint expected = a * b;
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Mul_UInt2ComponentWiseTest()
        {
            UInt2 a = new UInt2((uint)100, (uint)200);
            UInt2 b = new UInt2((uint)300, (uint)400);
            UInt2 result = Maths.Mul(a, b);
            
            uint expectedX = (uint)100 * (uint)300;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)200 * (uint)400;
            Assert.Equal(expectedY, result.Y);
        }

        [Fact]
        public void Mul_UInt3ComponentWiseTest()
        {
            UInt3 a = new UInt3((uint)100, (uint)200, (uint)300);
            UInt3 b = new UInt3((uint)400, (uint)500, (uint)600);
            UInt3 result = Maths.Mul(a, b);
            
            uint expectedX = (uint)100 * (uint)400;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)200 * (uint)500;
            Assert.Equal(expectedY, result.Y);
            uint expectedZ = (uint)300 * (uint)600;
            Assert.Equal(expectedZ, result.Z);
        }

        [Fact]
        public void Mul_UInt4ComponentWiseTest()
        {
            UInt4 a = new UInt4((uint)100, (uint)200, (uint)300, (uint)400);
            UInt4 b = new UInt4((uint)500, (uint)600, (uint)700, (uint)800);
            UInt4 result = Maths.Mul(a, b);
            
            uint expectedX = (uint)100 * (uint)500;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)200 * (uint)600;
            Assert.Equal(expectedY, result.Y);
            uint expectedZ = (uint)300 * (uint)700;
            Assert.Equal(expectedZ, result.Z);
            uint expectedW = (uint)400 * (uint)800;
            Assert.Equal(expectedW, result.W);
        }

        [Fact]
        public void Mul_Matrix2x2Vector2_UIntTest()
        {
            UInt2x2 matrix = new UInt2x2(new UInt2((uint)1100, (uint)1200), new UInt2((uint)1300, (uint)1400));
            UInt2 vector = new UInt2((uint)100, (uint)200);
            UInt2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            uint expectedX = (uint)1100 * (uint)100 + (uint)1300 * (uint)200;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)1200 * (uint)100 + (uint)1400 * (uint)200;
            Assert.Equal(expectedY, result.Y);
        }

        [Fact]
        public void Mul_Vector2Matrix2x2_UIntTest()
        {
            UInt2 rowVector = new UInt2((uint)2100, (uint)2200);
            UInt2x2 matrix = new UInt2x2(new UInt2((uint)3100, (uint)3200), new UInt2((uint)3300, (uint)3400));
            UInt2 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            uint expectedX = (uint)2100 * (uint)3100 + (uint)2200 * (uint)3200;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)2100 * (uint)3300 + (uint)2200 * (uint)3400;
            Assert.Equal(expectedY, result.Y);
        }

        [Fact]
        public void Mul_Matrix3x3Vector3_UIntTest()
        {
            UInt3x3 matrix = new UInt3x3(new UInt3((uint)1100, (uint)1200, (uint)1300), new UInt3((uint)1400, (uint)1500, (uint)1600), new UInt3((uint)1700, (uint)1800, (uint)1900));
            UInt3 vector = new UInt3((uint)100, (uint)200, (uint)300);
            UInt3 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            uint expectedX = (uint)1100 * (uint)100 + (uint)1400 * (uint)200 + (uint)1700 * (uint)300;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)1200 * (uint)100 + (uint)1500 * (uint)200 + (uint)1800 * (uint)300;
            Assert.Equal(expectedY, result.Y);
            uint expectedZ = (uint)1300 * (uint)100 + (uint)1600 * (uint)200 + (uint)1900 * (uint)300;
            Assert.Equal(expectedZ, result.Z);
        }

        [Fact]
        public void Mul_Vector3Matrix3x3_UIntTest()
        {
            UInt3 rowVector = new UInt3((uint)2100, (uint)2200, (uint)2300);
            UInt3x3 matrix = new UInt3x3(new UInt3((uint)3100, (uint)3200, (uint)3300), new UInt3((uint)3400, (uint)3500, (uint)3600), new UInt3((uint)3700, (uint)3800, (uint)3900));
            UInt3 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            uint expectedX = (uint)2100 * (uint)3100 + (uint)2200 * (uint)3200 + (uint)2300 * (uint)3300;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)2100 * (uint)3400 + (uint)2200 * (uint)3500 + (uint)2300 * (uint)3600;
            Assert.Equal(expectedY, result.Y);
            uint expectedZ = (uint)2100 * (uint)3700 + (uint)2200 * (uint)3800 + (uint)2300 * (uint)3900;
            Assert.Equal(expectedZ, result.Z);
        }

        [Fact]
        public void Mul_Matrix4x4Vector4_UIntTest()
        {
            UInt4x4 matrix = new UInt4x4(new UInt4((uint)1100, (uint)1200, (uint)1300, (uint)1400), new UInt4((uint)1500, (uint)1600, (uint)1700, (uint)1800), new UInt4((uint)1900, (uint)2000, (uint)2100, (uint)2200), new UInt4((uint)2300, (uint)2400, (uint)2500, (uint)2600));
            UInt4 vector = new UInt4((uint)100, (uint)200, (uint)300, (uint)400);
            UInt4 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            uint expectedX = (uint)1100 * (uint)100 + (uint)1500 * (uint)200 + (uint)1900 * (uint)300 + (uint)2300 * (uint)400;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)1200 * (uint)100 + (uint)1600 * (uint)200 + (uint)2000 * (uint)300 + (uint)2400 * (uint)400;
            Assert.Equal(expectedY, result.Y);
            uint expectedZ = (uint)1300 * (uint)100 + (uint)1700 * (uint)200 + (uint)2100 * (uint)300 + (uint)2500 * (uint)400;
            Assert.Equal(expectedZ, result.Z);
            uint expectedW = (uint)1400 * (uint)100 + (uint)1800 * (uint)200 + (uint)2200 * (uint)300 + (uint)2600 * (uint)400;
            Assert.Equal(expectedW, result.W);
        }

        [Fact]
        public void Mul_Vector4Matrix4x4_UIntTest()
        {
            UInt4 rowVector = new UInt4((uint)2100, (uint)2200, (uint)2300, (uint)2400);
            UInt4x4 matrix = new UInt4x4(new UInt4((uint)3100, (uint)3200, (uint)3300, (uint)3400), new UInt4((uint)3500, (uint)3600, (uint)3700, (uint)3800), new UInt4((uint)3900, (uint)4000, (uint)4100, (uint)4200), new UInt4((uint)4300, (uint)4400, (uint)4500, (uint)4600));
            UInt4 result = Maths.Mul(rowVector, matrix);
            
            // Expected result: rowVector * matrix
            uint expectedX = (uint)2100 * (uint)3100 + (uint)2200 * (uint)3200 + (uint)2300 * (uint)3300 + (uint)2400 * (uint)3400;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)2100 * (uint)3500 + (uint)2200 * (uint)3600 + (uint)2300 * (uint)3700 + (uint)2400 * (uint)3800;
            Assert.Equal(expectedY, result.Y);
            uint expectedZ = (uint)2100 * (uint)3900 + (uint)2200 * (uint)4000 + (uint)2300 * (uint)4100 + (uint)2400 * (uint)4200;
            Assert.Equal(expectedZ, result.Z);
            uint expectedW = (uint)2100 * (uint)4300 + (uint)2200 * (uint)4400 + (uint)2300 * (uint)4500 + (uint)2400 * (uint)4600;
            Assert.Equal(expectedW, result.W);
        }

        [Fact]
        public void Mul_Matrix2x3Vector3_UIntTest()
        {
            UInt2x3 matrix = new UInt2x3(new UInt2((uint)7100, (uint)7200), new UInt2((uint)7300, (uint)7400), new UInt2((uint)7500, (uint)7600));
            UInt3 vector = new UInt3((uint)6100, (uint)6200, (uint)6300);
            UInt2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            uint expectedX = (uint)7100 * (uint)6100 + (uint)7300 * (uint)6200 + (uint)7500 * (uint)6300;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)7200 * (uint)6100 + (uint)7400 * (uint)6200 + (uint)7600 * (uint)6300;
            Assert.Equal(expectedY, result.Y);
        }

        [Fact]
        public void Mul_Matrix3x2Vector2_UIntTest()
        {
            UInt3x2 matrix = new UInt3x2(new UInt3((uint)7100, (uint)7200, (uint)7300), new UInt3((uint)7400, (uint)7500, (uint)7600));
            UInt2 vector = new UInt2((uint)6100, (uint)6200);
            UInt3 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            uint expectedX = (uint)7100 * (uint)6100 + (uint)7400 * (uint)6200;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)7200 * (uint)6100 + (uint)7500 * (uint)6200;
            Assert.Equal(expectedY, result.Y);
            uint expectedZ = (uint)7300 * (uint)6100 + (uint)7600 * (uint)6200;
            Assert.Equal(expectedZ, result.Z);
        }

        [Fact]
        public void Mul_Matrix2x4Vector4_UIntTest()
        {
            UInt2x4 matrix = new UInt2x4(new UInt2((uint)7100, (uint)7200), new UInt2((uint)7300, (uint)7400), new UInt2((uint)7500, (uint)7600), new UInt2((uint)7700, (uint)7800));
            UInt4 vector = new UInt4((uint)6100, (uint)6200, (uint)6300, (uint)6400);
            UInt2 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            uint expectedX = (uint)7100 * (uint)6100 + (uint)7300 * (uint)6200 + (uint)7500 * (uint)6300 + (uint)7700 * (uint)6400;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)7200 * (uint)6100 + (uint)7400 * (uint)6200 + (uint)7600 * (uint)6300 + (uint)7800 * (uint)6400;
            Assert.Equal(expectedY, result.Y);
        }

        [Fact]
        public void Mul_Matrix4x2Vector2_UIntTest()
        {
            UInt4x2 matrix = new UInt4x2(new UInt4((uint)7100, (uint)7200, (uint)7300, (uint)7400), new UInt4((uint)7500, (uint)7600, (uint)7700, (uint)7800));
            UInt2 vector = new UInt2((uint)6100, (uint)6200);
            UInt4 result = Maths.Mul(matrix, vector);
            
            // Expected result: matrix * vector
            uint expectedX = (uint)7100 * (uint)6100 + (uint)7500 * (uint)6200;
            Assert.Equal(expectedX, result.X);
            uint expectedY = (uint)7200 * (uint)6100 + (uint)7600 * (uint)6200;
            Assert.Equal(expectedY, result.Y);
            uint expectedZ = (uint)7300 * (uint)6100 + (uint)7700 * (uint)6200;
            Assert.Equal(expectedZ, result.Z);
            uint expectedW = (uint)7400 * (uint)6100 + (uint)7800 * (uint)6200;
            Assert.Equal(expectedW, result.W);
        }

        [Fact]
        public void Mul_Matrix2x2Matrix2x2_UIntTest()
        {
            UInt2x2 a = new UInt2x2(new UInt2((uint)4100, (uint)4200), new UInt2((uint)4300, (uint)4400));
            UInt2x2 b = new UInt2x2(new UInt2((uint)5100, (uint)5200), new UInt2((uint)5300, (uint)5400));
            UInt2x2 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            uint expectedC0X = (uint)4100 * (uint)5100 + (uint)4300 * (uint)5200;
            Assert.Equal(expectedC0X, result.c0.X);
            uint expectedC0Y = (uint)4200 * (uint)5100 + (uint)4400 * (uint)5200;
            Assert.Equal(expectedC0Y, result.c0.Y);
            uint expectedC1X = (uint)4100 * (uint)5300 + (uint)4300 * (uint)5400;
            Assert.Equal(expectedC1X, result.c1.X);
            uint expectedC1Y = (uint)4200 * (uint)5300 + (uint)4400 * (uint)5400;
            Assert.Equal(expectedC1Y, result.c1.Y);
        }

        [Fact]
        public void Mul_Matrix3x3Matrix3x3_UIntTest()
        {
            UInt3x3 a = new UInt3x3(new UInt3((uint)4100, (uint)4200, (uint)4300), new UInt3((uint)4400, (uint)4500, (uint)4600), new UInt3((uint)4700, (uint)4800, (uint)4900));
            UInt3x3 b = new UInt3x3(new UInt3((uint)5100, (uint)5200, (uint)5300), new UInt3((uint)5400, (uint)5500, (uint)5600), new UInt3((uint)5700, (uint)5800, (uint)5900));
            UInt3x3 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            uint expectedC0X = (uint)4100 * (uint)5100 + (uint)4400 * (uint)5200 + (uint)4700 * (uint)5300;
            Assert.Equal(expectedC0X, result.c0.X);
            uint expectedC0Y = (uint)4200 * (uint)5100 + (uint)4500 * (uint)5200 + (uint)4800 * (uint)5300;
            Assert.Equal(expectedC0Y, result.c0.Y);
            uint expectedC0Z = (uint)4300 * (uint)5100 + (uint)4600 * (uint)5200 + (uint)4900 * (uint)5300;
            Assert.Equal(expectedC0Z, result.c0.Z);
            uint expectedC1X = (uint)4100 * (uint)5400 + (uint)4400 * (uint)5500 + (uint)4700 * (uint)5600;
            Assert.Equal(expectedC1X, result.c1.X);
            uint expectedC1Y = (uint)4200 * (uint)5400 + (uint)4500 * (uint)5500 + (uint)4800 * (uint)5600;
            Assert.Equal(expectedC1Y, result.c1.Y);
            uint expectedC1Z = (uint)4300 * (uint)5400 + (uint)4600 * (uint)5500 + (uint)4900 * (uint)5600;
            Assert.Equal(expectedC1Z, result.c1.Z);
            uint expectedC2X = (uint)4100 * (uint)5700 + (uint)4400 * (uint)5800 + (uint)4700 * (uint)5900;
            Assert.Equal(expectedC2X, result.c2.X);
            uint expectedC2Y = (uint)4200 * (uint)5700 + (uint)4500 * (uint)5800 + (uint)4800 * (uint)5900;
            Assert.Equal(expectedC2Y, result.c2.Y);
            uint expectedC2Z = (uint)4300 * (uint)5700 + (uint)4600 * (uint)5800 + (uint)4900 * (uint)5900;
            Assert.Equal(expectedC2Z, result.c2.Z);
        }

        [Fact]
        public void Mul_Matrix4x4Matrix4x4_UIntTest()
        {
            UInt4x4 a = new UInt4x4(new UInt4((uint)4100, (uint)4200, (uint)4300, (uint)4400), new UInt4((uint)4500, (uint)4600, (uint)4700, (uint)4800), new UInt4((uint)4900, (uint)5000, (uint)5100, (uint)5200), new UInt4((uint)5300, (uint)5400, (uint)5500, (uint)5600));
            UInt4x4 b = new UInt4x4(new UInt4((uint)5100, (uint)5200, (uint)5300, (uint)5400), new UInt4((uint)5500, (uint)5600, (uint)5700, (uint)5800), new UInt4((uint)5900, (uint)6000, (uint)6100, (uint)6200), new UInt4((uint)6300, (uint)6400, (uint)6500, (uint)6600));
            UInt4x4 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            uint expectedC0X = (uint)4100 * (uint)5100 + (uint)4500 * (uint)5200 + (uint)4900 * (uint)5300 + (uint)5300 * (uint)5400;
            Assert.Equal(expectedC0X, result.c0.X);
            uint expectedC0Y = (uint)4200 * (uint)5100 + (uint)4600 * (uint)5200 + (uint)5000 * (uint)5300 + (uint)5400 * (uint)5400;
            Assert.Equal(expectedC0Y, result.c0.Y);
            uint expectedC0Z = (uint)4300 * (uint)5100 + (uint)4700 * (uint)5200 + (uint)5100 * (uint)5300 + (uint)5500 * (uint)5400;
            Assert.Equal(expectedC0Z, result.c0.Z);
            uint expectedC0W = (uint)4400 * (uint)5100 + (uint)4800 * (uint)5200 + (uint)5200 * (uint)5300 + (uint)5600 * (uint)5400;
            Assert.Equal(expectedC0W, result.c0.W);
            uint expectedC1X = (uint)4100 * (uint)5500 + (uint)4500 * (uint)5600 + (uint)4900 * (uint)5700 + (uint)5300 * (uint)5800;
            Assert.Equal(expectedC1X, result.c1.X);
            uint expectedC1Y = (uint)4200 * (uint)5500 + (uint)4600 * (uint)5600 + (uint)5000 * (uint)5700 + (uint)5400 * (uint)5800;
            Assert.Equal(expectedC1Y, result.c1.Y);
            uint expectedC1Z = (uint)4300 * (uint)5500 + (uint)4700 * (uint)5600 + (uint)5100 * (uint)5700 + (uint)5500 * (uint)5800;
            Assert.Equal(expectedC1Z, result.c1.Z);
            uint expectedC1W = (uint)4400 * (uint)5500 + (uint)4800 * (uint)5600 + (uint)5200 * (uint)5700 + (uint)5600 * (uint)5800;
            Assert.Equal(expectedC1W, result.c1.W);
            uint expectedC2X = (uint)4100 * (uint)5900 + (uint)4500 * (uint)6000 + (uint)4900 * (uint)6100 + (uint)5300 * (uint)6200;
            Assert.Equal(expectedC2X, result.c2.X);
            uint expectedC2Y = (uint)4200 * (uint)5900 + (uint)4600 * (uint)6000 + (uint)5000 * (uint)6100 + (uint)5400 * (uint)6200;
            Assert.Equal(expectedC2Y, result.c2.Y);
            uint expectedC2Z = (uint)4300 * (uint)5900 + (uint)4700 * (uint)6000 + (uint)5100 * (uint)6100 + (uint)5500 * (uint)6200;
            Assert.Equal(expectedC2Z, result.c2.Z);
            uint expectedC2W = (uint)4400 * (uint)5900 + (uint)4800 * (uint)6000 + (uint)5200 * (uint)6100 + (uint)5600 * (uint)6200;
            Assert.Equal(expectedC2W, result.c2.W);
            uint expectedC3X = (uint)4100 * (uint)6300 + (uint)4500 * (uint)6400 + (uint)4900 * (uint)6500 + (uint)5300 * (uint)6600;
            Assert.Equal(expectedC3X, result.c3.X);
            uint expectedC3Y = (uint)4200 * (uint)6300 + (uint)4600 * (uint)6400 + (uint)5000 * (uint)6500 + (uint)5400 * (uint)6600;
            Assert.Equal(expectedC3Y, result.c3.Y);
            uint expectedC3Z = (uint)4300 * (uint)6300 + (uint)4700 * (uint)6400 + (uint)5100 * (uint)6500 + (uint)5500 * (uint)6600;
            Assert.Equal(expectedC3Z, result.c3.Z);
            uint expectedC3W = (uint)4400 * (uint)6300 + (uint)4800 * (uint)6400 + (uint)5200 * (uint)6500 + (uint)5600 * (uint)6600;
            Assert.Equal(expectedC3W, result.c3.W);
        }

        [Fact]
        public void Mul_Matrix2x3Matrix3x2_UIntTest()
        {
            UInt2x3 a = new UInt2x3(new UInt2((uint)8100, (uint)8200), new UInt2((uint)8300, (uint)8400), new UInt2((uint)8500, (uint)8600));
            UInt3x2 b = new UInt3x2(new UInt3((uint)9100, (uint)9200, (uint)9300), new UInt3((uint)9400, (uint)9500, (uint)9600));
            UInt2x2 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            uint expectedC0X = (uint)8100 * (uint)9100 + (uint)8300 * (uint)9200 + (uint)8500 * (uint)9300;
            Assert.Equal(expectedC0X, result.c0.X);
            uint expectedC0Y = (uint)8200 * (uint)9100 + (uint)8400 * (uint)9200 + (uint)8600 * (uint)9300;
            Assert.Equal(expectedC0Y, result.c0.Y);
            uint expectedC1X = (uint)8100 * (uint)9400 + (uint)8300 * (uint)9500 + (uint)8500 * (uint)9600;
            Assert.Equal(expectedC1X, result.c1.X);
            uint expectedC1Y = (uint)8200 * (uint)9400 + (uint)8400 * (uint)9500 + (uint)8600 * (uint)9600;
            Assert.Equal(expectedC1Y, result.c1.Y);
        }

        [Fact]
        public void Mul_Matrix3x2Matrix2x4_UIntTest()
        {
            UInt3x2 a = new UInt3x2(new UInt3((uint)8100, (uint)8200, (uint)8300), new UInt3((uint)8400, (uint)8500, (uint)8600));
            UInt2x4 b = new UInt2x4(new UInt2((uint)9100, (uint)9200), new UInt2((uint)9300, (uint)9400), new UInt2((uint)9500, (uint)9600), new UInt2((uint)9700, (uint)9800));
            UInt3x4 result = Maths.Mul(a, b);
            
            // Expected result: a * b
            uint expectedC0X = (uint)8100 * (uint)9100 + (uint)8400 * (uint)9200;
            Assert.Equal(expectedC0X, result.c0.X);
            uint expectedC0Y = (uint)8200 * (uint)9100 + (uint)8500 * (uint)9200;
            Assert.Equal(expectedC0Y, result.c0.Y);
            uint expectedC0Z = (uint)8300 * (uint)9100 + (uint)8600 * (uint)9200;
            Assert.Equal(expectedC0Z, result.c0.Z);
            uint expectedC1X = (uint)8100 * (uint)9300 + (uint)8400 * (uint)9400;
            Assert.Equal(expectedC1X, result.c1.X);
            uint expectedC1Y = (uint)8200 * (uint)9300 + (uint)8500 * (uint)9400;
            Assert.Equal(expectedC1Y, result.c1.Y);
            uint expectedC1Z = (uint)8300 * (uint)9300 + (uint)8600 * (uint)9400;
            Assert.Equal(expectedC1Z, result.c1.Z);
            uint expectedC2X = (uint)8100 * (uint)9500 + (uint)8400 * (uint)9600;
            Assert.Equal(expectedC2X, result.c2.X);
            uint expectedC2Y = (uint)8200 * (uint)9500 + (uint)8500 * (uint)9600;
            Assert.Equal(expectedC2Y, result.c2.Y);
            uint expectedC2Z = (uint)8300 * (uint)9500 + (uint)8600 * (uint)9600;
            Assert.Equal(expectedC2Z, result.c2.Z);
            uint expectedC3X = (uint)8100 * (uint)9700 + (uint)8400 * (uint)9800;
            Assert.Equal(expectedC3X, result.c3.X);
            uint expectedC3Y = (uint)8200 * (uint)9700 + (uint)8500 * (uint)9800;
            Assert.Equal(expectedC3Y, result.c3.Y);
            uint expectedC3Z = (uint)8300 * (uint)9700 + (uint)8600 * (uint)9800;
            Assert.Equal(expectedC3Z, result.c3.Z);
        }

        [Fact]
        public void Pow_FloatScalarTest()
        {
            float x = 1.5f;
            float y = -1f;
            float result = Maths.Pow(x, y);
            float expected = System.MathF.Pow((float)1.5f, (float)-1f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Pow_DoubleScalarTest()
        {
            double x = 1.5;
            double y = -1;
            double result = Maths.Pow(x, y);
            double expected = System.Math.Pow((double)1.5, (double)-1);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Pow_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 y = new Float2(4.5f, -2f);
            Float2 result = Maths.Pow(x, y);
            Float2 expected = new Float2(System.MathF.Pow((float)1.5f, (float)4.5f), System.MathF.Pow((float)-1f, (float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Pow_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 y = new Float3(-2f, 7.5f, -3f);
            Float3 result = Maths.Pow(x, y);
            Float3 expected = new Float3(System.MathF.Pow((float)1.5f, (float)-2f), System.MathF.Pow((float)-1f, (float)7.5f), System.MathF.Pow((float)4.5f, (float)-3f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Pow_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 y = new Float4(7.5f, -3f, 10.5f, -4f);
            Float4 result = Maths.Pow(x, y);
            Float4 expected = new Float4(System.MathF.Pow((float)1.5f, (float)7.5f), System.MathF.Pow((float)-1f, (float)-3f), System.MathF.Pow((float)4.5f, (float)10.5f), System.MathF.Pow((float)-2f, (float)-4f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Pow_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 y = new Double2(4.5, -2);
            Double2 result = Maths.Pow(x, y);
            Double2 expected = new Double2(System.Math.Pow((double)1.5, (double)4.5), System.Math.Pow((double)-1, (double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Pow_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 y = new Double3(-2, 7.5, -3);
            Double3 result = Maths.Pow(x, y);
            Double3 expected = new Double3(System.Math.Pow((double)1.5, (double)-2), System.Math.Pow((double)-1, (double)7.5), System.Math.Pow((double)4.5, (double)-3));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Pow_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 y = new Double4(7.5, -3, 10.5, -4);
            Double4 result = Maths.Pow(x, y);
            Double4 expected = new Double4(System.Math.Pow((double)1.5, (double)7.5), System.Math.Pow((double)-1, (double)-3), System.Math.Pow((double)4.5, (double)10.5), System.Math.Pow((double)-2, (double)-4));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Round_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Round(x);
            float expected = System.MathF.Round((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Round_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Round(x);
            double expected = System.Math.Round((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Round_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Round(x);
            Float2 expected = new Float2(System.MathF.Round((float)1.5f), System.MathF.Round((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Round_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Round(x);
            Float3 expected = new Float3(System.MathF.Round((float)1.5f), System.MathF.Round((float)-1f), System.MathF.Round((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Round_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Round(x);
            Float4 expected = new Float4(System.MathF.Round((float)1.5f), System.MathF.Round((float)-1f), System.MathF.Round((float)4.5f), System.MathF.Round((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Round_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Round(x);
            Double2 expected = new Double2(System.Math.Round((double)1.5), System.Math.Round((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Round_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Round(x);
            Double3 expected = new Double3(System.Math.Round((double)1.5), System.Math.Round((double)-1), System.Math.Round((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Round_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Round(x);
            Double4 expected = new Double4(System.Math.Round((double)1.5), System.Math.Round((double)-1), System.Math.Round((double)4.5), System.Math.Round((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Sign_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Sign(x);
            float expected = System.MathF.Sign((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Sign_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Sign(x);
            double expected = System.Math.Sign((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Sign_IntScalarTest()
        {
            int x = 2;
            int result = Maths.Sign(x);
            int expected = System.Math.Sign((int)2);
            Assert.Equal(expected, result);
        }

        [Fact]
        public void Sign_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Sign(x);
            Float2 expected = new Float2(System.MathF.Sign((float)1.5f), System.MathF.Sign((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Sign_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Sign(x);
            Float3 expected = new Float3(System.MathF.Sign((float)1.5f), System.MathF.Sign((float)-1f), System.MathF.Sign((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Sign_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Sign(x);
            Float4 expected = new Float4(System.MathF.Sign((float)1.5f), System.MathF.Sign((float)-1f), System.MathF.Sign((float)4.5f), System.MathF.Sign((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Sign_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Sign(x);
            Double2 expected = new Double2(System.Math.Sign((double)1.5), System.Math.Sign((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Sign_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Sign(x);
            Double3 expected = new Double3(System.Math.Sign((double)1.5), System.Math.Sign((double)-1), System.Math.Sign((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Sign_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Sign(x);
            Double4 expected = new Double4(System.Math.Sign((double)1.5), System.Math.Sign((double)-1), System.Math.Sign((double)4.5), System.Math.Sign((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Sign_Int2Test()
        {
            Int2 x = new Int2(2, -2);
            Int2 result = Maths.Sign(x);
            Int2 expected = new Int2(System.Math.Sign((int)2), System.Math.Sign((int)-2));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
        }

        [Fact]
        public void Sign_Int3Test()
        {
            Int3 x = new Int3(2, -2, 6);
            Int3 result = Maths.Sign(x);
            Int3 expected = new Int3(System.Math.Sign((int)2), System.Math.Sign((int)-2), System.Math.Sign((int)6));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
        }

        [Fact]
        public void Sign_Int4Test()
        {
            Int4 x = new Int4(2, -2, 6, -4);
            Int4 result = Maths.Sign(x);
            Int4 expected = new Int4(System.Math.Sign((int)2), System.Math.Sign((int)-2), System.Math.Sign((int)6), System.Math.Sign((int)-4));
            Assert.Equal(expected.X, result.X);
            Assert.Equal(expected.Y, result.Y);
            Assert.Equal(expected.Z, result.Z);
            Assert.Equal(expected.W, result.W);
        }

        [Fact]
        public void Sin_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Sin(x);
            float expected = System.MathF.Sin((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Sin_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Sin(x);
            double expected = System.Math.Sin((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Sin_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Sin(x);
            Float2 expected = new Float2(System.MathF.Sin((float)1.5f), System.MathF.Sin((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Sin_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Sin(x);
            Float3 expected = new Float3(System.MathF.Sin((float)1.5f), System.MathF.Sin((float)-1f), System.MathF.Sin((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Sin_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Sin(x);
            Float4 expected = new Float4(System.MathF.Sin((float)1.5f), System.MathF.Sin((float)-1f), System.MathF.Sin((float)4.5f), System.MathF.Sin((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Sin_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Sin(x);
            Double2 expected = new Double2(System.Math.Sin((double)1.5), System.Math.Sin((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Sin_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Sin(x);
            Double3 expected = new Double3(System.Math.Sin((double)1.5), System.Math.Sin((double)-1), System.Math.Sin((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Sin_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Sin(x);
            Double4 expected = new Double4(System.Math.Sin((double)1.5), System.Math.Sin((double)-1), System.Math.Sin((double)4.5), System.Math.Sin((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Sqrt_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Sqrt(x);
            float expected = System.MathF.Sqrt((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Sqrt_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Sqrt(x);
            double expected = System.Math.Sqrt((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Sqrt_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Sqrt(x);
            Float2 expected = new Float2(System.MathF.Sqrt((float)1.5f), System.MathF.Sqrt((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Sqrt_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Sqrt(x);
            Float3 expected = new Float3(System.MathF.Sqrt((float)1.5f), System.MathF.Sqrt((float)-1f), System.MathF.Sqrt((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Sqrt_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Sqrt(x);
            Float4 expected = new Float4(System.MathF.Sqrt((float)1.5f), System.MathF.Sqrt((float)-1f), System.MathF.Sqrt((float)4.5f), System.MathF.Sqrt((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Sqrt_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Sqrt(x);
            Double2 expected = new Double2(System.Math.Sqrt((double)1.5), System.Math.Sqrt((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Sqrt_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Sqrt(x);
            Double3 expected = new Double3(System.Math.Sqrt((double)1.5), System.Math.Sqrt((double)-1), System.Math.Sqrt((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Sqrt_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Sqrt(x);
            Double4 expected = new Double4(System.Math.Sqrt((double)1.5), System.Math.Sqrt((double)-1), System.Math.Sqrt((double)4.5), System.Math.Sqrt((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void Tan_FloatScalarTest()
        {
            float x = 1.5f;
            float result = Maths.Tan(x);
            float expected = System.MathF.Tan((float)1.5f);
            Assert.Equal(expected, result, 0.0001f);
        }

        [Fact]
        public void Tan_DoubleScalarTest()
        {
            double x = 1.5;
            double result = Maths.Tan(x);
            double expected = System.Math.Tan((double)1.5);
            Assert.Equal(expected, result, 0.0000000001);
        }

        [Fact]
        public void Tan_Float2Test()
        {
            Float2 x = new Float2(1.5f, -1f);
            Float2 result = Maths.Tan(x);
            Float2 expected = new Float2(System.MathF.Tan((float)1.5f), System.MathF.Tan((float)-1f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
        }

        [Fact]
        public void Tan_Float3Test()
        {
            Float3 x = new Float3(1.5f, -1f, 4.5f);
            Float3 result = Maths.Tan(x);
            Float3 expected = new Float3(System.MathF.Tan((float)1.5f), System.MathF.Tan((float)-1f), System.MathF.Tan((float)4.5f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
        }

        [Fact]
        public void Tan_Float4Test()
        {
            Float4 x = new Float4(1.5f, -1f, 4.5f, -2f);
            Float4 result = Maths.Tan(x);
            Float4 expected = new Float4(System.MathF.Tan((float)1.5f), System.MathF.Tan((float)-1f), System.MathF.Tan((float)4.5f), System.MathF.Tan((float)-2f));
            Assert.Equal(expected.X, result.X, 0.0001f);
            Assert.Equal(expected.Y, result.Y, 0.0001f);
            Assert.Equal(expected.Z, result.Z, 0.0001f);
            Assert.Equal(expected.W, result.W, 0.0001f);
        }

        [Fact]
        public void Tan_Double2Test()
        {
            Double2 x = new Double2(1.5, -1);
            Double2 result = Maths.Tan(x);
            Double2 expected = new Double2(System.Math.Tan((double)1.5), System.Math.Tan((double)-1));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
        }

        [Fact]
        public void Tan_Double3Test()
        {
            Double3 x = new Double3(1.5, -1, 4.5);
            Double3 result = Maths.Tan(x);
            Double3 expected = new Double3(System.Math.Tan((double)1.5), System.Math.Tan((double)-1), System.Math.Tan((double)4.5));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
        }

        [Fact]
        public void Tan_Double4Test()
        {
            Double4 x = new Double4(1.5, -1, 4.5, -2);
            Double4 result = Maths.Tan(x);
            Double4 expected = new Double4(System.Math.Tan((double)1.5), System.Math.Tan((double)-1), System.Math.Tan((double)4.5), System.Math.Tan((double)-2));
            Assert.Equal(expected.X, result.X, 0.0000000001);
            Assert.Equal(expected.Y, result.Y, 0.0000000001);
            Assert.Equal(expected.Z, result.Z, 0.0000000001);
            Assert.Equal(expected.W, result.W, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Float2_2x2Identity_Test()
        {
            // Test with identity matrix - direction should remain unchanged
            Float2 direction = new Float2(1.0f, 0.0f); // Right vector
            Float2x2 identity = new Float2x2(
                1.0f, 0.0f,
                0.0f, 1.0f
            );
            
            Float2 result = Maths.TransformDirection(direction, identity);
            
            Assert.Equal(1.0f, result.X, 0.0001f);
            Assert.Equal(0.0f, result.Y, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float2_2x2Scale_Test()
        {
            // Test with scale matrix
            Float2 direction = new Float2(1.0f, 1.0f); // Diagonal vector
            Float2x2 scale = new Float2x2(
                2.0f, 0.0f,  // Scale X by 2
                0.0f, 3.0f   // Scale Y by 3
            );
            
            Float2 result = Maths.TransformDirection(direction, scale);
            
            // Direction should be scaled: (1,1) -> (2,3)
            Assert.Equal(2.0f, result.X, 0.0001f);
            Assert.Equal(3.0f, result.Y, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float2_2x2Rotation_Test()
        {
            // Test with 90-degree counter-clockwise rotation
            Float2 direction = new Float2(1.0f, 0.0f); // Right vector
            Float2x2 rotation90 = new Float2x2(
                0.0f, -1.0f,  // 90-degree counter-clockwise rotation
                1.0f, 0.0f
            );
            
            Float2 result = Maths.TransformDirection(direction, rotation90);
            
            // 90-degree rotation of (1,0) should give (0,1)
            Assert.Equal(0.0f, result.X, 0.0001f);
            Assert.Equal(1.0f, result.Y, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float2_2x2Rotation45_Test()
        {
            // Test with 45-degree counter-clockwise rotation
            Float2 direction = new Float2(1.0f, 0.0f); // Right vector
            Float2x2 rotation45 = new Float2x2(
                0.7071068f, -0.7071068f,  // 45-degree counter-clockwise rotation
                0.7071068f, 0.7071068f
            );
            
            Float2 result = Maths.TransformDirection(direction, rotation45);
            
            // 45-degree rotation of (1,0) should give (sqrt(2)/2, sqrt(2)/2)
            Assert.Equal(0.7071068f, result.X, 0.0001f);
            Assert.Equal(0.7071068f, result.Y, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float2_3x3Matrix_Test()
        {
            // Test 2D direction with 3x3 transformation matrix (should ignore translation)
            Float2 direction = new Float2(2.0f, 3.0f);
            Float3x3 transform = new Float3x3(
                new Float3(2.0f, 0.0f, 10.0f), // Scale X by 2, translate by 10
                new Float3(0.0f, 3.0f, 20.0f), // Scale Y by 3, translate by 20
                new Float3(0.0f, 0.0f, 1.0f)   // Homogeneous row
            );
            
            Float2 result = Maths.TransformDirection(direction, transform);
            
            // Should extract upper-left 2x2 and ignore translation
            // (2,3) scaled by (2,3) = (4,9)
            Assert.Equal(4.0f, result.X, 0.0001f);
            Assert.Equal(9.0f, result.Y, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float2_3x3WithRotation_Test()
        {
            // Test 2D direction with 3x3 matrix containing rotation and translation
            Float2 direction = new Float2(1.0f, 0.0f); // Right vector
            Float3x3 rotateAndTranslate = new Float3x3(
                new Float3(0.0f, -1.0f, 5.0f), // 90° rotation + translation
                new Float3(1.0f, 0.0f, 7.0f),
                new Float3(0.0f, 0.0f, 1.0f)
            );
            
            Float2 result = Maths.TransformDirection(direction, rotateAndTranslate);
            
            // Should rotate (1,0) to (0,1) and ignore translation
            Assert.Equal(0.0f, result.X, 0.0001f);
            Assert.Equal(1.0f, result.Y, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float3_3x3Identity_Test()
        {
            // Test with identity matrix - direction should remain unchanged
            Float3 direction = new Float3(1.0f, 0.0f, 0.0f); // Right vector
            Float3x3 identity = new Float3x3(
                new Float3(1.0f, 0.0f, 0.0f),
                new Float3(0.0f, 1.0f, 0.0f),
                new Float3(0.0f, 0.0f, 1.0f)
            );
            
            Float3 result = Maths.TransformDirection(direction, identity);
            
            Assert.Equal(1.0f, result.X, 0.0001f);
            Assert.Equal(0.0f, result.Y, 0.0001f);
            Assert.Equal(0.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float3_3x3Scale_Test()
        {
            // Test with scale matrix
            Float3 direction = new Float3(2.0f, 3.0f, 4.0f);
            Float3x3 scale = new Float3x3(
                new Float3(2.0f, 0.0f, 0.0f), // Scale X by 2
                new Float3(0.0f, 3.0f, 0.0f), // Scale Y by 3
                new Float3(0.0f, 0.0f, 0.5f)  // Scale Z by 0.5
            );
            
            Float3 result = Maths.TransformDirection(direction, scale);
            
            // Direction should be scaled: (2,3,4) -> (4,9,2)
            Assert.Equal(4.0f, result.X, 0.0001f);
            Assert.Equal(9.0f, result.Y, 0.0001f);
            Assert.Equal(2.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float3_3x3RotationX_Test()
        {
            // Test with 90-degree rotation around X-axis
            Float3 direction = new Float3(0.0f, 1.0f, 0.0f); // Up vector
            Float3x3 rotationX90 = new Float3x3(
                new Float3(1.0f, 0.0f, 0.0f),  // X unchanged
                new Float3(0.0f, 0.0f, 1.0f),  // Y -> Z   <-- FIX: Changed -1.0 to 1.0
                new Float3(0.0f, -1.0f, 0.0f)   // Z -> -Y  <-- FIX: Changed 1.0 to -1.0
            );
            
            Float3 result = Maths.TransformDirection(direction, rotationX90);
            
            // 90-degree rotation around X: (0,1,0) -> (0,0,1)
            Assert.Equal(0.0f, result.X, 0.0001f);
            Assert.Equal(0.0f, result.Y, 0.0001f);
            Assert.Equal(1.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float3_3x3RotationY_Test()
        {
            // Test with 90-degree rotation around Y-axis
            Float3 direction = new Float3(1.0f, 0.0f, 0.0f); // Right vector
            Float3x3 rotationY90 = new Float3x3(
                new Float3(0.0f, 0.0f, -1.0f),  // X -> Z
                new Float3(0.0f, 1.0f, 0.0f),  // Y unchanged
                new Float3(-1.0f, 0.0f, 0.0f) // Z -> -X
            );
            
            Float3 result = Maths.TransformDirection(direction, rotationY90);
            
            // 90-degree rotation around Y: (1,0,0) -> (0,0,-1)
            Assert.Equal(0.0f, result.X, 0.0001f);
            Assert.Equal(0.0f, result.Y, 0.0001f);
            Assert.Equal(-1.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float3_4x4Matrix_Test()
        {
            // Test 3D direction with 4x4 transformation matrix (should ignore translation)
            Float3 direction = new Float3(1.0f, 2.0f, 3.0f);
            Float4x4 transform = new Float4x4(
                new Float4(2.0f, 0.0f, 0.0f, 10.0f), // Scale X by 2, translate
                new Float4(0.0f, 3.0f, 0.0f, 20.0f), // Scale Y by 3, translate
                new Float4(0.0f, 0.0f, 4.0f, 30.0f), // Scale Z by 4, translate
                new Float4(0.0f, 0.0f, 0.0f, 1.0f)   // Homogeneous row
            );
            
            Float3 result = Maths.TransformDirection(direction, transform);
            
            // Should extract upper-left 3x3 and ignore translation
            // (1,2,3) scaled by (2,3,4) = (2,6,12)
            Assert.Equal(2.0f, result.X, 0.0001f);
            Assert.Equal(6.0f, result.Y, 0.0001f);
            Assert.Equal(12.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float3_4x4WithRotationAndTranslation_Test()
        {
            // Test 3D direction with 4x4 matrix containing rotation and translation
            Float3 direction = new Float3(0.0f, 1.0f, 0.0f); // Up vector
            Float4x4 rotateAndTranslate = new Float4x4(
                new Float4(1.0f, 0.0f, 0.0f, 100.0f), // No X rotation, translate
                new Float4(0.0f, 0.0f, -1.0f, 200.0f), // Y -> -Z, translate
                new Float4(0.0f, 1.0f, 0.0f, 300.0f), // Z -> Y, translate
                new Float4(0.0f, 0.0f, 0.0f, 1.0f)    // Homogeneous row
            );
            
            Float3 result = Maths.TransformDirection(direction, rotateAndTranslate);
            
            // Should rotate (0,1,0) to (0,0,1) and ignore translation
            Assert.Equal(0.0f, result.X, 0.0001f);
            Assert.Equal(0.0f, result.Y, 0.0001f);
            Assert.Equal(1.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Float3_4x4UniformScale_Test()
        {
            // Test with uniform scale (should preserve direction ratios)
            Float3 direction = new Float3(1.0f, 2.0f, 3.0f);
            Float4x4 uniformScale = new Float4x4(
                new Float4(2.0f, 0.0f, 0.0f, 0.0f), // Uniform scale by 2
                new Float4(0.0f, 2.0f, 0.0f, 0.0f),
                new Float4(0.0f, 0.0f, 2.0f, 0.0f),
                new Float4(0.0f, 0.0f, 0.0f, 1.0f)
            );
            
            Float3 result = Maths.TransformDirection(direction, uniformScale);
            
            // Uniform scale should preserve ratios: (1,2,3) -> (2,4,6)
            Assert.Equal(2.0f, result.X, 0.0001f);
            Assert.Equal(4.0f, result.Y, 0.0001f);
            Assert.Equal(6.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformDirection_Double2_2x2Identity_Test()
        {
            // Test with identity matrix - direction should remain unchanged
            Double2 direction = new Double2(1.0, 0.0); // Right vector
            Double2x2 identity = new Double2x2(
                1.0, 0.0,
                0.0, 1.0
            );
            
            Double2 result = Maths.TransformDirection(direction, identity);
            
            Assert.Equal(1.0, result.X, 0.0000000001);
            Assert.Equal(0.0, result.Y, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double2_2x2Scale_Test()
        {
            // Test with scale matrix
            Double2 direction = new Double2(1.0, 1.0); // Diagonal vector
            Double2x2 scale = new Double2x2(
                2.0, 0.0,  // Scale X by 2
                0.0, 3.0   // Scale Y by 3
            );
            
            Double2 result = Maths.TransformDirection(direction, scale);
            
            // Direction should be scaled: (1,1) -> (2,3)
            Assert.Equal(2.0, result.X, 0.0000000001);
            Assert.Equal(3.0, result.Y, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double2_2x2Rotation_Test()
        {
            // Test with 90-degree counter-clockwise rotation
            Double2 direction = new Double2(1.0, 0.0); // Right vector
            Double2x2 rotation90 = new Double2x2(
                0.0, -1.0,  // 90-degree counter-clockwise rotation
                1.0, 0.0
            );
            
            Double2 result = Maths.TransformDirection(direction, rotation90);
            
            // 90-degree rotation of (1,0) should give (0,1)
            Assert.Equal(0.0, result.X, 0.0000000001);
            Assert.Equal(1.0, result.Y, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double2_2x2Rotation45_Test()
        {
            // Test with 45-degree counter-clockwise rotation
            Double2 direction = new Double2(1.0, 0.0); // Right vector
            Double2x2 rotation45 = new Double2x2(
                0.7071067811865475, -0.7071067811865475,  // 45-degree counter-clockwise rotation
                0.7071067811865475, 0.7071067811865475
            );
            
            Double2 result = Maths.TransformDirection(direction, rotation45);
            
            // 45-degree rotation of (1,0) should give (sqrt(2)/2, sqrt(2)/2)
            Assert.Equal(0.7071067811865475, result.X, 0.0000000001);
            Assert.Equal(0.7071067811865475, result.Y, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double2_3x3Matrix_Test()
        {
            // Test 2D direction with 3x3 transformation matrix (should ignore translation)
            Double2 direction = new Double2(2.0, 3.0);
            Double3x3 transform = new Double3x3(
                new Double3(2.0, 0.0, 10.0), // Scale X by 2, translate by 10
                new Double3(0.0, 3.0, 20.0), // Scale Y by 3, translate by 20
                new Double3(0.0, 0.0, 1.0)   // Homogeneous row
            );
            
            Double2 result = Maths.TransformDirection(direction, transform);
            
            // Should extract upper-left 2x2 and ignore translation
            // (2,3) scaled by (2,3) = (4,9)
            Assert.Equal(4.0, result.X, 0.0000000001);
            Assert.Equal(9.0, result.Y, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double2_3x3WithRotation_Test()
        {
            // Test 2D direction with 3x3 matrix containing rotation and translation
            Double2 direction = new Double2(1.0, 0.0); // Right vector
            Double3x3 rotateAndTranslate = new Double3x3(
                new Double3(0.0, -1.0, 5.0), // 90° rotation + translation
                new Double3(1.0, 0.0, 7.0),
                new Double3(0.0, 0.0, 1.0)
            );
            
            Double2 result = Maths.TransformDirection(direction, rotateAndTranslate);
            
            // Should rotate (1,0) to (0,1) and ignore translation
            Assert.Equal(0.0, result.X, 0.0000000001);
            Assert.Equal(1.0, result.Y, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double3_3x3Identity_Test()
        {
            // Test with identity matrix - direction should remain unchanged
            Double3 direction = new Double3(1.0, 0.0, 0.0); // Right vector
            Double3x3 identity = new Double3x3(
                new Double3(1.0, 0.0, 0.0),
                new Double3(0.0, 1.0, 0.0),
                new Double3(0.0, 0.0, 1.0)
            );
            
            Double3 result = Maths.TransformDirection(direction, identity);
            
            Assert.Equal(1.0, result.X, 0.0000000001);
            Assert.Equal(0.0, result.Y, 0.0000000001);
            Assert.Equal(0.0, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double3_3x3Scale_Test()
        {
            // Test with scale matrix
            Double3 direction = new Double3(2.0, 3.0, 4.0);
            Double3x3 scale = new Double3x3(
                new Double3(2.0, 0.0, 0.0), // Scale X by 2
                new Double3(0.0, 3.0, 0.0), // Scale Y by 3
                new Double3(0.0, 0.0, 0.5)  // Scale Z by 0.5
            );
            
            Double3 result = Maths.TransformDirection(direction, scale);
            
            // Direction should be scaled: (2,3,4) -> (4,9,2)
            Assert.Equal(4.0, result.X, 0.0000000001);
            Assert.Equal(9.0, result.Y, 0.0000000001);
            Assert.Equal(2.0, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double3_3x3RotationX_Test()
        {
            // Test with 90-degree rotation around X-axis
            Double3 direction = new Double3(0.0, 1.0, 0.0); // Up vector
            Double3x3 rotationX90 = new Double3x3(
                new Double3(1.0, 0.0, 0.0),  // X unchanged
                new Double3(0.0, 0.0, 1.0),  // Y -> Z   <-- FIX: Changed -1.0 to 1.0
                new Double3(0.0, -1.0, 0.0)   // Z -> -Y  <-- FIX: Changed 1.0 to -1.0
            );
            
            Double3 result = Maths.TransformDirection(direction, rotationX90);
            
            // 90-degree rotation around X: (0,1,0) -> (0,0,1)
            Assert.Equal(0.0, result.X, 0.0000000001);
            Assert.Equal(0.0, result.Y, 0.0000000001);
            Assert.Equal(1.0, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double3_3x3RotationY_Test()
        {
            // Test with 90-degree rotation around Y-axis
            Double3 direction = new Double3(1.0, 0.0, 0.0); // Right vector
            Double3x3 rotationY90 = new Double3x3(
                new Double3(0.0, 0.0, -1.0),  // X -> Z
                new Double3(0.0, 1.0, 0.0),  // Y unchanged
                new Double3(-1.0, 0.0, 0.0) // Z -> -X
            );
            
            Double3 result = Maths.TransformDirection(direction, rotationY90);
            
            // 90-degree rotation around Y: (1,0,0) -> (0,0,-1)
            Assert.Equal(0.0, result.X, 0.0000000001);
            Assert.Equal(0.0, result.Y, 0.0000000001);
            Assert.Equal(-1.0, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double3_4x4Matrix_Test()
        {
            // Test 3D direction with 4x4 transformation matrix (should ignore translation)
            Double3 direction = new Double3(1.0, 2.0, 3.0);
            Double4x4 transform = new Double4x4(
                new Double4(2.0, 0.0, 0.0, 10.0), // Scale X by 2, translate
                new Double4(0.0, 3.0, 0.0, 20.0), // Scale Y by 3, translate
                new Double4(0.0, 0.0, 4.0, 30.0), // Scale Z by 4, translate
                new Double4(0.0, 0.0, 0.0, 1.0)   // Homogeneous row
            );
            
            Double3 result = Maths.TransformDirection(direction, transform);
            
            // Should extract upper-left 3x3 and ignore translation
            // (1,2,3) scaled by (2,3,4) = (2,6,12)
            Assert.Equal(2.0, result.X, 0.0000000001);
            Assert.Equal(6.0, result.Y, 0.0000000001);
            Assert.Equal(12.0, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double3_4x4WithRotationAndTranslation_Test()
        {
            // Test 3D direction with 4x4 matrix containing rotation and translation
            Double3 direction = new Double3(0.0, 1.0, 0.0); // Up vector
            Double4x4 rotateAndTranslate = new Double4x4(
                new Double4(1.0, 0.0, 0.0, 100.0), // No X rotation, translate
                new Double4(0.0, 0.0, -1.0, 200.0), // Y -> -Z, translate
                new Double4(0.0, 1.0, 0.0, 300.0), // Z -> Y, translate
                new Double4(0.0, 0.0, 0.0, 1.0)    // Homogeneous row
            );
            
            Double3 result = Maths.TransformDirection(direction, rotateAndTranslate);
            
            // Should rotate (0,1,0) to (0,0,1) and ignore translation
            Assert.Equal(0.0, result.X, 0.0000000001);
            Assert.Equal(0.0, result.Y, 0.0000000001);
            Assert.Equal(1.0, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformDirection_Double3_4x4UniformScale_Test()
        {
            // Test with uniform scale (should preserve direction ratios)
            Double3 direction = new Double3(1.0, 2.0, 3.0);
            Double4x4 uniformScale = new Double4x4(
                new Double4(2.0, 0.0, 0.0, 0.0), // Uniform scale by 2
                new Double4(0.0, 2.0, 0.0, 0.0),
                new Double4(0.0, 0.0, 2.0, 0.0),
                new Double4(0.0, 0.0, 0.0, 1.0)
            );
            
            Double3 result = Maths.TransformDirection(direction, uniformScale);
            
            // Uniform scale should preserve ratios: (1,2,3) -> (2,4,6)
            Assert.Equal(2.0, result.X, 0.0000000001);
            Assert.Equal(4.0, result.Y, 0.0000000001);
            Assert.Equal(6.0, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformNormal_Float2_2x2Identity_Test()
        {
            // Test with identity matrix - normal should remain unchanged
            Float2 normal = new Float2(0.0f, 1.0f); // Up vector
            Float2x2 identity = new Float2x2(
                1.0f, 0.0f,
                0.0f, 1.0f
            );
            
            Float2 result = Maths.TransformNormal(normal, identity);
            
            Assert.Equal(0.0f, result.X, 0.0001f);
            Assert.Equal(1.0f, result.Y, 0.0001f);
        }

        [Fact]
        public void TransformNormal_Float2_2x2Scale_Test()
        {
            // Test with non-uniform scale - normal should be transformed by inverse transpose
            Float2 normal = new Float2(1.0f, 0.0f); // Right vector
            Float2x2 scale = new Float2x2(
                2.0f, 0.0f,  // Scale X by 2
                0.0f, 4.0f   // Scale Y by 4
            );
            
            Float2 result = Maths.TransformNormal(normal, scale);
            
            // For non-uniform scale, normal should be scaled by reciprocal and normalized
            // Inverse transpose of scale matrix has (0.5, 0, 0, 0.25)
            // Transformed normal would be (0.5, 0), normalized to (1, 0)
            Assert.Equal(1.0f, result.X, 0.0001f);
            Assert.Equal(0.0f, result.Y, 0.0001f);
        }

        [Fact]
        public void TransformNormal_Float2_2x2Rotation_Test()
        {
            // Test with 45-degree rotation
            Float2 normal = new Float2(1.0f, 0.0f); // Right vector
            Float2x2 rotation = new Float2x2(
                0.7071068f, -0.7071068f,  // 45-degree counter-clockwise rotation
                0.7071068f, 0.7071068f
            );
            
            Float2 result = Maths.TransformNormal(normal, rotation);
            
            // 45-degree rotation of (1,0) should give approximately (sqrt(2)/2, sqrt(2)/2)
            Assert.Equal(0.7071068f, result.X, 0.0001f);
            Assert.Equal(0.7071068f, result.Y, 0.0001f);
        }

        [Fact]
        public void TransformNormal_Float2_3x3Matrix_Test()
        {
            // Test 2D normal with 3x3 transformation matrix
            Float2 normal = new Float2(0.0f, 1.0f); // Up vector
            Float3x3 transform = new Float3x3(
                new Float3(2.0f, 0.0f, 5.0f), // Scale X by 2, translate by 5
                new Float3(0.0f, 3.0f, 7.0f), // Scale Y by 3, translate by 7
                new Float3(0.0f, 0.0f, 1.0f)  // Homogeneous row
            );
            
            Float2 result = Maths.TransformNormal(normal, transform);
            
            // Should extract upper-left 2x2 and transform normal accordingly
            // Inverse transpose of [[2,0],[0,3]] is [[0.5,0],[0,1/3]], so (0,1) -> (0,1/3) -> normalized (0,1)
            Assert.Equal(0.0f, result.X, 0.0001f);
            Assert.Equal(1.0f, result.Y, 0.0001f);
        }

        [Fact]
        public void TransformNormal_Float3_3x3Identity_Test()
        {
            // Test with identity matrix - normal should remain unchanged
            Float3 normal = new Float3(0.0f, 0.0f, 1.0f); // Forward vector
            Float3x3 identity = new Float3x3(
                new Float3(1.0f, 0.0f, 0.0f),
                new Float3(0.0f, 1.0f, 0.0f),
                new Float3(0.0f, 0.0f, 1.0f)
            );
            
            Float3 result = Maths.TransformNormal(normal, identity);
            
            Assert.Equal(0.0f, result.X, 0.0001f);
            Assert.Equal(0.0f, result.Y, 0.0001f);
            Assert.Equal(1.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformNormal_Float3_3x3Scale_Test()
        {
            // Test with non-uniform scale
            Float3 normal = new Float3(1.0f, 0.0f, 0.0f); // Right vector
            Float3x3 scale = new Float3x3(
                new Float3(2.0f, 0.0f, 0.0f), // Scale X by 2
                new Float3(0.0f, 3.0f, 0.0f), // Scale Y by 3
                new Float3(0.0f, 0.0f, 4.0f)  // Scale Z by 4
            );
            
            Float3 result = Maths.TransformNormal(normal, scale);
            
            // For non-uniform scale, normal should be scaled by reciprocal and normalized
            // Inverse transpose of scale matrix scales by (0.5, 1/3, 0.25)
            // (1,0,0) -> (0.5,0,0) -> normalized (1,0,0)
            Assert.Equal(1.0f, result.X, 0.0001f);
            Assert.Equal(0.0f, result.Y, 0.0001f);
            Assert.Equal(0.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformNormal_Float3_3x3UniformScale_Test()
        {
            // Test with uniform scale - normal should remain the same direction
            Float3 normal = new Float3(0.5773503f, 0.5773503f, 0.5773503f); // Normalized diagonal vector
            Float3x3 uniformScale = new Float3x3(
                new Float3(2.0f, 0.0f, 0.0f), // Uniform scale by 2
                new Float3(0.0f, 2.0f, 0.0f),
                new Float3(0.0f, 0.0f, 2.0f)
            );
            
            Float3 result = Maths.TransformNormal(normal, uniformScale);
            
            // With uniform scale, normal direction should be preserved
            Assert.Equal(0.5773503f, result.X, 0.0001f);
            Assert.Equal(0.5773503f, result.Y, 0.0001f);
            Assert.Equal(0.5773503f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformNormal_Float3_4x4Matrix_Test()
        {
            // Test 3D normal with 4x4 transformation matrix
            Float3 normal = new Float3(1.0f, 0.0f, 0.0f); // Right vector
            Float4x4 transform = new Float4x4(
                new Float4(2.0f, 0.0f, 0.0f, 10.0f), // Scale X by 2, translate
                new Float4(0.0f, 3.0f, 0.0f, 20.0f), // Scale Y by 3, translate
                new Float4(0.0f, 0.0f, 4.0f, 30.0f), // Scale Z by 4, translate
                new Float4(0.0f, 0.0f, 0.0f, 1.0f)   // Homogeneous row
            );
            
            Float3 result = Maths.TransformNormal(normal, transform);
            
            // Should extract upper-left 3x3 and transform normal accordingly
            // Translation should be ignored for normals
            // Inverse transpose of scale matrix should transform (1,0,0) -> (0.5,0,0) -> normalized (1,0,0)
            Assert.Equal(1.0f, result.X, 0.0001f);
            Assert.Equal(0.0f, result.Y, 0.0001f);
            Assert.Equal(0.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformNormal_Float3_4x4WithRotation_Test()
        {
            // Test with a rotation around Y-axis (90 degrees)
            Float3 normal = new Float3(1.0f, 0.0f, 0.0f); // Right vector
            Float4x4 rotationY = new Float4x4(
                new Float4(0.0f, 0.0f, 1.0f, 0.0f),  // 90° rotation around Y
                new Float4(0.0f, 1.0f, 0.0f, 0.0f),
                new Float4(-1.0f, 0.0f, 0.0f, 0.0f),
                new Float4(0.0f, 0.0f, 0.0f, 1.0f)
            );
            
            Float3 result = Maths.TransformNormal(normal, rotationY);
            
            // 90° rotation around Y should transform (1,0,0) to (0,0,-1)
            Assert.Equal(0.0f, result.X, 0.0001f);
            Assert.Equal(0.0f, result.Y, 0.0001f);
            Assert.Equal(-1.0f, result.Z, 0.0001f);
        }

        [Fact]
        public void TransformNormal_Double2_2x2Identity_Test()
        {
            // Test with identity matrix - normal should remain unchanged
            Double2 normal = new Double2(0.0, 1.0); // Up vector
            Double2x2 identity = new Double2x2(
                1.0, 0.0,
                0.0, 1.0
            );
            
            Double2 result = Maths.TransformNormal(normal, identity);
            
            Assert.Equal(0.0, result.X, 0.0000000001);
            Assert.Equal(1.0, result.Y, 0.0000000001);
        }

        [Fact]
        public void TransformNormal_Double2_2x2Scale_Test()
        {
            // Test with non-uniform scale - normal should be transformed by inverse transpose
            Double2 normal = new Double2(1.0, 0.0); // Right vector
            Double2x2 scale = new Double2x2(
                2.0, 0.0,  // Scale X by 2
                0.0, 4.0   // Scale Y by 4
            );
            
            Double2 result = Maths.TransformNormal(normal, scale);
            
            // For non-uniform scale, normal should be scaled by reciprocal and normalized
            // Inverse transpose of scale matrix has (0.5, 0, 0, 0.25)
            // Transformed normal would be (0.5, 0), normalized to (1, 0)
            Assert.Equal(1.0, result.X, 0.0000000001);
            Assert.Equal(0.0, result.Y, 0.0000000001);
        }

        [Fact]
        public void TransformNormal_Double2_2x2Rotation_Test()
        {
            // Test with 45-degree rotation
            Double2 normal = new Double2(1.0, 0.0); // Right vector
            Double2x2 rotation = new Double2x2(
                0.7071067811865475, -0.7071067811865475,  // 45-degree counter-clockwise rotation
                0.7071067811865475, 0.7071067811865475
            );
            
            Double2 result = Maths.TransformNormal(normal, rotation);
            
            // 45-degree rotation of (1,0) should give approximately (sqrt(2)/2, sqrt(2)/2)
            Assert.Equal(0.7071067811865475, result.X, 0.0000000001);
            Assert.Equal(0.7071067811865475, result.Y, 0.0000000001);
        }

        [Fact]
        public void TransformNormal_Double2_3x3Matrix_Test()
        {
            // Test 2D normal with 3x3 transformation matrix
            Double2 normal = new Double2(0.0, 1.0); // Up vector
            Double3x3 transform = new Double3x3(
                new Double3(2.0, 0.0, 5.0), // Scale X by 2, translate by 5
                new Double3(0.0, 3.0, 7.0), // Scale Y by 3, translate by 7
                new Double3(0.0, 0.0, 1.0)  // Homogeneous row
            );
            
            Double2 result = Maths.TransformNormal(normal, transform);
            
            // Should extract upper-left 2x2 and transform normal accordingly
            // Inverse transpose of [[2,0],[0,3]] is [[0.5,0],[0,1/3]], so (0,1) -> (0,1/3) -> normalized (0,1)
            Assert.Equal(0.0, result.X, 0.0000000001);
            Assert.Equal(1.0, result.Y, 0.0000000001);
        }

        [Fact]
        public void TransformNormal_Double3_3x3Identity_Test()
        {
            // Test with identity matrix - normal should remain unchanged
            Double3 normal = new Double3(0.0, 0.0, 1.0); // Forward vector
            Double3x3 identity = new Double3x3(
                new Double3(1.0, 0.0, 0.0),
                new Double3(0.0, 1.0, 0.0),
                new Double3(0.0, 0.0, 1.0)
            );
            
            Double3 result = Maths.TransformNormal(normal, identity);
            
            Assert.Equal(0.0, result.X, 0.0000000001);
            Assert.Equal(0.0, result.Y, 0.0000000001);
            Assert.Equal(1.0, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformNormal_Double3_3x3Scale_Test()
        {
            // Test with non-uniform scale
            Double3 normal = new Double3(1.0, 0.0, 0.0); // Right vector
            Double3x3 scale = new Double3x3(
                new Double3(2.0, 0.0, 0.0), // Scale X by 2
                new Double3(0.0, 3.0, 0.0), // Scale Y by 3
                new Double3(0.0, 0.0, 4.0)  // Scale Z by 4
            );
            
            Double3 result = Maths.TransformNormal(normal, scale);
            
            // For non-uniform scale, normal should be scaled by reciprocal and normalized
            // Inverse transpose of scale matrix scales by (0.5, 1/3, 0.25)
            // (1,0,0) -> (0.5,0,0) -> normalized (1,0,0)
            Assert.Equal(1.0, result.X, 0.0000000001);
            Assert.Equal(0.0, result.Y, 0.0000000001);
            Assert.Equal(0.0, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformNormal_Double3_3x3UniformScale_Test()
        {
            // Test with uniform scale - normal should remain the same direction
            Double3 normal = new Double3(0.5773502691896257, 0.5773502691896257, 0.5773502691896257); // Normalized diagonal vector
            Double3x3 uniformScale = new Double3x3(
                new Double3(2.0, 0.0, 0.0), // Uniform scale by 2
                new Double3(0.0, 2.0, 0.0),
                new Double3(0.0, 0.0, 2.0)
            );
            
            Double3 result = Maths.TransformNormal(normal, uniformScale);
            
            // With uniform scale, normal direction should be preserved
            Assert.Equal(0.5773502691896257, result.X, 0.0000000001);
            Assert.Equal(0.5773502691896257, result.Y, 0.0000000001);
            Assert.Equal(0.5773502691896257, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformNormal_Double3_4x4Matrix_Test()
        {
            // Test 3D normal with 4x4 transformation matrix
            Double3 normal = new Double3(1.0, 0.0, 0.0); // Right vector
            Double4x4 transform = new Double4x4(
                new Double4(2.0, 0.0, 0.0, 10.0), // Scale X by 2, translate
                new Double4(0.0, 3.0, 0.0, 20.0), // Scale Y by 3, translate
                new Double4(0.0, 0.0, 4.0, 30.0), // Scale Z by 4, translate
                new Double4(0.0, 0.0, 0.0, 1.0)   // Homogeneous row
            );
            
            Double3 result = Maths.TransformNormal(normal, transform);
            
            // Should extract upper-left 3x3 and transform normal accordingly
            // Translation should be ignored for normals
            // Inverse transpose of scale matrix should transform (1,0,0) -> (0.5,0,0) -> normalized (1,0,0)
            Assert.Equal(1.0, result.X, 0.0000000001);
            Assert.Equal(0.0, result.Y, 0.0000000001);
            Assert.Equal(0.0, result.Z, 0.0000000001);
        }

        [Fact]
        public void TransformNormal_Double3_4x4WithRotation_Test()
        {
            // Test with a rotation around Y-axis (90 degrees)
            Double3 normal = new Double3(1.0, 0.0, 0.0); // Right vector
            Double4x4 rotationY = new Double4x4(
                new Double4(0.0, 0.0, 1.0, 0.0),  // 90° rotation around Y
                new Double4(0.0, 1.0, 0.0, 0.0),
                new Double4(-1.0, 0.0, 0.0, 0.0),
                new Double4(0.0, 0.0, 0.0, 1.0)
            );
            
            Double3 result = Maths.TransformNormal(normal, rotationY);
            
            // 90° rotation around Y should transform (1,0,0) to (0,0,-1)
            Assert.Equal(0.0, result.X, 0.0000000001);
            Assert.Equal(0.0, result.Y, 0.0000000001);
            Assert.Equal(-1.0, result.Z, 0.0000000001);
        }

        [Fact]
public void TransformPoint_Float2_3x3Matrix_IdentityTest()
{
// Test with identity matrix - point should remain unchanged
Float2 point = new Float2(3.0f, 4.0f);
Float3x3 identity = new Float3x3(
new Float3(1.0f, 0.0f, 0.0f),
new Float3(0.0f, 1.0f, 0.0f),
new Float3(0.0f, 0.0f, 1.0f)
);

Float2 result = Maths.TransformPoint(point, identity);

Assert.Equal(point.X, result.X, 0.0001f);
Assert.Equal(point.Y, result.Y, 0.0001f);
}

        [Fact]
public void TransformPoint_Float2_3x3Matrix_TranslationTest()
{
// Test with translation matrix
Float2 point = new Float2(1.0f, 2.0f);
Float3x3 translation = new Float3x3(
new Float3(1.0f, 0.0f, 0.0f),  // Column 0
new Float3(0.0f, 1.0f, 0.0f),  // Column 1
new Float3(5.0f, 7.0f, 1.0f)   // Column 2 (Tx, Ty, W). This is the translation column.
);

Float2 result = Maths.TransformPoint(point, translation);

float expectedX = 6.0f; // 1 + 5
float expectedY = 9.0f; // 2 + 7
Assert.Equal(expectedX, result.X, 0.0001f);
Assert.Equal(expectedY, result.Y, 0.0001f);
}

        [Fact]
public void TransformPoint_Float2_3x3Matrix_ScaleTest()
{
// Test with scale matrix
Float2 point = new Float2(2.0f, 3.0f);
Float3x3 scale = new Float3x3(
new Float3(2.0f, 0.0f, 0.0f), // scale X by 2
new Float3(0.0f, 3.0f, 0.0f), // scale Y by 3
new Float3(0.0f, 0.0f, 1.0f)   // Last column for homogeneous coordinate
);

Float2 result = Maths.TransformPoint(point, scale);

float expectedX = 4.0f; // 2 * 2
float expectedY = 9.0f; // 3 * 3
Assert.Equal(expectedX, result.X, 0.0001f);
Assert.Equal(expectedY, result.Y, 0.0001f);
}

        [Fact]
public void TransformPoint_Float2_3x3Matrix_PerspectiveDivideTest()
{
// Test perspective divide with non-unity W component
Float2 point = new Float2(4.0f, 6.0f);
Float3x3 perspective = new Float3x3(
new Float3(1.0f, 0.0f, 0.0f),
new Float3(0.0f, 1.0f, 0.0f),
new Float3(0.0f, 0.0f, 2.0f) // This 2.0 in the (3,3) position will be the W component (Z for 3x3)
);

Float2 result = Maths.TransformPoint(point, perspective);

float expectedX = 2.0f; // 4 / 2
float expectedY = 3.0f; // 6 / 2
Assert.Equal(expectedX, result.X, 0.0001f);
Assert.Equal(expectedY, result.Y, 0.0001f);
}

        [Fact]
public void TransformPoint_Float3_4x4Matrix_IdentityTest()
{
// Test with identity matrix - point should remain unchanged
Float3 point = new Float3(2.0f, 3.0f, 4.0f);
Float4x4 identity = new Float4x4(
new Float4(1.0f, 0.0f, 0.0f, 0.0f),
new Float4(0.0f, 1.0f, 0.0f, 0.0f),
new Float4(0.0f, 0.0f, 1.0f, 0.0f),
new Float4(0.0f, 0.0f, 0.0f, 1.0f)
);

Float3 result = Maths.TransformPoint(point, identity);

Assert.Equal(point.X, result.X, 0.0001f);
Assert.Equal(point.Y, result.Y, 0.0001f);
Assert.Equal(point.Z, result.Z, 0.0001f);
}

        [Fact]
public void TransformPoint_Float3_4x4Matrix_TranslationTest()
{
// Test with translation matrix
Float3 point = new Float3(1.0f, 2.0f, 3.0f);
Float4x4 translation = new Float4x4(
new Float4(1.0f, 0.0f, 0.0f, 0.0f),  // Column 0
new Float4(0.0f, 1.0f, 0.0f, 0.0f),  // Column 1
new Float4(0.0f, 0.0f, 1.0f, 0.0f),  // Column 2
new Float4(5.0f, 6.0f, 7.0f, 1.0f)   // Column 3 (Tx, Ty, Tz, W). This is the translation column.
);

Float3 result = Maths.TransformPoint(point, translation);

float expectedX = 6.0f; // 1 + 5
float expectedY = 8.0f; // 2 + 6
float expectedZ = 10.0f; // 3 + 7
Assert.Equal(expectedX, result.X, 0.0001f);
Assert.Equal(expectedY, result.Y, 0.0001f);
Assert.Equal(expectedZ, result.Z, 0.0001f);
}

        [Fact]
public void TransformPoint_Float3_4x4Matrix_ScaleTest()
{
// Test with scale matrix
Float3 point = new Float3(2.0f, 3.0f, 4.0f);
Float4x4 scale = new Float4x4(
new Float4(2.0f, 0.0f, 0.0f, 0.0f), // scale X by 2
new Float4(0.0f, 3.0f, 0.0f, 0.0f), // scale Y by 3
new Float4(0.0f, 0.0f, 0.5f, 0.0f), // scale Z by 0.5
new Float4(0.0f, 0.0f, 0.0f, 1.0f)   // Last column for homogeneous coordinate
);

Float3 result = Maths.TransformPoint(point, scale);

float expectedX = 4.0f; // 2 * 2
float expectedY = 9.0f; // 3 * 3
float expectedZ = 2.0f; // 4 * 0.5
Assert.Equal(expectedX, result.X, 0.0001f);
Assert.Equal(expectedY, result.Y, 0.0001f);
Assert.Equal(expectedZ, result.Z, 0.0001f);
}

        [Fact]
public void TransformPoint_Float3_4x4Matrix_PerspectiveDivideTest()
{
// Test perspective divide with non-unity W component
Float3 point = new Float3(6.0f, 8.0f, 12.0f);
Float4x4 perspective = new Float4x4(
new Float4(1.0f, 0.0f, 0.0f, 0.0f),
new Float4(0.0f, 1.0f, 0.0f, 0.0f),
new Float4(0.0f, 0.0f, 1.0f, 0.0f),
new Float4(0.0f, 0.0f, 0.0f, 2.0f) // This 2.0 in the (4,4) position will be the W component
);

Float3 result = Maths.TransformPoint(point, perspective);

float expectedX = 3.0f; // 6 / 2
float expectedY = 4.0f; // 8 / 2
float expectedZ = 6.0f; // 12 / 2
Assert.Equal(expectedX, result.X, 0.0001f);
Assert.Equal(expectedY, result.Y, 0.0001f);
Assert.Equal(expectedZ, result.Z, 0.0001f);
}

        [Fact]
public void TransformPoint_Float4_4x4Matrix_IdentityTest()
{
// Test with identity matrix - point should remain unchanged
Float4 point = new Float4(1.0f, 2.0f, 3.0f, 4.0f);
Float4x4 identity = new Float4x4(
new Float4(1.0f, 0.0f, 0.0f, 0.0f),
new Float4(0.0f, 1.0f, 0.0f, 0.0f),
new Float4(0.0f, 0.0f, 1.0f, 0.0f),
new Float4(0.0f, 0.0f, 0.0f, 1.0f)
);

Float4 result = Maths.TransformPoint(point, identity);

Assert.Equal(point.X, result.X, 0.0001f);
Assert.Equal(point.Y, result.Y, 0.0001f);
Assert.Equal(point.Z, result.Z, 0.0001f);
Assert.Equal(point.W, result.W, 0.0001f);
}

        [Fact]
public void TransformPoint_Float4_4x4Matrix_ScaleTest()
{
// Test with scale transformation
Float4 point = new Float4(2.0f, 3.0f, 4.0f, 5.0f);
Float4x4 scale = new Float4x4(
new Float4(2.0f, 0.0f, 0.0f, 0.0f), // scale X by 2
new Float4(0.0f, 3.0f, 0.0f, 0.0f), // scale Y by 3
new Float4(0.0f, 0.0f, 0.5f, 0.0f), // scale Z by 0.5
new Float4(0.0f, 0.0f, 0.0f, 0.2f)   // scale W by 0.2
);

Float4 result = Maths.TransformPoint(point, scale);

float expectedX = 4.0f; // 2 * 2
float expectedY = 9.0f; // 3 * 3
float expectedZ = 2.0f; // 4 * 0.5
float expectedW = 1.0f; // 5 * 0.2
Assert.Equal(expectedX, result.X, 0.0001f);
Assert.Equal(expectedY, result.Y, 0.0001f);
Assert.Equal(expectedZ, result.Z, 0.0001f);
Assert.Equal(expectedW, result.W, 0.0001f);
}

        [Fact]
public void TransformPoint_Float4_4x4Matrix_GeneralTransformTest()
{
// Test with a general transformation matrix
Float4 point = new Float4(1.0f, 1.0f, 1.0f, 1.0f);
Float4x4 transform = new Float4x4(
new Float4(1.0f, 2.0f, 3.0f, 4.0f),   // Column 0
new Float4(5.0f, 6.0f, 7.0f, 8.0f),   // Column 1
new Float4(9.0f, 10.0f, 11.0f, 12.0f), // Column 2
new Float4(13.0f, 14.0f, 15.0f, 16.0f) // Column 3
);

Float4 result = Maths.TransformPoint(point, transform);

// Corrected Expected values based on matrix (column-major) * vector (column) multiplication
float expectedX = 28.0f; // 1 + 5 + 9 + 13
float expectedY = 32.0f; // 2 + 6 + 10 + 14
float expectedZ = 36.0f; // 3 + 7 + 11 + 15
float expectedW = 40.0f; // 4 + 8 + 12 + 16

Assert.Equal(expectedX, result.X, 0.0001f);
Assert.Equal(expectedY, result.Y, 0.0001f);
Assert.Equal(expectedZ, result.Z, 0.0001f);
Assert.Equal(expectedW, result.W, 0.0001f);
}

        [Fact]
public void TransformPoint_Double2_3x3Matrix_IdentityTest()
{
// Test with identity matrix - point should remain unchanged
Double2 point = new Double2(3.0, 4.0);
Double3x3 identity = new Double3x3(
new Double3(1.0, 0.0, 0.0),
new Double3(0.0, 1.0, 0.0),
new Double3(0.0, 0.0, 1.0)
);

Double2 result = Maths.TransformPoint(point, identity);

Assert.Equal(point.X, result.X, 0.0000000001);
Assert.Equal(point.Y, result.Y, 0.0000000001);
}

        [Fact]
public void TransformPoint_Double2_3x3Matrix_TranslationTest()
{
// Test with translation matrix
Double2 point = new Double2(1.0, 2.0);
Double3x3 translation = new Double3x3(
new Double3(1.0, 0.0, 0.0),  // Column 0
new Double3(0.0, 1.0, 0.0),  // Column 1
new Double3(5.0, 7.0, 1.0)   // Column 2 (Tx, Ty, W). This is the translation column.
);

Double2 result = Maths.TransformPoint(point, translation);

double expectedX = 6.0; // 1 + 5
double expectedY = 9.0; // 2 + 7
Assert.Equal(expectedX, result.X, 0.0000000001);
Assert.Equal(expectedY, result.Y, 0.0000000001);
}

        [Fact]
public void TransformPoint_Double2_3x3Matrix_ScaleTest()
{
// Test with scale matrix
Double2 point = new Double2(2.0, 3.0);
Double3x3 scale = new Double3x3(
new Double3(2.0, 0.0, 0.0), // scale X by 2
new Double3(0.0, 3.0, 0.0), // scale Y by 3
new Double3(0.0, 0.0, 1.0)   // Last column for homogeneous coordinate
);

Double2 result = Maths.TransformPoint(point, scale);

double expectedX = 4.0; // 2 * 2
double expectedY = 9.0; // 3 * 3
Assert.Equal(expectedX, result.X, 0.0000000001);
Assert.Equal(expectedY, result.Y, 0.0000000001);
}

        [Fact]
public void TransformPoint_Double2_3x3Matrix_PerspectiveDivideTest()
{
// Test perspective divide with non-unity W component
Double2 point = new Double2(4.0, 6.0);
Double3x3 perspective = new Double3x3(
new Double3(1.0, 0.0, 0.0),
new Double3(0.0, 1.0, 0.0),
new Double3(0.0, 0.0, 2.0) // This 2.0 in the (3,3) position will be the W component (Z for 3x3)
);

Double2 result = Maths.TransformPoint(point, perspective);

double expectedX = 2.0; // 4 / 2
double expectedY = 3.0; // 6 / 2
Assert.Equal(expectedX, result.X, 0.0000000001);
Assert.Equal(expectedY, result.Y, 0.0000000001);
}

        [Fact]
public void TransformPoint_Double3_4x4Matrix_IdentityTest()
{
// Test with identity matrix - point should remain unchanged
Double3 point = new Double3(2.0, 3.0, 4.0);
Double4x4 identity = new Double4x4(
new Double4(1.0, 0.0, 0.0, 0.0),
new Double4(0.0, 1.0, 0.0, 0.0),
new Double4(0.0, 0.0, 1.0, 0.0),
new Double4(0.0, 0.0, 0.0, 1.0)
);

Double3 result = Maths.TransformPoint(point, identity);

Assert.Equal(point.X, result.X, 0.0000000001);
Assert.Equal(point.Y, result.Y, 0.0000000001);
Assert.Equal(point.Z, result.Z, 0.0000000001);
}

        [Fact]
public void TransformPoint_Double3_4x4Matrix_TranslationTest()
{
// Test with translation matrix
Double3 point = new Double3(1.0, 2.0, 3.0);
Double4x4 translation = new Double4x4(
new Double4(1.0, 0.0, 0.0, 0.0),  // Column 0
new Double4(0.0, 1.0, 0.0, 0.0),  // Column 1
new Double4(0.0, 0.0, 1.0, 0.0),  // Column 2
new Double4(5.0, 6.0, 7.0, 1.0)   // Column 3 (Tx, Ty, Tz, W). This is the translation column.
);

Double3 result = Maths.TransformPoint(point, translation);

double expectedX = 6.0; // 1 + 5
double expectedY = 8.0; // 2 + 6
double expectedZ = 10.0; // 3 + 7
Assert.Equal(expectedX, result.X, 0.0000000001);
Assert.Equal(expectedY, result.Y, 0.0000000001);
Assert.Equal(expectedZ, result.Z, 0.0000000001);
}

        [Fact]
public void TransformPoint_Double3_4x4Matrix_ScaleTest()
{
// Test with scale matrix
Double3 point = new Double3(2.0, 3.0, 4.0);
Double4x4 scale = new Double4x4(
new Double4(2.0, 0.0, 0.0, 0.0), // scale X by 2
new Double4(0.0, 3.0, 0.0, 0.0), // scale Y by 3
new Double4(0.0, 0.0, 0.5, 0.0), // scale Z by 0.5
new Double4(0.0, 0.0, 0.0, 1.0)   // Last column for homogeneous coordinate
);

Double3 result = Maths.TransformPoint(point, scale);

double expectedX = 4.0; // 2 * 2
double expectedY = 9.0; // 3 * 3
double expectedZ = 2.0; // 4 * 0.5
Assert.Equal(expectedX, result.X, 0.0000000001);
Assert.Equal(expectedY, result.Y, 0.0000000001);
Assert.Equal(expectedZ, result.Z, 0.0000000001);
}

        [Fact]
public void TransformPoint_Double3_4x4Matrix_PerspectiveDivideTest()
{
// Test perspective divide with non-unity W component
Double3 point = new Double3(6.0, 8.0, 12.0);
Double4x4 perspective = new Double4x4(
new Double4(1.0, 0.0, 0.0, 0.0),
new Double4(0.0, 1.0, 0.0, 0.0),
new Double4(0.0, 0.0, 1.0, 0.0),
new Double4(0.0, 0.0, 0.0, 2.0) // This 2.0 in the (4,4) position will be the W component
);

Double3 result = Maths.TransformPoint(point, perspective);

double expectedX = 3.0; // 6 / 2
double expectedY = 4.0; // 8 / 2
double expectedZ = 6.0; // 12 / 2
Assert.Equal(expectedX, result.X, 0.0000000001);
Assert.Equal(expectedY, result.Y, 0.0000000001);
Assert.Equal(expectedZ, result.Z, 0.0000000001);
}

        [Fact]
public void TransformPoint_Double4_4x4Matrix_IdentityTest()
{
// Test with identity matrix - point should remain unchanged
Double4 point = new Double4(1.0, 2.0, 3.0, 4.0);
Double4x4 identity = new Double4x4(
new Double4(1.0, 0.0, 0.0, 0.0),
new Double4(0.0, 1.0, 0.0, 0.0),
new Double4(0.0, 0.0, 1.0, 0.0),
new Double4(0.0, 0.0, 0.0, 1.0)
);

Double4 result = Maths.TransformPoint(point, identity);

Assert.Equal(point.X, result.X, 0.0000000001);
Assert.Equal(point.Y, result.Y, 0.0000000001);
Assert.Equal(point.Z, result.Z, 0.0000000001);
Assert.Equal(point.W, result.W, 0.0000000001);
}

        [Fact]
public void TransformPoint_Double4_4x4Matrix_ScaleTest()
{
// Test with scale transformation
Double4 point = new Double4(2.0, 3.0, 4.0, 5.0);
Double4x4 scale = new Double4x4(
new Double4(2.0, 0.0, 0.0, 0.0), // scale X by 2
new Double4(0.0, 3.0, 0.0, 0.0), // scale Y by 3
new Double4(0.0, 0.0, 0.5, 0.0), // scale Z by 0.5
new Double4(0.0, 0.0, 0.0, 0.2)   // scale W by 0.2
);

Double4 result = Maths.TransformPoint(point, scale);

double expectedX = 4.0; // 2 * 2
double expectedY = 9.0; // 3 * 3
double expectedZ = 2.0; // 4 * 0.5
double expectedW = 1.0; // 5 * 0.2
Assert.Equal(expectedX, result.X, 0.0000000001);
Assert.Equal(expectedY, result.Y, 0.0000000001);
Assert.Equal(expectedZ, result.Z, 0.0000000001);
Assert.Equal(expectedW, result.W, 0.0000000001);
}

        [Fact]
public void TransformPoint_Double4_4x4Matrix_GeneralTransformTest()
{
// Test with a general transformation matrix
Double4 point = new Double4(1.0, 1.0, 1.0, 1.0);
Double4x4 transform = new Double4x4(
new Double4(1.0, 2.0, 3.0, 4.0),   // Column 0
new Double4(5.0, 6.0, 7.0, 8.0),   // Column 1
new Double4(9.0, 10.0, 11.0, 12.0), // Column 2
new Double4(13.0, 14.0, 15.0, 16.0) // Column 3
);

Double4 result = Maths.TransformPoint(point, transform);

// Corrected Expected values based on matrix (column-major) * vector (column) multiplication
double expectedX = 28.0; // 1 + 5 + 9 + 13
double expectedY = 32.0; // 2 + 6 + 10 + 14
double expectedZ = 36.0; // 3 + 7 + 11 + 15
double expectedW = 40.0; // 4 + 8 + 12 + 16

Assert.Equal(expectedX, result.X, 0.0000000001);
Assert.Equal(expectedY, result.Y, 0.0000000001);
Assert.Equal(expectedZ, result.Z, 0.0000000001);
Assert.Equal(expectedW, result.W, 0.0000000001);
}

        [Fact]
        public void Transpose_Float2x2Test()
        {
            // Create test matrix with known values
            Float2x2 source = new Float2x2(new Float2(1.5f, -1f), new Float2(4.5f, -2f));

            // Perform transpose
            Float2x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5f, result.c0.X, 0.0001f);
            Assert.Equal(-1f, result.c1.X, 0.0001f);
            Assert.Equal(4.5f, result.c0.Y, 0.0001f);
            Assert.Equal(-2f, result.c1.Y, 0.0001f);
        }


        [Fact]
        public void Transpose_Float3x3Test()
        {
            // Create test matrix with known values
            Float3x3 source = new Float3x3(new Float3(1.5f, -1f, 4.5f), new Float3(-2f, 7.5f, -3f), new Float3(10.5f, -4f, 13.5f));

            // Perform transpose
            Float3x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5f, result.c0.X, 0.0001f);
            Assert.Equal(-1f, result.c1.X, 0.0001f);
            Assert.Equal(4.5f, result.c2.X, 0.0001f);
            Assert.Equal(-2f, result.c0.Y, 0.0001f);
            Assert.Equal(7.5f, result.c1.Y, 0.0001f);
            Assert.Equal(-3f, result.c2.Y, 0.0001f);
            Assert.Equal(10.5f, result.c0.Z, 0.0001f);
            Assert.Equal(-4f, result.c1.Z, 0.0001f);
            Assert.Equal(13.5f, result.c2.Z, 0.0001f);
        }


        [Fact]
        public void Transpose_Float4x4Test()
        {
            // Create test matrix with known values
            Float4x4 source = new Float4x4(new Float4(1.5f, -1f, 4.5f, -2f), new Float4(7.5f, -3f, 10.5f, -4f), new Float4(13.5f, -5f, 16.5f, -6f), new Float4(19.5f, -7f, 22.5f, -8f));

            // Perform transpose
            Float4x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5f, result.c0.X, 0.0001f);
            Assert.Equal(-1f, result.c1.X, 0.0001f);
            Assert.Equal(4.5f, result.c2.X, 0.0001f);
            Assert.Equal(-2f, result.c3.X, 0.0001f);
            Assert.Equal(7.5f, result.c0.Y, 0.0001f);
            Assert.Equal(-3f, result.c1.Y, 0.0001f);
            Assert.Equal(10.5f, result.c2.Y, 0.0001f);
            Assert.Equal(-4f, result.c3.Y, 0.0001f);
            Assert.Equal(13.5f, result.c0.Z, 0.0001f);
            Assert.Equal(-5f, result.c1.Z, 0.0001f);
            Assert.Equal(16.5f, result.c2.Z, 0.0001f);
            Assert.Equal(-6f, result.c3.Z, 0.0001f);
            Assert.Equal(19.5f, result.c0.W, 0.0001f);
            Assert.Equal(-7f, result.c1.W, 0.0001f);
            Assert.Equal(22.5f, result.c2.W, 0.0001f);
            Assert.Equal(-8f, result.c3.W, 0.0001f);
        }


        [Fact]
        public void Transpose_Float2x3Test()
        {
            // Create test matrix with known values
            Float2x3 source = new Float2x3(new Float2(1.5f, -1f), new Float2(4.5f, -2f), new Float2(7.5f, -3f));

            // Perform transpose
            Float3x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5f, result.c0.X, 0.0001f);
            Assert.Equal(-1f, result.c1.X, 0.0001f);
            Assert.Equal(4.5f, result.c0.Y, 0.0001f);
            Assert.Equal(-2f, result.c1.Y, 0.0001f);
            Assert.Equal(7.5f, result.c0.Z, 0.0001f);
            Assert.Equal(-3f, result.c1.Z, 0.0001f);
        }


        [Fact]
        public void Transpose_Float2x4Test()
        {
            // Create test matrix with known values
            Float2x4 source = new Float2x4(new Float2(1.5f, -1f), new Float2(4.5f, -2f), new Float2(7.5f, -3f), new Float2(10.5f, -4f));

            // Perform transpose
            Float4x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5f, result.c0.X, 0.0001f);
            Assert.Equal(-1f, result.c1.X, 0.0001f);
            Assert.Equal(4.5f, result.c0.Y, 0.0001f);
            Assert.Equal(-2f, result.c1.Y, 0.0001f);
            Assert.Equal(7.5f, result.c0.Z, 0.0001f);
            Assert.Equal(-3f, result.c1.Z, 0.0001f);
            Assert.Equal(10.5f, result.c0.W, 0.0001f);
            Assert.Equal(-4f, result.c1.W, 0.0001f);
        }


        [Fact]
        public void Transpose_Float3x2Test()
        {
            // Create test matrix with known values
            Float3x2 source = new Float3x2(new Float3(1.5f, -1f, 4.5f), new Float3(-2f, 7.5f, -3f));

            // Perform transpose
            Float2x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5f, result.c0.X, 0.0001f);
            Assert.Equal(-1f, result.c1.X, 0.0001f);
            Assert.Equal(-2f, result.c0.Y, 0.0001f);
            Assert.Equal(7.5f, result.c1.Y, 0.0001f);
        }


        [Fact]
        public void Transpose_Float3x4Test()
        {
            // Create test matrix with known values
            Float3x4 source = new Float3x4(new Float3(1.5f, -1f, 4.5f), new Float3(-2f, 7.5f, -3f), new Float3(10.5f, -4f, 13.5f), new Float3(-5f, 16.5f, -6f));

            // Perform transpose
            Float4x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5f, result.c0.X, 0.0001f);
            Assert.Equal(-1f, result.c1.X, 0.0001f);
            Assert.Equal(4.5f, result.c2.X, 0.0001f);
            Assert.Equal(-2f, result.c0.Y, 0.0001f);
            Assert.Equal(7.5f, result.c1.Y, 0.0001f);
            Assert.Equal(-3f, result.c2.Y, 0.0001f);
            Assert.Equal(10.5f, result.c0.Z, 0.0001f);
            Assert.Equal(-4f, result.c1.Z, 0.0001f);
            Assert.Equal(13.5f, result.c2.Z, 0.0001f);
            Assert.Equal(-5f, result.c0.W, 0.0001f);
            Assert.Equal(16.5f, result.c1.W, 0.0001f);
            Assert.Equal(-6f, result.c2.W, 0.0001f);
        }


        [Fact]
        public void Transpose_Float4x2Test()
        {
            // Create test matrix with known values
            Float4x2 source = new Float4x2(new Float4(1.5f, -1f, 4.5f, -2f), new Float4(7.5f, -3f, 10.5f, -4f));

            // Perform transpose
            Float2x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5f, result.c0.X, 0.0001f);
            Assert.Equal(-1f, result.c1.X, 0.0001f);
            Assert.Equal(7.5f, result.c0.Y, 0.0001f);
            Assert.Equal(-3f, result.c1.Y, 0.0001f);
        }


        [Fact]
        public void Transpose_Float4x3Test()
        {
            // Create test matrix with known values
            Float4x3 source = new Float4x3(new Float4(1.5f, -1f, 4.5f, -2f), new Float4(7.5f, -3f, 10.5f, -4f), new Float4(13.5f, -5f, 16.5f, -6f));

            // Perform transpose
            Float3x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5f, result.c0.X, 0.0001f);
            Assert.Equal(-1f, result.c1.X, 0.0001f);
            Assert.Equal(4.5f, result.c2.X, 0.0001f);
            Assert.Equal(7.5f, result.c0.Y, 0.0001f);
            Assert.Equal(-3f, result.c1.Y, 0.0001f);
            Assert.Equal(10.5f, result.c2.Y, 0.0001f);
            Assert.Equal(13.5f, result.c0.Z, 0.0001f);
            Assert.Equal(-5f, result.c1.Z, 0.0001f);
            Assert.Equal(16.5f, result.c2.Z, 0.0001f);
        }


        [Fact]
        public void Transpose_Double2x2Test()
        {
            // Create test matrix with known values
            Double2x2 source = new Double2x2(new Double2(1.5, -1), new Double2(4.5, -2));

            // Perform transpose
            Double2x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5, result.c0.X, 0.0000000001);
            Assert.Equal(-1, result.c1.X, 0.0000000001);
            Assert.Equal(4.5, result.c0.Y, 0.0000000001);
            Assert.Equal(-2, result.c1.Y, 0.0000000001);
        }


        [Fact]
        public void Transpose_Double3x3Test()
        {
            // Create test matrix with known values
            Double3x3 source = new Double3x3(new Double3(1.5, -1, 4.5), new Double3(-2, 7.5, -3), new Double3(10.5, -4, 13.5));

            // Perform transpose
            Double3x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5, result.c0.X, 0.0000000001);
            Assert.Equal(-1, result.c1.X, 0.0000000001);
            Assert.Equal(4.5, result.c2.X, 0.0000000001);
            Assert.Equal(-2, result.c0.Y, 0.0000000001);
            Assert.Equal(7.5, result.c1.Y, 0.0000000001);
            Assert.Equal(-3, result.c2.Y, 0.0000000001);
            Assert.Equal(10.5, result.c0.Z, 0.0000000001);
            Assert.Equal(-4, result.c1.Z, 0.0000000001);
            Assert.Equal(13.5, result.c2.Z, 0.0000000001);
        }


        [Fact]
        public void Transpose_Double4x4Test()
        {
            // Create test matrix with known values
            Double4x4 source = new Double4x4(new Double4(1.5, -1, 4.5, -2), new Double4(7.5, -3, 10.5, -4), new Double4(13.5, -5, 16.5, -6), new Double4(19.5, -7, 22.5, -8));

            // Perform transpose
            Double4x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5, result.c0.X, 0.0000000001);
            Assert.Equal(-1, result.c1.X, 0.0000000001);
            Assert.Equal(4.5, result.c2.X, 0.0000000001);
            Assert.Equal(-2, result.c3.X, 0.0000000001);
            Assert.Equal(7.5, result.c0.Y, 0.0000000001);
            Assert.Equal(-3, result.c1.Y, 0.0000000001);
            Assert.Equal(10.5, result.c2.Y, 0.0000000001);
            Assert.Equal(-4, result.c3.Y, 0.0000000001);
            Assert.Equal(13.5, result.c0.Z, 0.0000000001);
            Assert.Equal(-5, result.c1.Z, 0.0000000001);
            Assert.Equal(16.5, result.c2.Z, 0.0000000001);
            Assert.Equal(-6, result.c3.Z, 0.0000000001);
            Assert.Equal(19.5, result.c0.W, 0.0000000001);
            Assert.Equal(-7, result.c1.W, 0.0000000001);
            Assert.Equal(22.5, result.c2.W, 0.0000000001);
            Assert.Equal(-8, result.c3.W, 0.0000000001);
        }


        [Fact]
        public void Transpose_Double2x3Test()
        {
            // Create test matrix with known values
            Double2x3 source = new Double2x3(new Double2(1.5, -1), new Double2(4.5, -2), new Double2(7.5, -3));

            // Perform transpose
            Double3x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5, result.c0.X, 0.0000000001);
            Assert.Equal(-1, result.c1.X, 0.0000000001);
            Assert.Equal(4.5, result.c0.Y, 0.0000000001);
            Assert.Equal(-2, result.c1.Y, 0.0000000001);
            Assert.Equal(7.5, result.c0.Z, 0.0000000001);
            Assert.Equal(-3, result.c1.Z, 0.0000000001);
        }


        [Fact]
        public void Transpose_Double2x4Test()
        {
            // Create test matrix with known values
            Double2x4 source = new Double2x4(new Double2(1.5, -1), new Double2(4.5, -2), new Double2(7.5, -3), new Double2(10.5, -4));

            // Perform transpose
            Double4x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5, result.c0.X, 0.0000000001);
            Assert.Equal(-1, result.c1.X, 0.0000000001);
            Assert.Equal(4.5, result.c0.Y, 0.0000000001);
            Assert.Equal(-2, result.c1.Y, 0.0000000001);
            Assert.Equal(7.5, result.c0.Z, 0.0000000001);
            Assert.Equal(-3, result.c1.Z, 0.0000000001);
            Assert.Equal(10.5, result.c0.W, 0.0000000001);
            Assert.Equal(-4, result.c1.W, 0.0000000001);
        }


        [Fact]
        public void Transpose_Double3x2Test()
        {
            // Create test matrix with known values
            Double3x2 source = new Double3x2(new Double3(1.5, -1, 4.5), new Double3(-2, 7.5, -3));

            // Perform transpose
            Double2x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5, result.c0.X, 0.0000000001);
            Assert.Equal(-1, result.c1.X, 0.0000000001);
            Assert.Equal(-2, result.c0.Y, 0.0000000001);
            Assert.Equal(7.5, result.c1.Y, 0.0000000001);
        }


        [Fact]
        public void Transpose_Double3x4Test()
        {
            // Create test matrix with known values
            Double3x4 source = new Double3x4(new Double3(1.5, -1, 4.5), new Double3(-2, 7.5, -3), new Double3(10.5, -4, 13.5), new Double3(-5, 16.5, -6));

            // Perform transpose
            Double4x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5, result.c0.X, 0.0000000001);
            Assert.Equal(-1, result.c1.X, 0.0000000001);
            Assert.Equal(4.5, result.c2.X, 0.0000000001);
            Assert.Equal(-2, result.c0.Y, 0.0000000001);
            Assert.Equal(7.5, result.c1.Y, 0.0000000001);
            Assert.Equal(-3, result.c2.Y, 0.0000000001);
            Assert.Equal(10.5, result.c0.Z, 0.0000000001);
            Assert.Equal(-4, result.c1.Z, 0.0000000001);
            Assert.Equal(13.5, result.c2.Z, 0.0000000001);
            Assert.Equal(-5, result.c0.W, 0.0000000001);
            Assert.Equal(16.5, result.c1.W, 0.0000000001);
            Assert.Equal(-6, result.c2.W, 0.0000000001);
        }


        [Fact]
        public void Transpose_Double4x2Test()
        {
            // Create test matrix with known values
            Double4x2 source = new Double4x2(new Double4(1.5, -1, 4.5, -2), new Double4(7.5, -3, 10.5, -4));

            // Perform transpose
            Double2x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5, result.c0.X, 0.0000000001);
            Assert.Equal(-1, result.c1.X, 0.0000000001);
            Assert.Equal(7.5, result.c0.Y, 0.0000000001);
            Assert.Equal(-3, result.c1.Y, 0.0000000001);
        }


        [Fact]
        public void Transpose_Double4x3Test()
        {
            // Create test matrix with known values
            Double4x3 source = new Double4x3(new Double4(1.5, -1, 4.5, -2), new Double4(7.5, -3, 10.5, -4), new Double4(13.5, -5, 16.5, -6));

            // Perform transpose
            Double3x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(1.5, result.c0.X, 0.0000000001);
            Assert.Equal(-1, result.c1.X, 0.0000000001);
            Assert.Equal(4.5, result.c2.X, 0.0000000001);
            Assert.Equal(7.5, result.c0.Y, 0.0000000001);
            Assert.Equal(-3, result.c1.Y, 0.0000000001);
            Assert.Equal(10.5, result.c2.Y, 0.0000000001);
            Assert.Equal(13.5, result.c0.Z, 0.0000000001);
            Assert.Equal(-5, result.c1.Z, 0.0000000001);
            Assert.Equal(16.5, result.c2.Z, 0.0000000001);
        }


        [Fact]
        public void Transpose_Int2x2Test()
        {
            // Create test matrix with known values
            Int2x2 source = new Int2x2(new Int2(2, -2), new Int2(6, -4));

            // Perform transpose
            Int2x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(2, result.c0.X);
            Assert.Equal(-2, result.c1.X);
            Assert.Equal(6, result.c0.Y);
            Assert.Equal(-4, result.c1.Y);
        }


        [Fact]
        public void Transpose_Int3x3Test()
        {
            // Create test matrix with known values
            Int3x3 source = new Int3x3(new Int3(2, -2, 6), new Int3(-4, 10, -6), new Int3(14, -8, 18));

            // Perform transpose
            Int3x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(2, result.c0.X);
            Assert.Equal(-2, result.c1.X);
            Assert.Equal(6, result.c2.X);
            Assert.Equal(-4, result.c0.Y);
            Assert.Equal(10, result.c1.Y);
            Assert.Equal(-6, result.c2.Y);
            Assert.Equal(14, result.c0.Z);
            Assert.Equal(-8, result.c1.Z);
            Assert.Equal(18, result.c2.Z);
        }


        [Fact]
        public void Transpose_Int4x4Test()
        {
            // Create test matrix with known values
            Int4x4 source = new Int4x4(new Int4(2, -2, 6, -4), new Int4(10, -6, 14, -8), new Int4(18, -10, 22, -12), new Int4(26, -14, 30, -16));

            // Perform transpose
            Int4x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(2, result.c0.X);
            Assert.Equal(-2, result.c1.X);
            Assert.Equal(6, result.c2.X);
            Assert.Equal(-4, result.c3.X);
            Assert.Equal(10, result.c0.Y);
            Assert.Equal(-6, result.c1.Y);
            Assert.Equal(14, result.c2.Y);
            Assert.Equal(-8, result.c3.Y);
            Assert.Equal(18, result.c0.Z);
            Assert.Equal(-10, result.c1.Z);
            Assert.Equal(22, result.c2.Z);
            Assert.Equal(-12, result.c3.Z);
            Assert.Equal(26, result.c0.W);
            Assert.Equal(-14, result.c1.W);
            Assert.Equal(30, result.c2.W);
            Assert.Equal(-16, result.c3.W);
        }


        [Fact]
        public void Transpose_Int2x3Test()
        {
            // Create test matrix with known values
            Int2x3 source = new Int2x3(new Int2(2, -2), new Int2(6, -4), new Int2(10, -6));

            // Perform transpose
            Int3x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(2, result.c0.X);
            Assert.Equal(-2, result.c1.X);
            Assert.Equal(6, result.c0.Y);
            Assert.Equal(-4, result.c1.Y);
            Assert.Equal(10, result.c0.Z);
            Assert.Equal(-6, result.c1.Z);
        }


        [Fact]
        public void Transpose_Int2x4Test()
        {
            // Create test matrix with known values
            Int2x4 source = new Int2x4(new Int2(2, -2), new Int2(6, -4), new Int2(10, -6), new Int2(14, -8));

            // Perform transpose
            Int4x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(2, result.c0.X);
            Assert.Equal(-2, result.c1.X);
            Assert.Equal(6, result.c0.Y);
            Assert.Equal(-4, result.c1.Y);
            Assert.Equal(10, result.c0.Z);
            Assert.Equal(-6, result.c1.Z);
            Assert.Equal(14, result.c0.W);
            Assert.Equal(-8, result.c1.W);
        }


        [Fact]
        public void Transpose_Int3x2Test()
        {
            // Create test matrix with known values
            Int3x2 source = new Int3x2(new Int3(2, -2, 6), new Int3(-4, 10, -6));

            // Perform transpose
            Int2x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(2, result.c0.X);
            Assert.Equal(-2, result.c1.X);
            Assert.Equal(-4, result.c0.Y);
            Assert.Equal(10, result.c1.Y);
        }


        [Fact]
        public void Transpose_Int3x4Test()
        {
            // Create test matrix with known values
            Int3x4 source = new Int3x4(new Int3(2, -2, 6), new Int3(-4, 10, -6), new Int3(14, -8, 18), new Int3(-10, 22, -12));

            // Perform transpose
            Int4x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(2, result.c0.X);
            Assert.Equal(-2, result.c1.X);
            Assert.Equal(6, result.c2.X);
            Assert.Equal(-4, result.c0.Y);
            Assert.Equal(10, result.c1.Y);
            Assert.Equal(-6, result.c2.Y);
            Assert.Equal(14, result.c0.Z);
            Assert.Equal(-8, result.c1.Z);
            Assert.Equal(18, result.c2.Z);
            Assert.Equal(-10, result.c0.W);
            Assert.Equal(22, result.c1.W);
            Assert.Equal(-12, result.c2.W);
        }


        [Fact]
        public void Transpose_Int4x2Test()
        {
            // Create test matrix with known values
            Int4x2 source = new Int4x2(new Int4(2, -2, 6, -4), new Int4(10, -6, 14, -8));

            // Perform transpose
            Int2x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(2, result.c0.X);
            Assert.Equal(-2, result.c1.X);
            Assert.Equal(10, result.c0.Y);
            Assert.Equal(-6, result.c1.Y);
        }


        [Fact]
        public void Transpose_Int4x3Test()
        {
            // Create test matrix with known values
            Int4x3 source = new Int4x3(new Int4(2, -2, 6, -4), new Int4(10, -6, 14, -8), new Int4(18, -10, 22, -12));

            // Perform transpose
            Int3x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal(2, result.c0.X);
            Assert.Equal(-2, result.c1.X);
            Assert.Equal(6, result.c2.X);
            Assert.Equal(10, result.c0.Y);
            Assert.Equal(-6, result.c1.Y);
            Assert.Equal(14, result.c2.Y);
            Assert.Equal(18, result.c0.Z);
            Assert.Equal(-10, result.c1.Z);
            Assert.Equal(22, result.c2.Z);
        }


        [Fact]
        public void Transpose_UInt2x2Test()
        {
            // Create test matrix with known values
            UInt2x2 source = new UInt2x2(new UInt2((uint)100, (uint)200), new UInt2((uint)300, (uint)400));

            // Perform transpose
            UInt2x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal((uint)100, result.c0.X);
            Assert.Equal((uint)200, result.c1.X);
            Assert.Equal((uint)300, result.c0.Y);
            Assert.Equal((uint)400, result.c1.Y);
        }


        [Fact]
        public void Transpose_UInt3x3Test()
        {
            // Create test matrix with known values
            UInt3x3 source = new UInt3x3(new UInt3((uint)100, (uint)200, (uint)300), new UInt3((uint)400, (uint)500, (uint)600), new UInt3((uint)700, (uint)800, (uint)900));

            // Perform transpose
            UInt3x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal((uint)100, result.c0.X);
            Assert.Equal((uint)200, result.c1.X);
            Assert.Equal((uint)300, result.c2.X);
            Assert.Equal((uint)400, result.c0.Y);
            Assert.Equal((uint)500, result.c1.Y);
            Assert.Equal((uint)600, result.c2.Y);
            Assert.Equal((uint)700, result.c0.Z);
            Assert.Equal((uint)800, result.c1.Z);
            Assert.Equal((uint)900, result.c2.Z);
        }


        [Fact]
        public void Transpose_UInt4x4Test()
        {
            // Create test matrix with known values
            UInt4x4 source = new UInt4x4(new UInt4((uint)100, (uint)200, (uint)300, (uint)400), new UInt4((uint)500, (uint)600, (uint)700, (uint)800), new UInt4((uint)900, (uint)1000, (uint)1100, (uint)1200), new UInt4((uint)1300, (uint)1400, (uint)1500, (uint)1600));

            // Perform transpose
            UInt4x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal((uint)100, result.c0.X);
            Assert.Equal((uint)200, result.c1.X);
            Assert.Equal((uint)300, result.c2.X);
            Assert.Equal((uint)400, result.c3.X);
            Assert.Equal((uint)500, result.c0.Y);
            Assert.Equal((uint)600, result.c1.Y);
            Assert.Equal((uint)700, result.c2.Y);
            Assert.Equal((uint)800, result.c3.Y);
            Assert.Equal((uint)900, result.c0.Z);
            Assert.Equal((uint)1000, result.c1.Z);
            Assert.Equal((uint)1100, result.c2.Z);
            Assert.Equal((uint)1200, result.c3.Z);
            Assert.Equal((uint)1300, result.c0.W);
            Assert.Equal((uint)1400, result.c1.W);
            Assert.Equal((uint)1500, result.c2.W);
            Assert.Equal((uint)1600, result.c3.W);
        }


        [Fact]
        public void Transpose_UInt2x3Test()
        {
            // Create test matrix with known values
            UInt2x3 source = new UInt2x3(new UInt2((uint)100, (uint)200), new UInt2((uint)300, (uint)400), new UInt2((uint)500, (uint)600));

            // Perform transpose
            UInt3x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal((uint)100, result.c0.X);
            Assert.Equal((uint)200, result.c1.X);
            Assert.Equal((uint)300, result.c0.Y);
            Assert.Equal((uint)400, result.c1.Y);
            Assert.Equal((uint)500, result.c0.Z);
            Assert.Equal((uint)600, result.c1.Z);
        }


        [Fact]
        public void Transpose_UInt2x4Test()
        {
            // Create test matrix with known values
            UInt2x4 source = new UInt2x4(new UInt2((uint)100, (uint)200), new UInt2((uint)300, (uint)400), new UInt2((uint)500, (uint)600), new UInt2((uint)700, (uint)800));

            // Perform transpose
            UInt4x2 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal((uint)100, result.c0.X);
            Assert.Equal((uint)200, result.c1.X);
            Assert.Equal((uint)300, result.c0.Y);
            Assert.Equal((uint)400, result.c1.Y);
            Assert.Equal((uint)500, result.c0.Z);
            Assert.Equal((uint)600, result.c1.Z);
            Assert.Equal((uint)700, result.c0.W);
            Assert.Equal((uint)800, result.c1.W);
        }


        [Fact]
        public void Transpose_UInt3x2Test()
        {
            // Create test matrix with known values
            UInt3x2 source = new UInt3x2(new UInt3((uint)100, (uint)200, (uint)300), new UInt3((uint)400, (uint)500, (uint)600));

            // Perform transpose
            UInt2x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal((uint)100, result.c0.X);
            Assert.Equal((uint)200, result.c1.X);
            Assert.Equal((uint)400, result.c0.Y);
            Assert.Equal((uint)500, result.c1.Y);
        }


        [Fact]
        public void Transpose_UInt3x4Test()
        {
            // Create test matrix with known values
            UInt3x4 source = new UInt3x4(new UInt3((uint)100, (uint)200, (uint)300), new UInt3((uint)400, (uint)500, (uint)600), new UInt3((uint)700, (uint)800, (uint)900), new UInt3((uint)1000, (uint)1100, (uint)1200));

            // Perform transpose
            UInt4x3 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal((uint)100, result.c0.X);
            Assert.Equal((uint)200, result.c1.X);
            Assert.Equal((uint)300, result.c2.X);
            Assert.Equal((uint)400, result.c0.Y);
            Assert.Equal((uint)500, result.c1.Y);
            Assert.Equal((uint)600, result.c2.Y);
            Assert.Equal((uint)700, result.c0.Z);
            Assert.Equal((uint)800, result.c1.Z);
            Assert.Equal((uint)900, result.c2.Z);
            Assert.Equal((uint)1000, result.c0.W);
            Assert.Equal((uint)1100, result.c1.W);
            Assert.Equal((uint)1200, result.c2.W);
        }


        [Fact]
        public void Transpose_UInt4x2Test()
        {
            // Create test matrix with known values
            UInt4x2 source = new UInt4x2(new UInt4((uint)100, (uint)200, (uint)300, (uint)400), new UInt4((uint)500, (uint)600, (uint)700, (uint)800));

            // Perform transpose
            UInt2x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal((uint)100, result.c0.X);
            Assert.Equal((uint)200, result.c1.X);
            Assert.Equal((uint)500, result.c0.Y);
            Assert.Equal((uint)600, result.c1.Y);
        }


        [Fact]
        public void Transpose_UInt4x3Test()
        {
            // Create test matrix with known values
            UInt4x3 source = new UInt4x3(new UInt4((uint)100, (uint)200, (uint)300, (uint)400), new UInt4((uint)500, (uint)600, (uint)700, (uint)800), new UInt4((uint)900, (uint)1000, (uint)1100, (uint)1200));

            // Perform transpose
            UInt3x4 result = Maths.Transpose(source);

            // Verify transpose: result[i,j] should equal source[j,i]
            Assert.Equal((uint)100, result.c0.X);
            Assert.Equal((uint)200, result.c1.X);
            Assert.Equal((uint)300, result.c2.X);
            Assert.Equal((uint)500, result.c0.Y);
            Assert.Equal((uint)600, result.c1.Y);
            Assert.Equal((uint)700, result.c2.Y);
            Assert.Equal((uint)900, result.c0.Z);
            Assert.Equal((uint)1000, result.c1.Z);
            Assert.Equal((uint)1100, result.c2.Z);
        }


    }
}
