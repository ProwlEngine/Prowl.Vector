//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-06-06 14:59:48
//

// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace Prowl.Vector.Geometry
{
    /// <summary>
    /// Represents a 3D viewing frustum defined by 6 planes.
    /// Planes are ordered: Near, Far, Left, Right, Top, Bottom.
    /// </summary>
    public struct FrustrumFloat : IEquatable<FrustrumFloat>, IFormattable
    {
        /// <summary>The 6 frustum planes: Near, Far, Left, Right, Top, Bottom.</summary>
        public PlaneFloat[] Planes;

        /// <summary>
        /// Initializes a new frustum with the specified planes.
        /// </summary>
        /// <param name="planes">Array of 6 planes in order: Near, Far, Left, Right, Top, Bottom.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public FrustrumFloat(PlaneFloat[] planes)
        {
            if (planes == null || planes.Length != 6)
                throw new ArgumentException("Frustum requires exactly 6 planes", nameof(planes));
            
            Planes = new PlaneFloat[6];
            Array.Copy(planes, Planes, 6);
        }

        /// <summary>
        /// Initializes a new frustum with individual planes.
        /// </summary>
        /// <param name="near">Near plane.</param>
        /// <param name="far">Far plane.</param>
        /// <param name="left">Left plane.</param>
        /// <param name="right">Right plane.</param>
        /// <param name="top">Top plane.</param>
        /// <param name="bottom">Bottom plane.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public FrustrumFloat(PlaneFloat near, PlaneFloat far, PlaneFloat left, 
                             PlaneFloat right, PlaneFloat top, PlaneFloat bottom)
        {
            Planes = new PlaneFloat[6] { near, far, left, right, top, bottom };
        }

        /// <summary>Gets or sets the near plane.</summary>
        public PlaneFloat Near
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Planes[0];
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Planes[0] = value;
        }

        /// <summary>Gets or sets the far plane.</summary>
        public PlaneFloat Far
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Planes[1];
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Planes[1] = value;
        }

        /// <summary>Gets or sets the left plane.</summary>
        public PlaneFloat Left
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Planes[2];
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Planes[2] = value;
        }

        /// <summary>Gets or sets the right plane.</summary>
        public PlaneFloat Right
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Planes[3];
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Planes[3] = value;
        }

        /// <summary>Gets or sets the top plane.</summary>
        public PlaneFloat Top
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Planes[4];
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Planes[4] = value;
        }

        /// <summary>Gets or sets the bottom plane.</summary>
        public PlaneFloat Bottom
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Planes[5];
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => Planes[5] = value;
        }

        /// <summary>
        /// Creates a frustum from a view-projection matrix.
        /// Extracts the 6 frustum planes from the combined matrix.
        /// </summary>
        /// <param name="viewProjectionMatrix">The combined view-projection matrix.</param>
        /// <returns>The extracted frustum.</returns>
        public static FrustrumFloat FromMatrix(Float4x4 viewProjectionMatrix)
        {
            var planes = new PlaneFloat[6];
            
            // Extract planes from matrix (Gribb/Hartmann method)
            // Left plane
            Float3 leftNormal = new Float3(
                viewProjectionMatrix.c3.X + viewProjectionMatrix.c0.X,
                viewProjectionMatrix.c3.Y + viewProjectionMatrix.c0.Y,
                viewProjectionMatrix.c3.Z + viewProjectionMatrix.c0.Z
            );
            float leftD = viewProjectionMatrix.c3.W + viewProjectionMatrix.c0.W;
            planes[2] = new PlaneFloat(leftNormal, leftD);

            // Right plane
            Float3 rightNormal = new Float3(
                viewProjectionMatrix.c3.X - viewProjectionMatrix.c0.X,
                viewProjectionMatrix.c3.Y - viewProjectionMatrix.c0.Y,
                viewProjectionMatrix.c3.Z - viewProjectionMatrix.c0.Z
            );
            float rightD = viewProjectionMatrix.c3.W - viewProjectionMatrix.c0.W;
            planes[3] = new PlaneFloat(rightNormal, rightD);

            // Bottom plane
            Float3 bottomNormal = new Float3(
                viewProjectionMatrix.c3.X + viewProjectionMatrix.c1.X,
                viewProjectionMatrix.c3.Y + viewProjectionMatrix.c1.Y,
                viewProjectionMatrix.c3.Z + viewProjectionMatrix.c1.Z
            );
            float bottomD = viewProjectionMatrix.c3.W + viewProjectionMatrix.c1.W;
            planes[5] = new PlaneFloat(bottomNormal, bottomD);

            // Top plane
            Float3 topNormal = new Float3(
                viewProjectionMatrix.c3.X - viewProjectionMatrix.c1.X,
                viewProjectionMatrix.c3.Y - viewProjectionMatrix.c1.Y,
                viewProjectionMatrix.c3.Z - viewProjectionMatrix.c1.Z
            );
            float topD = viewProjectionMatrix.c3.W - viewProjectionMatrix.c1.W;
            planes[4] = new PlaneFloat(topNormal, topD);

            // Near plane
            Float3 nearNormal = new Float3(
                viewProjectionMatrix.c2.X,
                viewProjectionMatrix.c2.Y,
                viewProjectionMatrix.c2.Z
            );
            float nearD = viewProjectionMatrix.c2.W;
            planes[0] = new PlaneFloat(nearNormal, nearD);

            // Far plane
            Float3 farNormal = new Float3(
                viewProjectionMatrix.c3.X - viewProjectionMatrix.c2.X,
                viewProjectionMatrix.c3.Y - viewProjectionMatrix.c2.Y,
                viewProjectionMatrix.c3.Z - viewProjectionMatrix.c2.Z
            );
            float farD = viewProjectionMatrix.c3.W - viewProjectionMatrix.c2.W;
            planes[1] = new PlaneFloat(farNormal, farD);

            return new FrustrumFloat(planes);
        }

        /// <summary>
        /// Creates a frustum from separate view and projection matrices.
        /// </summary>
        /// <param name="viewMatrix">The view matrix.</param>
        /// <param name="projectionMatrix">The projection matrix.</param>
        /// <returns>The frustum.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static FrustrumFloat FromMatrices(Float4x4 viewMatrix, Float4x4 projectionMatrix)
        {
            Float4x4 viewProjection = Maths.Mul(projectionMatrix, viewMatrix);
            return FromMatrix(viewProjection);
        }

        /// <summary>
        /// Checks if a point is contained within the frustum.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>True if the point is inside the frustum.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Float3 point)
        {
            Float3[] normals = new Float3[6];
            float[] ds = new float[6];
            
            for (int i = 0; i < 6; i++)
            {
                normals[i] = Planes[i].Normal;
                ds[i] = Planes[i].D;
            }
            
            return IntersectionFloat.FrustumContainsPoint(normals, ds, point);
        }

        /// <summary>
        /// Checks if a sphere intersects with the frustum.
        /// </summary>
        /// <param name="sphere">The sphere to test.</param>
        /// <returns>True if the sphere intersects the frustum.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(SphereFloat sphere)
        {
            Float3[] normals = new Float3[6];
            float[] ds = new float[6];
            
            for (int i = 0; i < 6; i++)
            {
                normals[i] = Planes[i].Normal;
                ds[i] = Planes[i].D;
            }
            
            return IntersectionFloat.FrustumIntersectsSphere(normals, ds, sphere.Center, sphere.Radius);
        }

        /// <summary>
        /// Checks if an AABB intersects with the frustum.
        /// </summary>
        /// <param name="aabb">The AABB to test.</param>
        /// <returns>True if the AABB intersects the frustum.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(AABBFloat aabb)
        {
            Float3[] normals = new Float3[6];
            float[] ds = new float[6];
            
            for (int i = 0; i < 6; i++)
            {
                normals[i] = Planes[i].Normal;
                ds[i] = Planes[i].D;
            }
            
            return IntersectionFloat.FrustumIntersectsAABB(normals, ds, aabb.Min, aabb.Max);
        }

        /// <summary>
        /// Gets the 8 corner points of the frustum.
        /// </summary>
        /// <returns>Array of 8 corner points.</returns>
        public Float3[] GetCorners()
        {
            var corners = new Float3[8];
            
            // Find intersections of 3 planes to get corners
            // This is a simplified approach - a full implementation would solve
            // the system of linear equations for each corner
            
            // For now, we'll use a approximate method based on typical frustum geometry
            // In a full implementation, you'd solve plane intersection equations
            
            // Near plane corners (assuming standard camera setup)
            // This is a placeholder - real implementation needs plane intersection solving
            Float3 center = Float3.Zero;
            float size = 1f;
            
            corners[0] = new Float3(-size, -size, -size); // Near bottom left
            corners[1] = new Float3(size, -size, -size);  // Near bottom right
            corners[2] = new Float3(-size, size, -size);  // Near top left
            corners[3] = new Float3(size, size, -size);   // Near top right
            corners[4] = new Float3(-size * 2f, -size * 2f, size);  // Far bottom left
            corners[5] = new Float3(size * 2f, -size * 2f, size);   // Far bottom right
            corners[6] = new Float3(-size * 2f, size * 2f, size);   // Far top left
            corners[7] = new Float3(size * 2f, size * 2f, size);    // Far top right
            
            return corners;
        }

        /// <summary>
        /// Transforms the frustum by a matrix.
        /// </summary>
        /// <param name="matrix">The transformation matrix.</param>
        /// <returns>The transformed frustum.</returns>
        public FrustrumFloat Transform(Float4x4 matrix)
        {
            var transformedPlanes = new PlaneFloat[6];
            
            // Transform each plane by the inverse transpose of the matrix
            Float4x4 invTranspose = Maths.Transpose(Maths.Inverse(matrix));
            
            for (int i = 0; i < 6; i++)
            {
                Float4 planeVec = new Float4(Planes[i].Normal, Planes[i].D);
                Float4 transformedPlaneVec = Maths.Mul(invTranspose, planeVec);
                transformedPlanes[i] = new PlaneFloat(transformedPlaneVec.XYZ, transformedPlaneVec.W);
            }
            
            return new FrustrumFloat(transformedPlanes);
        }

        /// <summary>
        /// Normalizes all frustum planes to ensure consistent distance calculations.
        /// </summary>
        public void Normalize()
        {
            for (int i = 0; i < 6; i++)
            {
                float length = Maths.Length(Planes[i].Normal);
                if (length > float.Epsilon)
                {
                    Planes[i] = new PlaneFloat(
                        Planes[i].Normal / length,
                        Planes[i].D / length
                    );
                }
            }
        }

        /// <summary>
        /// Returns a normalized version of this frustum.
        /// </summary>
        /// <returns>The normalized frustum.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public FrustrumFloat Normalized()
        {
            var result = this;
            result.Normalize();
            return result;
        }

        /// <summary>
        /// Classifies a point relative to the frustum.
        /// </summary>
        /// <param name="point">The point to classify.</param>
        /// <returns>Number of planes the point is behind (0 = inside, 1-6 = partially/fully outside).</returns>
        public int ClassifyPoint(Float3 point)
        {
            int planesOutside = 0;
            for (int i = 0; i < 6; i++)
            {
                if (Planes[i].GetSignedDistanceToPoint(point) < -float.Epsilon)
                {
                    planesOutside++;
                }
            }
            return planesOutside;
        }
        
        /// <summary>
        /// Classifies a sphere relative to the frustum.
        /// </summary>
        /// <param name="sphere">The sphere to classify.</param>
        /// <returns>Number of planes the sphere is completely behind.</returns>
        public int ClassifySphere(SphereFloat sphere)
        {
            int planesOutside = 0;
            for (int i = 0; i < 6; i++)
            {
                float distance = Planes[i].GetSignedDistanceToPoint(sphere.Center);
                if (distance < -sphere.Radius - float.Epsilon)
                {
                    planesOutside++;
                }
            }
            return planesOutside;
        }
        
        /// <summary>
        /// Classifies an AABB relative to the frustum.
        /// </summary>
        /// <param name="aabb">The AABB to classify.</param>
        /// <returns>Number of planes the AABB is completely behind.</returns>
        public int ClassifyAABB(AABBFloat aabb)
        {
            int planesOutside = 0;
            for (int i = 0; i < 6; i++)
            {
                var classification = IntersectionFloat.ClassifyAABBToPlane(aabb.Min, aabb.Max, Planes[i].Normal, Planes[i].D);
                if (classification == IntersectionFloat.PlaneIntersectionType.Back)
                {
                    planesOutside++;
                }
            }
            return planesOutside;
        }
        
        /// <summary>
        /// Gets the volume of the frustum (approximate).
        /// </summary>
        public float Volume
        {
            get
            {
                // This is a simplified calculation
                // For an accurate volume, you'd need to compute the convex hull volume
                // of the 8 corner points, which is more complex
                var corners = GetCorners();
                
                // Approximate as a truncated pyramid
                // This is a placeholder - real implementation would be more sophisticated
                return 1f; // Placeholder
            }
        }
        
        /// <summary>
        /// Checks if the frustum is valid (all planes properly oriented).
        /// </summary>
        /// <returns>True if the frustum is valid.</returns>
        public bool IsValid()
        {
            if (Planes == null || Planes.Length != 6)
                return false;
                
            // Check that all plane normals have reasonable length
            for (int i = 0; i < 6; i++)
            {
                if (Maths.LengthSquared(Planes[i].Normal) < float.Epsilon * float.Epsilon)
                    return false;
            }
            
            return true;
        }
        
        /// <summary>
        /// Creates a frustum from camera parameters.
        /// </summary>
        /// <param name="position">Camera position.</param>
        /// <param name="forward">Camera forward direction (normalized).</param>
        /// <param name="up">Camera up direction (normalized).</param>
        /// <param name="fovY">Vertical field of view in radians.</param>
        /// <param name="aspect">Aspect ratio (width/height).</param>
        /// <param name="nearDist">Near plane distance.</param>
        /// <param name="farDist">Far plane distance.</param>
        /// <returns>The camera frustum.</returns>
        public static FrustrumFloat FromCamera(Float3 position, Float3 forward, Float3 up, 
                                               float fovY, float aspect, float nearDist, float farDist)
        {
            Float3 right = Maths.Normalize(Maths.Cross(forward, up));
            Float3 actualUp = Maths.Cross(right, forward);
            
            float halfFovY = fovY / 2f;
            float tanHalfFovY = Maths.Tan(halfFovY);
            float tanHalfFovX = tanHalfFovY * aspect;
            
            // Calculate plane normals (pointing inward)
            Float3 nearCenter = position + forward * nearDist;
            Float3 farCenter = position + forward * farDist;
            
            // Near and far planes
            PlaneFloat near = new PlaneFloat(forward, Maths.Dot(forward, nearCenter));
            PlaneFloat far = new PlaneFloat(-forward, Maths.Dot(-forward, farCenter));
            
            // Side planes
            Float3 leftNormal = Maths.Normalize(Maths.Cross(actualUp, forward + right * tanHalfFovX));
            Float3 rightNormal = Maths.Normalize(Maths.Cross(forward - right * tanHalfFovX, actualUp));
            Float3 topNormal = Maths.Normalize(Maths.Cross(right, forward + actualUp * tanHalfFovY));
            Float3 bottomNormal = Maths.Normalize(Maths.Cross(forward - actualUp * tanHalfFovY, right));
            
            PlaneFloat left = new PlaneFloat(leftNormal, Maths.Dot(leftNormal, position));
            PlaneFloat right = new PlaneFloat(rightNormal, Maths.Dot(rightNormal, position));
            PlaneFloat top = new PlaneFloat(topNormal, Maths.Dot(topNormal, position));
            PlaneFloat bottom = new PlaneFloat(bottomNormal, Maths.Dot(bottomNormal, position));
            
            return new FrustrumFloat(near, far, left, right, top, bottom);
        }
        
        /// <summary>
        /// Creates an orthographic frustum.
        /// </summary>
        /// <param name="left">Left boundary.</param>
        /// <param name="right">Right boundary.</param>
        /// <param name="bottom">Bottom boundary.</param>
        /// <param name="top">Top boundary.</param>
        /// <param name="nearDist">Near plane distance.</param>
        /// <param name="farDist">Far plane distance.</param>
        /// <returns>The orthographic frustum.</returns>
        public static FrustrumFloat CreateOrthographic(float left, float right, float bottom, 
                                                        float top, float nearDist, float farDist)
        {
            var planes = new PlaneFloat[6];
            
            // Near and far planes (assuming Z forward)
            planes[0] = new PlaneFloat(new Float3(0f, 0f, 1f), nearDist);
            planes[1] = new PlaneFloat(new Float3(0f, 0f, -1f), -farDist);
            
            // Side planes
            planes[2] = new PlaneFloat(new Float3(1f, 0f, 0f), -left);    // Left
            planes[3] = new PlaneFloat(new Float3(-1f, 0f, 0f), right);   // Right
            planes[4] = new PlaneFloat(new Float3(0f, -1f, 0f), top);     // Top
            planes[5] = new PlaneFloat(new Float3(0f, 1f, 0f), -bottom);  // Bottom
            
            return new FrustrumFloat(planes);
        }
        
        /// <summary>
        /// Expands the frustum by a given amount along all plane normals.
        /// </summary>
        /// <param name="amount">Amount to expand by.</param>
        public void Expand(float amount)
        {
            for (int i = 0; i < 6; i++)
            {
                Planes[i] = new PlaneFloat(Planes[i].Normal, Planes[i].D - amount);
            }
        }
        
        /// <summary>
        /// Returns an expanded version of this frustum.
        /// </summary>
        /// <param name="amount">Amount to expand by.</param>
        /// <returns>The expanded frustum.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public FrustrumFloat Expanded(float amount)
        {
            var result = this;
            result.Expand(amount);
            return result;
        }
        
        // --- IEquatable & IFormattable Implementation ---
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(FrustrumFloat other)
        {
            if (Planes == null && other.Planes == null) return true;
            if (Planes == null || other.Planes == null) return false;
            if (Planes.Length != other.Planes.Length) return false;
            
            for (int i = 0; i < Planes.Length; i++)
            {
                if (!Planes[i].Equals(other.Planes[i]))
                    return false;
            }
            return true;
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj) => obj is FrustrumFloat other && Equals(other);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode()
        {
            if (Planes == null) return 0;
            
            var hash = new HashCode();
            for (int i = 0; i < Planes.Length; i++)
            {
                hash.Add(Planes[i]);
            }
            return hash.ToHashCode();
        }
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string ToString() => ToString(null, CultureInfo.CurrentCulture);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToString(string? format, IFormatProvider? formatProvider = null)
        {
            if (Planes == null)
                return "FrustrumFloat(null)";
                
            return string.Format(formatProvider, 
                "FrustrumFloat(Near: {0}, Far: {1}, Left: {2}, Right: {3}, Top: {4}, Bottom: {5})",
                Planes[0].ToString(format, formatProvider),
                Planes[1].ToString(format, formatProvider),
                Planes[2].ToString(format, formatProvider),
                Planes[3].ToString(format, formatProvider),
                Planes[4].ToString(format, formatProvider),
                Planes[5].ToString(format, formatProvider));
        }
        
        public static bool operator ==(FrustrumFloat left, FrustrumFloat right) => left.Equals(right);
        public static bool operator !=(FrustrumFloat left, FrustrumFloat right) => !left.Equals(right);
    }
}
