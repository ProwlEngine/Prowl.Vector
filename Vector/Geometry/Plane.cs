//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-09-14 17:54:37
//

// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace Prowl.Vector.Geometry
{
    /// <summary>
    /// Represents a 3D plane defined by a normal vector and distance from origin.
    /// The plane equation is: Normal � Point = D
    /// </summary>
    public struct Plane : IEquatable<Plane>, IFormattable
    {
        /// <summary>The normalized normal vector of the plane.</summary>
        public Float3 Normal;

        /// <summary>The distance from the origin to the plane along the normal.</summary>
        public float D;

        /// <summary>
        /// Initializes a new plane from a normal vector and distance.
        /// The normal will be normalized.
        /// </summary>
        /// <param name="normal">The normal vector (will be normalized).</param>
        /// <param name="d">The distance from origin.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Plane(Float3 normal, float d)
        {
            Normal = Maths.Normalize(normal);
            D = d;
        }

        /// <summary>
        /// Initializes a new plane from three points.
        /// Points should be in counter-clockwise order for outward-facing normal.
        /// </summary>
        /// <param name="point1">First point on the plane.</param>
        /// <param name="point2">Second point on the plane.</param>
        /// <param name="point3">Third point on the plane.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Plane(Float3 point1, Float3 point2, Float3 point3)
        {
            Float3 edge1 = point2 - point1;
            Float3 edge2 = point3 - point1;
            Normal = Maths.Normalize(Maths.Cross(edge1, edge2));
            D = Maths.Dot(Normal, point1);
        }

        /// <summary>
        /// Initializes a new plane from a normal vector and a point on the plane.
        /// </summary>
        /// <param name="normal">The normal vector (will be normalized).</param>
        /// <param name="pointOnPlane">A point that lies on the plane.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Plane FromNormalAndPoint(Float3 normal, Float3 pointOnPlane)
        {
            Float3 normalizedNormal = Maths.Normalize(normal);
            return new Plane(normalizedNormal, Maths.Dot(normalizedNormal, pointOnPlane));
        }

        /// <summary>
        /// Gets the signed distance from a point to this plane.
        /// Positive if the point is on the side of the normal, negative otherwise.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>The signed distance.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float GetSignedDistanceToPoint(Float3 point)
        {
            return Maths.Dot(Normal, point) - D;
        }

        /// <summary>
        /// Gets the absolute distance from a point to this plane.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>The absolute distance.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public float GetDistanceToPoint(Float3 point)
        {
            return Maths.Abs(GetSignedDistanceToPoint(point));
        }

        /// <summary>
        /// Projects a point onto this plane.
        /// </summary>
        /// <param name="point">The point to project.</param>
        /// <returns>The closest point on the plane.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Float3 ClosestPointOnPlane(Float3 point)
        {
            float distance = GetSignedDistanceToPoint(point);
            return point - Normal * distance;
        }

        /// <summary>
        /// Determines which side of the plane a point is on.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>True if the point is on the positive side (normal side) of the plane.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool GetSide(Float3 point)
        {
            return GetSignedDistanceToPoint(point) > 0f;
        }

        /// <summary>
        /// Checks if two points are on the same side of the plane.
        /// </summary>
        /// <param name="point1">First point.</param>
        /// <param name="point2">Second point.</param>
        /// <returns>True if both points are on the same side.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool SameSide(Float3 point1, Float3 point2)
        {
            float d1 = GetSignedDistanceToPoint(point1);
            float d2 = GetSignedDistanceToPoint(point2);
            return (d1 > 0f) == (d2 > 0f);
        }

        /// <summary>
        /// Flips the plane to face the opposite direction.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Flip()
        {
            Normal = -Normal;
            D = -D;
        }

        /// <summary>
        /// Returns a flipped version of this plane.
        /// </summary>
        /// <returns>A plane facing the opposite direction.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Plane Flipped()
        {
            return new Plane(-Normal, -D);
        }

        /// <summary>
        /// Translates the plane by a given offset.
        /// </summary>
        /// <param name="translation">The translation vector.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Translate(Float3 translation)
        {
            D += Maths.Dot(Normal, translation);
        }

        /// <summary>
        /// Returns a translated version of this plane.
        /// </summary>
        /// <param name="translation">The translation vector.</param>
        /// <returns>The translated plane.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Plane Translated(Float3 translation)
        {
            return new Plane(Normal, D + Maths.Dot(Normal, translation));
        }

        // --- IEquatable & IFormattable Implementation ---
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Plane other) => Normal.Equals(other.Normal) && D.Equals(other.D);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj) => obj is Plane other && Equals(other);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode() => HashCode.Combine(Normal, D);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string ToString() => ToString(null, CultureInfo.CurrentCulture);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToString(string? format, IFormatProvider? formatProvider = null)
        {
            return string.Format(formatProvider, "Plane(Normal: {0}, D: {1})", 
                Normal.ToString(format, formatProvider), D.ToString(format, formatProvider));
        }

        public static bool operator ==(Plane left, Plane right) => left.Equals(right);
        public static bool operator !=(Plane left, Plane right) => !left.Equals(right);
    }
}
