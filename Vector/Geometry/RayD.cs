//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-10-10 14:15:04
//

// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace Prowl.Vector.Geometry
{
    /// <summary>
    /// Represents a 3D ray with an origin and a direction.
    /// </summary>
    public struct RayD : IEquatable<RayD>, IFormattable
    {
        /// <summary>The origin point of the ray.</summary>
        public Double3 Origin;

        /// <summary>The normalized direction vector of the ray.</summary>
        public Double3 Direction;

        /// <summary>
        /// Initializes a new instance of the RayD struct.
        /// The direction vector will be normalized.
        /// </summary>
        /// <param name="origin">The origin point of the ray.</param>
        /// <param name="direction">The direction vector of the ray (will be normalized).</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public RayD(Double3 origin, Double3 direction)
        {
            Origin = origin;
            Direction = Maths.Normalize(direction);
        }

        /// <summary>
        /// Gets a point along the ray at the specified distance from the origin.
        /// </summary>
        /// <param name="distance">The distance along the ray.</param>
        /// <returns>A point on the ray.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 GetPoint(double distance)
        {
            return Origin + Direction * distance;
        }

        #region --- Intersection Methods ---

        /// <summary>
        /// Tests intersection with a plane.
        /// </summary>
        /// <param name="plane">The plane to test against.</param>
        /// <param name="distance">The distance along the ray to the intersection point.</param>
        /// <returns>True if the ray intersects the plane in the forward direction.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(PlaneD plane, out double distance)
        {
            return IntersectionD.RayPlane(Origin, Direction, plane.Normal, plane.D, out distance);
        }

        /// <summary>
        /// Tests intersection with a triangle.
        /// </summary>
        /// <param name="triangle">The triangle to test against.</param>
        /// <param name="distance">The distance along the ray to the intersection point.</param>
        /// <param name="u">Barycentric coordinate u.</param>
        /// <param name="v">Barycentric coordinate v.</param>
        /// <returns>True if the ray intersects the triangle.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(TriangleD triangle, out double distance, out double u, out double v)
        {
            return IntersectionD.RayTriangle(Origin, Direction, triangle.V0, triangle.V1, triangle.V2, out distance, out u, out v);
        }

        /// <summary>
        /// Tests intersection with an axis-aligned bounding box.
        /// </summary>
        /// <param name="aabb">The AABB to test against.</param>
        /// <param name="tMin">The entry distance.</param>
        /// <param name="tMax">The exit distance.</param>
        /// <returns>True if the ray intersects the AABB.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(AABBD aabb, out double tMin, out double tMax)
        {
            return IntersectionD.RayAABB(Origin, Direction, aabb.Min, aabb.Max, out tMin, out tMax);
        }

        /// <summary>
        /// Tests intersection with a sphere.
        /// </summary>
        /// <param name="sphere">The sphere to test against.</param>
        /// <param name="t0">The first intersection distance.</param>
        /// <param name="t1">The second intersection distance.</param>
        /// <returns>True if the ray intersects the sphere.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(SphereD sphere, out double t0, out double t1)
        {
            return IntersectionD.RaySphere(Origin, Direction, sphere.Center, sphere.Radius, out t0, out t1);
        }

        #endregion

        #region --- Utility Methods ---

        /// <summary>
        /// Creates a ray from a 2D screen position, camera matrices, and viewport dimensions.
        /// This ray can be used for picking objects in the 3D world.
        /// Assumes DirectX-style projection (depth 0-1).
        /// </summary>
        /// <param name="screenPosition">The 2D screen coordinates (e.g., mouse position). Y is typically 0 at top.</param>
        /// <param name="viewMatrix">The camera's view matrix.</param>
        /// <param name="projectionMatrix">The camera's projection matrix (DirectX-style, depth 0-1).</param>
        /// <param name="viewportWidth">The width of the viewport in pixels.</param>
        /// <param name="viewportHeight">The height of the viewport in pixels.</param>
        /// <returns>A Ray originating from the near plane and pointing into the scene.</returns>
        public static RayD ScreenPointToRay(Double2 screenPosition, Double4x4 viewMatrix, Double4x4 projectionMatrix, double viewportWidth, double viewportHeight)
        {
            // 1. Convert screen coordinates to Normalized Device Coordinates (NDC)
            double ndcX = (2.0 * screenPosition.X) / viewportWidth - 1.0;
            double ndcY = 1.0 - (2.0 * screenPosition.Y) / viewportHeight; // Y is often flipped screen -> NDC

            // 2. Define points in NDC space on the near and far clip planes (DirectX-style Z)
            Double4 nearPointNDC = new Double4(ndcX, ndcY, 0.0, 1.0); // Point on the near plane (Z=0 for DX)
            Double4 farPointNDC = new Double4(ndcX, ndcY, 1.0, 1.0); // Point on the far plane (Z=1 for DX)

            // 3. Calculate the inverse of the combined view-projection matrix
            Double4x4 viewProjectionMatrix = Maths.Mul(projectionMatrix, viewMatrix);
            Double4x4 inverseViewProjectionMatrix;
            try
            {
                inverseViewProjectionMatrix = viewProjectionMatrix.Invert();
            }
            catch (ArgumentException ex)
            {
                System.Diagnostics.Debug.WriteLine("ScreenPointToRay Error: View-Projection matrix is singular. " + ex.Message);
                return new RayD(Double3.Zero, new Double3(0.0, 0.0, -1.0)); // Fallback ray
            }

            // 4. Transform NDC points to world space
            Double4 nearPointWorld = Maths.Mul(inverseViewProjectionMatrix, nearPointNDC);
            Double4 farPointWorld = Maths.Mul(inverseViewProjectionMatrix, farPointNDC);

            // 5. Perform perspective division (divide by W component)
            const double wEpsilon = double.Epsilon * 1000; // Local epsilon for W component check
            if (Maths.Abs(nearPointWorld.W) > wEpsilon) nearPointWorld /= nearPointWorld.W; else nearPointWorld.W = 1.0; // Avoid division by zero/small W
            if (Maths.Abs(farPointWorld.W) > wEpsilon) farPointWorld /= farPointWorld.W; else farPointWorld.W = 1.0; // Avoid division by zero/small W

            // 6. Create the ray
            Double3 rayOrigin = new Double3(nearPointWorld.X, nearPointWorld.Y, nearPointWorld.Z);
            Double3 rayDirectionTarget = new Double3(farPointWorld.X, farPointWorld.Y, farPointWorld.Z);
            Double3 rayDirection = rayDirectionTarget - rayOrigin;

            // Direction should be normalized by the Ray constructor
            return new RayD(rayOrigin, rayDirection);
        }

        /// <summary>
        /// Creates a ray from a 2D screen position using camera properties.
        /// The ray originates from the camera's world position.
        /// Assumes DirectX-style projection (depth 0-1).
        /// </summary>
        /// <param name="screenPosition">The 2D screen coordinates (Y typically 0 at top).</param>
        /// <param name="cameraWorldPosition">The world position of the camera.</param>
        /// <param name="viewMatrix">The camera's view matrix.</param>
        /// <param name="projectionMatrix">The camera's projection matrix (DirectX-style, depth 0-1).</param>
        /// <param name="viewportWidth">The width of the viewport.</param>
        /// <param name="viewportHeight">The height of the viewport.</param>
        /// <returns>A Ray starting from the camera's world position.</returns>
        public static RayD ScreenPointToRayFromCamera(Double2 screenPosition, Double3 cameraWorldPosition, Double4x4 viewMatrix, Double4x4 projectionMatrix, double viewportWidth, double viewportHeight)
        {
            double ndcX = (2.0 * screenPosition.X) / viewportWidth - 1.0;
            double ndcY = 1.0 - (2.0 * screenPosition.Y) / viewportHeight; // Y is often flipped

            // For direction, unprojecting a point on the far plane is standard.
            // Using Z=1 for far plane in DirectX-style NDC.
            Double4 farPointNDC = new Double4(ndcX, ndcY, 1.0, 1.0);

            Double4x4 viewProjectionMatrix = Maths.Mul(projectionMatrix, viewMatrix);
            Double4x4 inverseViewProjectionMatrix;
            try
            {
                inverseViewProjectionMatrix = viewProjectionMatrix.Invert();
            }
            catch (ArgumentException ex)
            {
                System.Diagnostics.Debug.WriteLine("ScreenPointToRayFromCamera Error: View-Projection matrix is singular. " + ex.Message);
                return new RayD(cameraWorldPosition, new Double3(0.0, 0.0, -1.0)); // Fallback ray
            }

            Double4 farPointWorldH = Maths.Mul(inverseViewProjectionMatrix, farPointNDC);

            const double wEpsilon = double.Epsilon * 1000;
            if (Maths.Abs(farPointWorldH.W) > wEpsilon) farPointWorldH /= farPointWorldH.W; else farPointWorldH.W = 1.0;

            Double3 worldPointOnFarPlane = new Double3(farPointWorldH.X, farPointWorldH.Y, farPointWorldH.Z);
            Double3 direction = worldPointOnFarPlane - cameraWorldPosition;

            // Direction will be normalized by the Ray constructor
            return new RayD(cameraWorldPosition, direction);
        }

        #endregion

        // --- IEquatable & IFormattable Implementation ---
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(RayD other) => Origin.Equals(other.Origin) && Direction.Equals(other.Direction);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj) => obj is RayD other && Equals(other);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode() => HashCode.Combine(Origin, Direction);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string ToString() => ToString(null, CultureInfo.CurrentCulture);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToString(string? format, IFormatProvider? formatProvider = null)
        {
            return string.Format(formatProvider, "RayD(Origin: {0}, Direction: {1})", Origin.ToString(format, formatProvider), Direction.ToString(format, formatProvider));
        }

        public static bool operator ==(RayD left, RayD right) => left.Equals(right);
        public static bool operator !=(RayD left, RayD right) => !left.Equals(right);
    }
}
