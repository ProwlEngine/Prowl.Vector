//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-06-06 14:59:48
//

// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace Prowl.Vector.Geometry
{
    /// <summary>
    /// Represents a 3D sphere defined by a center point and radius.
    /// </summary>
    public struct SphereDouble : IEquatable<SphereDouble>, IFormattable
    {
        /// <summary>The center point of the sphere.</summary>
        public Double3 Center;

        /// <summary>The radius of the sphere.</summary>
        public double Radius;

        /// <summary>
        /// Initializes a new sphere with the specified center and radius.
        /// </summary>
        /// <param name="center">The center point of the sphere.</param>
        /// <param name="radius">The radius of the sphere.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SphereDouble(Double3 center, double radius)
        {
            Center = center;
            Radius = Maths.Max(radius, 0.0); // Ensure non-negative radius
        }

        /// <summary>
        /// Initializes a new sphere with center components and radius.
        /// </summary>
        /// <param name="x">X coordinate of the center.</param>
        /// <param name="y">Y coordinate of the center.</param>
        /// <param name="z">Z coordinate of the center.</param>
        /// <param name="radius">The radius of the sphere.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SphereDouble(double x, double y, double z, double radius)
        {
            Center = new Double3(x, y, z);
            Radius = Maths.Max(radius, 0.0);
        }

        /// <summary>
        /// Gets the diameter of the sphere.
        /// </summary>
        public double Diameter
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => Radius * 2.0;
        }

        /// <summary>
        /// Gets the surface area of the sphere (4πr²).
        /// </summary>
        public double SurfaceArea
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => 4 * (double)Maths.PI * Radius * Radius;
        }

        /// <summary>
        /// Gets the volume of the sphere (4/3πr³).
        /// </summary>
        public double Volume
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (4 / 3) * (double)Maths.PI * Radius * Radius * Radius;
        }

        /// <summary>
        /// Gets the circumference of the sphere (2πr).
        /// </summary>
        public double Circumference
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => 2.0 * (double)Maths.PI * Radius;
        }

        /// <summary>
        /// Checks if this sphere contains a point.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>True if the point is inside or on the sphere surface.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(Double3 point)
        {
            return Maths.LengthSquared(point - Center) <= Radius * Radius + double.Epsilon;
        }

        /// <summary>
        /// Checks if this sphere completely contains another sphere.
        /// </summary>
        /// <param name="other">The other sphere to test.</param>
        /// <returns>True if the other sphere is completely inside this sphere.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Contains(SphereDouble other)
        {
            double distance = Maths.Length(other.Center - Center);
            return distance + other.Radius <= Radius + double.Epsilon;
        }

        /// <summary>
        /// Checks if this sphere intersects with another sphere.
        /// </summary>
        /// <param name="other">The other sphere to test.</param>
        /// <returns>True if the spheres intersect or touch.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(SphereDouble other)
        {
            return IntersectionDouble.SphereSphereOverlap(Center, Radius, other.Center, other.Radius);
        }

        /// <summary>
        /// Checks if this sphere intersects with an AABB.
        /// </summary>
        /// <param name="aabb">The AABB to test.</param>
        /// <returns>True if the sphere intersects the AABB.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Intersects(AABBDouble aabb)
        {
            return IntersectionDouble.SphereAABBOverlap(Center, Radius, aabb.Min, aabb.Max);
        }

        /// <summary>
        /// Gets the signed distance from a point to the sphere surface.
        /// Positive if outside, negative if inside, zero if on the surface.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>The signed distance.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double GetSignedDistanceToPoint(Double3 point)
        {
            return Maths.Length(point - Center) - Radius;
        }

        /// <summary>
        /// Gets the absolute distance from a point to the sphere surface.
        /// </summary>
        /// <param name="point">The point to test.</param>
        /// <returns>The absolute distance.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public double GetDistanceToPoint(Double3 point)
        {
            return Maths.Abs(GetSignedDistanceToPoint(point));
        }

        /// <summary>
        /// Gets the closest point on the sphere surface to a given point.
        /// </summary>
        /// <param name="point">The point to find the closest point to.</param>
        /// <returns>The closest point on the sphere surface.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 ClosestPointTo(Double3 point)
        {
            Double3 closestPoint;
            IntersectionDouble.ClosestPointOnSphereToPoint(point, Center, Radius, out closestPoint);
            return closestPoint;
        }

        /// <summary>
        /// Expands the sphere to include a point.
        /// </summary>
        /// <param name="point">The point to include.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Encapsulate(Double3 point)
        {
            double distance = Maths.Length(point - Center);
            if (distance > Radius)
            {
                Radius = distance;
            }
        }

        /// <summary>
        /// Expands the sphere to include another sphere.
        /// </summary>
        /// <param name="other">The sphere to include.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Encapsulate(SphereDouble other)
        {
            double distance = Maths.Length(other.Center - Center);
            double requiredRadius = distance + other.Radius;
            if (requiredRadius > Radius)
            {
                Radius = requiredRadius;
            }
        }

        /// <summary>
        /// Returns a sphere that encapsulates both this sphere and a point.
        /// </summary>
        /// <param name="point">The point to include.</param>
        /// <returns>The encapsulating sphere.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SphereDouble Encapsulating(Double3 point)
        {
            var result = this;
            result.Encapsulate(point);
            return result;
        }

        /// <summary>
        /// Returns a sphere that encapsulates both this sphere and another sphere.
        /// </summary>
        /// <param name="other">The sphere to include.</param>
        /// <returns>The encapsulating sphere.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SphereDouble Encapsulating(SphereDouble other)
        {
            var result = this;
            result.Encapsulate(other);
            return result;
        }

        /// <summary>
        /// Transforms the sphere by a 4x4 matrix.
        /// Note: Only uniform scaling is properly supported.
        /// </summary>
        /// <param name="matrix">The transformation matrix.</param>
        /// <returns>The transformed sphere.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public SphereDouble Transform(Double4x4 matrix)
        {
            Double3 transformedCenter = Maths.TransformPoint(Center, matrix);
            
            // For radius, we need to handle scaling. We'll use the maximum scale factor.
            Double3 scaleVector = new Double3(
                Maths.Length(new Double3(matrix.c0.X, matrix.c0.Y, matrix.c0.Z)),
                Maths.Length(new Double3(matrix.c1.X, matrix.c1.Y, matrix.c1.Z)),
                Maths.Length(new Double3(matrix.c2.X, matrix.c2.Y, matrix.c2.Z))
            );
            double maxScale = Maths.Max(scaleVector.X, Maths.Max(scaleVector.Y, scaleVector.Z));
            double transformedRadius = Radius * maxScale;
            
            return new SphereDouble(transformedCenter, transformedRadius);
        }

        /// <summary>
        /// Samples a random point uniformly distributed on the sphere surface.
        /// </summary>
        /// <param name="u">Random value between 0 and 1.</param>
        /// <param name="v">Random value between 0 and 1.</param>
        /// <returns>A uniformly distributed point on the sphere surface.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 SampleSurface(double u, double v)
        {
            double theta = 2.0 * (double)Maths.PI * u;
            double phi = Maths.Acos(2.0 * v - 1.0);
            
            double sinPhi = Maths.Sin(phi);
            double x = sinPhi * Maths.Cos(theta);
            double y = sinPhi * Maths.Sin(theta);
            double z = Maths.Cos(phi);
            
            return Center + new Double3(x, y, z) * Radius;
        }

        /// <summary>
        /// Samples a random point uniformly distributed inside the sphere volume.
        /// </summary>
        /// <param name="u">Random value between 0 and 1.</param>
        /// <param name="v">Random value between 0 and 1.</param>
        /// <param name="w">Random value between 0 and 1.</param>
        /// <returns>A uniformly distributed point inside the sphere.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 SampleVolume(double u, double v, double w)
        {
            double r = Radius * Maths.Pow(u, 1.0 / 3); // Cube root for uniform distribution
            Double3 direction = SampleSurface(v, w) - Center;
            direction = Maths.Normalize(direction);
            return Center + direction * r;
        }

        /// <summary>
        /// Creates a sphere from two points (diameter endpoints).
        /// </summary>
        /// <param name="pointA">First endpoint.</param>
        /// <param name="pointB">Second endpoint.</param>
        /// <returns>A sphere with the two points as diameter endpoints.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static SphereDouble FromDiameter(Double3 pointA, Double3 pointB)
        {
            Double3 center = (pointA + pointB) / 2.0;
            double radius = Maths.Length(pointB - pointA) / 2.0;
            return new SphereDouble(center, radius);
        }

        /// <summary>
        /// Creates the smallest sphere that contains all the given points.
        /// Uses Welzl's algorithm for small point sets, falls back to naive approach for larger sets.
        /// </summary>
        /// <param name="points">The points to encapsulate.</param>
        /// <returns>The smallest encapsulating sphere.</returns>
        public static SphereDouble FromPoints(Double3[] points)
        {
            if (points == null || points.Length == 0)
                return new SphereDouble(Double3.Zero, 0.0);
            
            if (points.Length == 1)
                return new SphereDouble(points[0], 0.0);
            
            if (points.Length == 2)
                return FromDiameter(points[0], points[1]);
            
            // For simplicity, use centroid and max distance approach
            // A more sophisticated implementation would use Welzl's algorithm
            Double3 centroid = Double3.Zero;
            for (int i = 0; i < points.Length; i++)
            {
                centroid += points[i];
            }
            centroid /= points.Length;
            
            double maxDistSq = 0.0;
            for (int i = 0; i < points.Length; i++)
            {
                double distSq = Maths.LengthSquared(points[i] - centroid);
                if (distSq > maxDistSq)
                    maxDistSq = distSq;
            }
            
            return new SphereDouble(centroid, Maths.Sqrt(maxDistSq));
        }

        // --- IEquatable & IFormattable Implementation ---
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(SphereDouble other) => Center.Equals(other.Center) && Radius.Equals(other.Radius);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj) => obj is SphereDouble other && Equals(other);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode() => HashCode.Combine(Center, Radius);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string ToString() => ToString(null, CultureInfo.CurrentCulture);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToString(string? format, IFormatProvider? formatProvider = null)
        {
            return string.Format(formatProvider, "SphereDouble(Center: {0}, Radius: {1})", 
                Center.ToString(format, formatProvider), Radius.ToString(format, formatProvider));
        }

        public static bool operator ==(SphereDouble left, SphereDouble right) => left.Equals(right);
        public static bool operator !=(SphereDouble left, SphereDouble right) => !left.Equals(right);
    }
}
