//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-09-14 17:55:33
//

// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Linq;

namespace Prowl.Vector.Geometry
{

    /// <summary>
    /// Represents a parametric spline curve in 3D space.
    /// </summary>
    public struct Spline : IEquatable<Spline>, IFormattable
    {
        /// <summary>
        /// Represents a coordinate frame along the spline.
        /// </summary>
        public struct SplineFrame
        {
            /// <summary>The position on the spline.</summary>
            public Float3 Position;
            
            /// <summary>The forward direction (tangent to the spline).</summary>
            public Float3 Forward;
            
            /// <summary>The up direction (binormal or twist-controlled up vector).</summary>
            public Float3 Up;
            
            /// <summary>The right direction (cross product of forward and up).</summary>
            public Float3 Right;
            
            /// <summary>The curvature at this point.</summary>
            public float Curvature;
            
            /// <summary>The torsion (twist) at this point.</summary>
            public float Torsion;

            public SplineFrame(Float3 position, Float3 forward, Float3 up, Float3 right, float curvature = 0f, float torsion = 0f)
            {
                Position = position;
                Forward = forward;
                Up = up;
                Right = right;
                Curvature = curvature;
                Torsion = torsion;
            }
        }

        /// <summary>
        /// Represents different types of spline interpolation.
        /// </summary>
        public enum SplineType
        {
            /// <summary>Linear interpolation between points.</summary>
            Linear,
            /// <summary>Catmull-Rom spline (cardinal spline with tension 0).</summary>
            CatmullRom,
            /// <summary>Cubic Bezier spline.</summary>
            Bezier,
            /// <summary>B-spline (uniform cubic B-spline).</summary>
            BSpline,
            /// <summary>Hermite spline with tangent control.</summary>
            Hermite
        }

        /// <summary>
        /// Method for calculating the up vector along the spline.
        /// </summary>
        public enum UpVectorMethod
        {
            /// <summary>Use a fixed world-space up vector (e.g., Y-up).</summary>
            FixedWorldUp,
            /// <summary>Use Frenet frame (normal from curvature).</summary>
            FrenetFrame,
            /// <summary>Use custom up vectors provided per control point.</summary>
            Custom
        }

        /// <summary>The control points of the spline.</summary>
        public Float3[] ControlPoints;

        /// <summary>The tangent vectors for Hermite splines.</summary>
        public Float3[]? Tangents;

        /// <summary>The type of spline interpolation.</summary>
        public SplineType Type;

        /// <summary>Whether the spline is closed (forms a loop).</summary>
        public bool IsClosed;

        /// <summary>Tension parameter for cardinal splines (0 = Catmull-Rom).</summary>
        public float Tension;

        /// <summary>Custom up vectors for UpVectorMethod.Custom.</summary>
        public Float3[]? CustomUpVectors;

        /// <summary>Fixed world up vector for UpVectorMethod.FixedWorldUp.</summary>
        public Float3 WorldUpVector;

        /// <summary>
        /// Initializes a new spline with the specified control points and type.
        /// </summary>
        /// <param name="controlPoints">The control points defining the spline.</param>
        /// <param name="type">The type of spline interpolation.</param>
        /// <param name="closed">Whether the spline should be closed.</param>
        /// <param name="tension">Tension parameter for cardinal splines.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Spline(Float3[] controlPoints, SplineType type = SplineType.CatmullRom, bool closed = false, float tension = 0f)
        {
            ControlPoints = controlPoints ?? throw new ArgumentNullException(nameof(controlPoints));
            Tangents = null;
            Type = type;
            IsClosed = closed;
            Tension = tension;
            CustomUpVectors = null;
            WorldUpVector = Float3.UnitY;

            if (type == SplineType.Hermite)
            {
                // Initialize default tangents for Hermite splines
                GenerateDefaultTangents();
            }
        }

        /// <summary>
        /// Initializes a new Hermite spline with control points and tangents.
        /// </summary>
        /// <param name="controlPoints">The control points defining the spline.</param>
        /// <param name="tangents">The tangent vectors at each control point.</param>
        /// <param name="closed">Whether the spline should be closed.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Spline(Float3[] controlPoints, Float3[] tangents, bool closed = false)
        {
            ControlPoints = controlPoints ?? throw new ArgumentNullException(nameof(controlPoints));
            Tangents = tangents ?? throw new ArgumentNullException(nameof(tangents));
            Type = SplineType.Hermite;
            IsClosed = closed;
            Tension = 0f;
            CustomUpVectors = null;
            WorldUpVector = Float3.UnitY;

            if (controlPoints.Length != tangents.Length)
                throw new ArgumentException("Control points and tangents arrays must have the same length.");
        }

        /// <summary>
        /// Gets the number of control points in the spline.
        /// </summary>
        public int ControlPointCount
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => ControlPoints?.Length ?? 0;
        }

        /// <summary>
        /// Gets the number of segments in the spline.
        /// </summary>
        public int SegmentCount
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                if (ControlPoints == null || ControlPoints.Length < 2) return 0;
                
                return Type switch
                {
                    SplineType.Bezier => (ControlPoints.Length - 1) / 3,
                    _ => IsClosed ? ControlPoints.Length : ControlPoints.Length - 1
                };
            }
        }

        /// <summary>
        /// Evaluates the spline at the given parameter t.
        /// </summary>
        /// <param name="t">Parameter value (0 to 1 for the entire spline).</param>
        /// <returns>The position on the spline at parameter t.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Float3 Evaluate(float t)
        {
            if (ControlPoints == null || ControlPoints.Length == 0)
                return Float3.Zero;

            if (ControlPoints.Length == 1)
                return ControlPoints[0];

            // Clamp t to [0, 1]
            t = Maths.Clamp(t, 0f, 1f);

            return Type switch
            {
                SplineType.Linear => EvaluateLinear(t),
                SplineType.CatmullRom => EvaluateCatmullRom(t),
                SplineType.Bezier => EvaluateBezier(t),
                SplineType.BSpline => EvaluateBSpline(t),
                SplineType.Hermite => EvaluateHermite(t),
                _ => EvaluateLinear(t)
            };
        }

        /// <summary>
        /// Evaluates the first derivative (tangent) of the spline at parameter t.
        /// </summary>
        /// <param name="t">Parameter value (0 to 1).</param>
        /// <returns>The tangent vector at parameter t.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Float3 EvaluateDerivative(float t)
        {
            if (ControlPoints == null || ControlPoints.Length < 2)
                return Float3.Zero;

            t = Maths.Clamp(t, 0f, 1f);

            return Type switch
            {
                SplineType.Linear => EvaluateLinearDerivative(t),
                SplineType.CatmullRom => EvaluateCatmullRomDerivative(t),
                SplineType.Bezier => EvaluateBezierDerivative(t),
                SplineType.BSpline => EvaluateBSplineDerivative(t),
                SplineType.Hermite => EvaluateHermiteDerivative(t),
                _ => EvaluateLinearDerivative(t)
            };
        }

        /// <summary>
        /// Evaluates a complete coordinate frame (position, forward, up, right) at parameter t.
        /// </summary>
        /// <param name="t">Parameter value (0 to 1).</param>
        /// <param name="upMethod">Method for calculating the up vector.</param>
        /// <returns>A complete coordinate frame at parameter t.</returns>
        public SplineFrame EvaluateFrame(float t, UpVectorMethod upMethod = UpVectorMethod.FixedWorldUp)
        {
            if (ControlPoints == null || ControlPoints.Length < 2)
                return new SplineFrame(Float3.Zero, Float3.UnitZ, Float3.UnitY, Float3.UnitX);

            t = Maths.Clamp(t, 0f, 1f);

            // Get position and first derivative (tangent)
            Float3 position = Evaluate(t);
            Float3 firstDerivative = EvaluateDerivative(t);
            
            // Normalize the forward direction
            Float3 forward = Maths.Normalize(firstDerivative);
            
            // Handle degenerate case
            if (Maths.LengthSquared(forward) < float.Epsilon * float.Epsilon)
            {
                forward = Float3.UnitZ;
            }

            Float3 up, right;
            float curvature = 0f;
            float torsion = 0f;

            switch (upMethod)
            {
                case UpVectorMethod.FixedWorldUp:
                    {
                        Float3 worldUp = WorldUpVector.Equals(Float3.Zero) ? Float3.UnitY : Maths.Normalize(WorldUpVector);
                        right = Maths.Normalize(Maths.Cross(forward, worldUp));
                        
                        // Handle case where forward is parallel to world up
                        if (Maths.LengthSquared(right) < float.Epsilon * float.Epsilon)
                        {
                            // Choose an arbitrary perpendicular vector
                            Float3 arbitrary = Maths.Abs(forward.X) < (float)0.9 ? Float3.UnitX : Float3.UnitZ;
                            right = Maths.Normalize(Maths.Cross(forward, arbitrary));
                        }
                        
                        up = Maths.Cross(right, forward);
                    }
                    break;

                case UpVectorMethod.FrenetFrame:
                    {
                        // Calculate second derivative for curvature
                        Float3 secondDerivative = EvaluateSecondDerivative(t);
                        Float3 normal = secondDerivative - Maths.Dot(secondDerivative, forward) * forward;
                        
                        float normalLength = Maths.Length(normal);
                        if (normalLength > float.Epsilon)
                        {
                            up = normal / normalLength;
                            curvature = normalLength / Maths.Max(Maths.LengthSquared(firstDerivative), float.Epsilon);
                        }
                        else
                        {
                            // Fallback to world up when curvature is zero
                            Float3 worldUp = Float3.UnitY;
                            up = worldUp - Maths.Dot(worldUp, forward) * forward;
                            if (Maths.LengthSquared(up) < float.Epsilon * float.Epsilon)
                            {
                                Float3 arbitrary = Maths.Abs(forward.X) < (float)0.9 ? Float3.UnitX : Float3.UnitZ;
                                up = Maths.Normalize(Maths.Cross(Maths.Cross(forward, arbitrary), forward));
                            }
                            else
                            {
                                up = Maths.Normalize(up);
                            }
                        }
                        
                        right = Maths.Cross(forward, up);
                        
                        // Calculate torsion if we have enough derivatives
                        Float3 thirdDerivative = EvaluateThirdDerivative(t);
                        Float3 crossFirstSecond = Maths.Cross(firstDerivative, secondDerivative);
                        float crossLength = Maths.Length(crossFirstSecond);
                        if (crossLength > float.Epsilon)
                        {
                            torsion = Maths.Dot(crossFirstSecond, thirdDerivative) / (crossLength * crossLength);
                        }
                    }
                    break;

                case UpVectorMethod.Custom:
                    {
                        if (CustomUpVectors != null && CustomUpVectors.Length > 0)
                        {
                            Float3 customUp = InterpolateCustomUpVector(t);
                            // Project custom up vector onto plane perpendicular to forward
                            up = customUp - Maths.Dot(customUp, forward) * forward;
                            if (Maths.LengthSquared(up) < float.Epsilon * float.Epsilon)
                            {
                                // Fallback if custom up is parallel to forward
                                Float3 arbitrary = Maths.Abs(forward.X) < (float)0.9 ? Float3.UnitX : Float3.UnitZ;
                                up = Maths.Normalize(Maths.Cross(Maths.Cross(forward, arbitrary), forward));
                            }
                            else
                            {
                                up = Maths.Normalize(up);
                            }
                            right = Maths.Cross(forward, up);
                        }
                        else
                        {
                            // Fallback to fixed world up
                            Float3 worldUp = Float3.UnitY;
                            right = Maths.Normalize(Maths.Cross(forward, worldUp));
                            if (Maths.LengthSquared(right) < float.Epsilon * float.Epsilon)
                            {
                                Float3 arbitrary = Maths.Abs(forward.X) < (float)0.9 ? Float3.UnitX : Float3.UnitZ;
                                right = Maths.Normalize(Maths.Cross(forward, arbitrary));
                            }
                            up = Maths.Cross(right, forward);
                        }
                    }
                    break;

                default:
                    up = Float3.UnitY;
                    right = Float3.UnitX;
                    break;
            }

            return new SplineFrame(position, forward, up, right, curvature, torsion);
        }

        /// <summary>
        /// Evaluates multiple frames along the spline.
        /// </summary>
        /// <param name="sampleCount">Number of frames to generate.</param>
        /// <param name="upMethod">Method for calculating up vectors.</param>
        /// <returns>Array of coordinate frames along the spline.</returns>
        public SplineFrame[] EvaluateFrames(int sampleCount, UpVectorMethod upMethod = UpVectorMethod.FixedWorldUp)
        {
            if (sampleCount < 2)
                throw new ArgumentException("Sample count must be at least 2", nameof(sampleCount));

            var frames = new SplineFrame[sampleCount];
            for (int i = 0; i < sampleCount; i++)
            {
                float t = i / (float)(sampleCount - 1);
                frames[i] = EvaluateFrame(t, upMethod);
            }

            return frames;
        }

        /// <summary>
        /// Sets custom up vectors for UpVectorMethod.Custom.
        /// </summary>
        /// <param name="upVectors">Up vectors corresponding to control points.</param>
        public void SetCustomUpVectors(Float3[] upVectors)
        {
            if (upVectors == null)
            {
                CustomUpVectors = null;
                return;
            }

            CustomUpVectors = new Float3[upVectors.Length];
            Array.Copy(upVectors, CustomUpVectors, upVectors.Length);
        }

        /// <summary>
        /// Sets the world up vector for UpVectorMethod.FixedWorldUp.
        /// </summary>
        /// <param name="worldUp">The world up vector.</param>
        public void SetWorldUpVector(Float3 worldUp)
        {
            WorldUpVector = worldUp;
        }

        #region Private Frame Calculation Methods

        private Float3 EvaluateSecondDerivative(float t)
        {
            // Numerical approximation of second derivative
            const float h = float.Epsilon * 1000; // Small step
            float t1 = Maths.Max(t - h, 0f);
            float t2 = Maths.Min(t + h, 1f);
            
            Float3 d1 = EvaluateDerivative(t1);
            Float3 d2 = EvaluateDerivative(t2);
            
            return (d2 - d1) / (t2 - t1);
        }

        private Float3 EvaluateThirdDerivative(float t)
        {
            // Numerical approximation of third derivative
            const float h = float.Epsilon * 1000;
            float t1 = Maths.Max(t - h, 0f);
            float t2 = Maths.Min(t + h, 1f);
            
            Float3 d1 = EvaluateSecondDerivative(t1);
            Float3 d2 = EvaluateSecondDerivative(t2);
            
            return (d2 - d1) / (t2 - t1);
        }

        private Float3 InterpolateCustomUpVector(float t)
        {
            if (CustomUpVectors == null || CustomUpVectors.Length == 0)
                return Float3.UnitY;

            if (CustomUpVectors.Length == 1)
                return CustomUpVectors[0];

            // Interpolate between custom up vectors based on control point positions
            float scaledT = t * (CustomUpVectors.Length - 1);
            int index = (int)Maths.Floor(scaledT);
            float localT = scaledT - index;

            if (index >= CustomUpVectors.Length - 1)
                return CustomUpVectors[CustomUpVectors.Length - 1];

            // Use spherical linear interpolation for smooth rotation
            return Slerp(CustomUpVectors[index], CustomUpVectors[index + 1], localT);
        }

        private Float3 Slerp(Float3 a, Float3 b, float t)
        {
            // Spherical linear interpolation
            float dot = Maths.Clamp(Maths.Dot(a, b), -1f, 1f);
            
            if (Maths.Abs(dot) > (float)0.9995)
            {
                // Vectors are nearly parallel, use linear interpolation
                return Maths.Normalize(Maths.Lerp(a, b, t));
            }
            
            float theta = Maths.Acos(Maths.Abs(dot));
            float sinTheta = Maths.Sin(theta);
            
            float wa = Maths.Sin((1f - t) * theta) / sinTheta;
            float wb = Maths.Sin(t * theta) / sinTheta;
            
            if (dot < 0f)
                wb = -wb;
                
            return Maths.Normalize(a * wa + b * wb);
        }

        #endregion

        /// <summary>
        /// Creates a transformation matrix from a spline frame.
        /// </summary>
        /// <param name="frame">The spline frame.</param>
        /// <returns>A 4x4 transformation matrix.</returns>
        public static Float4x4 FrameToMatrix(SplineFrame frame)
        {
            return new Float4x4(
                frame.Right.X, frame.Up.X, frame.Forward.X, frame.Position.X,
                frame.Right.Y, frame.Up.Y, frame.Forward.Y, frame.Position.Y,
                frame.Right.Z, frame.Up.Z, frame.Forward.Z, frame.Position.Z,
                0f, 0f, 0f, 1f
            );
        }

        /// <summary>
        /// Transforms a local offset by a spline frame.
        /// </summary>
        /// <param name="frame">The spline frame.</param>
        /// <param name="localOffset">Local offset (X=right, Y=up, Z=forward).</param>
        /// <returns>World space position.</returns>
        public static Float3 TransformByFrame(SplineFrame frame, Float3 localOffset)
        {
            return frame.Position + 
                   frame.Right * localOffset.X + 
                   frame.Up * localOffset.Y + 
                   frame.Forward * localOffset.Z;
        }

        /// <summary>
        /// Gets the approximate length of the spline using adaptive sampling.
        /// </summary>
        /// <param name="subdivisions">Number of subdivisions for length calculation.</param>
        /// <returns>The approximate length of the spline.</returns>
        public float GetLength(int subdivisions = 100)
        {
            if (ControlPoints == null || ControlPoints.Length < 2)
                return 0f;

            float length = 0f;
            Float3 previousPoint = Evaluate(0f);

            for (int i = 1; i <= subdivisions; i++)
            {
                float t = i / (float)subdivisions;
                Float3 currentPoint = Evaluate(t);
                length += Maths.Length(currentPoint - previousPoint);
                previousPoint = currentPoint;
            }

            return length;
        }

        /// <summary>
        /// Finds the parameter t that corresponds to the given arc length.
        /// </summary>
        /// <param name="targetLength">The target arc length.</param>
        /// <param name="tolerance">Tolerance for the binary search.</param>
        /// <returns>The parameter t corresponding to the target length.</returns>
        public float GetParameterAtLength(float targetLength, float tolerance = float.Epsilon * 1000)
        {
            if (targetLength <= 0f) return 0f;

            float totalLength = GetLength();
            if (targetLength >= totalLength) return 1f;

            // Binary search for the parameter
            float tMin = 0f;
            float tMax = 1f;
            float t = targetLength / totalLength; // Initial guess

            for (int iteration = 0; iteration < 50; iteration++) // Max iterations
            {
                float currentLength = GetLengthUpToParameter(t);
                float error = currentLength - targetLength;

                if (Maths.Abs(error) < tolerance)
                    break;

                if (error > 0f)
                    tMax = t;
                else
                    tMin = t;

                t = (tMin + tMax) / 2f;
            }

            return t;
        }

        /// <summary>
        /// Gets the length of the spline from t=0 to the given parameter.
        /// </summary>
        /// <param name="t">The parameter to measure length to.</param>
        /// <param name="subdivisions">Number of subdivisions for calculation.</param>
        /// <returns>The length from start to parameter t.</returns>
        public float GetLengthUpToParameter(float t, int subdivisions = 100)
        {
            if (t <= 0f) return 0f;
            if (t >= 1f) return GetLength(subdivisions);

            float length = 0f;
            Float3 previousPoint = Evaluate(0f);
            int steps = (int)(subdivisions * t);

            for (int i = 1; i <= steps; i++)
            {
                float currentT = (i / (float)subdivisions);
                Float3 currentPoint = Evaluate(currentT);
                length += Maths.Length(currentPoint - previousPoint);
                previousPoint = currentPoint;
            }

            return length;
        }

        /// <summary>
        /// Samples points along the spline at uniform parameter intervals.
        /// </summary>
        /// <param name="sampleCount">Number of samples to generate.</param>
        /// <returns>Array of sampled points.</returns>
        public Float3[] SampleUniform(int sampleCount)
        {
            if (sampleCount < 2)
                throw new ArgumentException("Sample count must be at least 2", nameof(sampleCount));

            var samples = new Float3[sampleCount];
            for (int i = 0; i < sampleCount; i++)
            {
                float t = i / (float)(sampleCount - 1);
                samples[i] = Evaluate(t);
            }

            return samples;
        }

        /// <summary>
        /// Samples points along the spline at uniform arc length intervals.
        /// </summary>
        /// <param name="sampleCount">Number of samples to generate.</param>
        /// <returns>Array of sampled points with uniform spacing.</returns>
        public Float3[] SampleUniformLength(int sampleCount)
        {
            if (sampleCount < 2)
                throw new ArgumentException("Sample count must be at least 2", nameof(sampleCount));

            var samples = new Float3[sampleCount];
            float totalLength = GetLength();

            for (int i = 0; i < sampleCount; i++)
            {
                float targetLength = (i / (float)(sampleCount - 1)) * totalLength;
                float t = GetParameterAtLength(targetLength);
                samples[i] = Evaluate(t);
            }

            return samples;
        }

        /// <summary>
        /// Finds the closest point on the spline to a given point.
        /// </summary>
        /// <param name="point">The point to find the closest point to.</param>
        /// <param name="subdivisions">Number of subdivisions for the search.</param>
        /// <returns>The closest point on the spline and its parameter.</returns>
        public (Float3 Point, float Parameter) GetClosestPoint(Float3 point, int subdivisions = 100)
        {
            float minDistance = float.MaxValue;
            float closestT = 0f;
            Float3 closestPoint = Float3.Zero;

            // Coarse search
            for (int i = 0; i <= subdivisions; i++)
            {
                float t = i / (float)subdivisions;
                Float3 splinePoint = Evaluate(t);
                float distance = Maths.LengthSquared(point - splinePoint);

                if (distance < minDistance)
                {
                    minDistance = distance;
                    closestT = t;
                    closestPoint = splinePoint;
                }
            }

            // Refine with Newton-Raphson if we have derivatives
            if (Type != SplineType.Linear)
            {
                for (int iteration = 0; iteration < 10; iteration++)
                {
                    Float3 splinePoint = Evaluate(closestT);
                    Float3 derivative = EvaluateDerivative(closestT);
                    
                    Float3 diff = splinePoint - point;
                    float numerator = Maths.Dot(diff, derivative);
                    float denominator = Maths.Dot(derivative, derivative);

                    if (Maths.Abs(denominator) < float.Epsilon)
                        break;

                    float newT = closestT - numerator / denominator;
                    newT = Maths.Clamp(newT, 0f, 1f);

                    if (Maths.Abs(newT - closestT) < float.Epsilon)
                        break;

                    closestT = newT;
                    closestPoint = Evaluate(closestT);
                }
            }

            return (closestPoint, closestT);
        }

        #region Private Evaluation Methods

        private Float3 EvaluateLinear(float t)
        {
            if (ControlPoints.Length == 1) return ControlPoints[0];

            float scaledT = t * (ControlPoints.Length - 1);
            int index = (int)Maths.Floor(scaledT);
            float localT = scaledT - index;

            if (index >= ControlPoints.Length - 1)
            {
                return IsClosed ? 
                    Maths.Lerp(ControlPoints[ControlPoints.Length - 1], ControlPoints[0], localT) :
                    ControlPoints[ControlPoints.Length - 1];
            }

            Float3 p0 = ControlPoints[index];
            Float3 p1 = ControlPoints[index + 1];
            return Maths.Lerp(p0, p1, localT);
        }

        private Float3 EvaluateCatmullRom(float t)
        {
            int segmentCount = IsClosed ? ControlPoints.Length : ControlPoints.Length - 1;
            float scaledT = t * segmentCount;
            int segment = (int)Maths.Floor(scaledT);
            float localT = scaledT - segment;

            if (segment >= segmentCount)
            {
                segment = segmentCount - 1;
                localT = 1f;
            }

            // Get the four control points for Catmull-Rom
            Float3 p0, p1, p2, p3;
            GetCatmullRomPoints(segment, out p0, out p1, out p2, out p3);

            // Catmull-Rom interpolation
            float t2 = localT * localT;
            float t3 = t2 * localT;

            float b0 = -Tension * t3 + 2f * Tension * t2 - Tension * localT;
            float b1 = (2f - Tension) * t3 + (Tension - 3) * t2 + 1f;
            float b2 = (Tension - 2f) * t3 + (3 - 2f * Tension) * t2 + Tension * localT;
            float b3 = Tension * t3 - Tension * t2;

            return p0 * b0 + p1 * b1 + p2 * b2 + p3 * b3;
        }

        private Float3 EvaluateBezier(float t)
        {
            int segmentCount = (ControlPoints.Length - 1) / 3;
            if (segmentCount == 0) return ControlPoints[0];

            float scaledT = t * segmentCount;
            int segment = (int)Maths.Floor(scaledT);
            float localT = scaledT - segment;

            if (segment >= segmentCount)
            {
                segment = segmentCount - 1;
                localT = 1f;
            }

            int baseIndex = segment * 3;
            Float3 p0 = ControlPoints[baseIndex];
            Float3 p1 = ControlPoints[baseIndex + 1];
            Float3 p2 = ControlPoints[baseIndex + 2];
            Float3 p3 = ControlPoints[baseIndex + 3];

            // Cubic Bezier evaluation
            float invT = 1f - localT;
            float invT2 = invT * invT;
            float invT3 = invT2 * invT;
            float t2 = localT * localT;
            float t3 = t2 * localT;

            return p0 * invT3 + p1 * (3 * invT2 * localT) + p2 * (3 * invT * t2) + p3 * t3;
        }

        private Float3 EvaluateBSpline(float t)
        {
            if (ControlPoints.Length < 4) return EvaluateLinear(t);

            int segmentCount = IsClosed ? ControlPoints.Length : ControlPoints.Length - 3;
            float scaledT = t * segmentCount;
            int segment = (int)Maths.Floor(scaledT);
            float localT = scaledT - segment;

            if (segment >= segmentCount)
            {
                segment = segmentCount - 1;
                localT = 1f;
            }

            // Get four control points for B-spline
            Float3 p0, p1, p2, p3;
            GetBSplinePoints(segment, out p0, out p1, out p2, out p3);

            // Uniform cubic B-spline basis functions
            float t2 = localT * localT;
            float t3 = t2 * localT;
            float invT = 1f - localT;
            float invT2 = invT * invT;
            float invT3 = invT2 * invT;

            float b0 = invT3 / 6;
            float b1 = (3 * t3 - 6 * t2 + 4) / 6;
            float b2 = (-3 * t3 + 3 * t2 + 3 * localT + 1f) / 6;
            float b3 = t3 / 6;

            return p0 * b0 + p1 * b1 + p2 * b2 + p3 * b3;
        }

        private Float3 EvaluateHermite(float t)
        {
            if (Tangents == null) return EvaluateLinear(t);

            int segmentCount = IsClosed ? ControlPoints.Length : ControlPoints.Length - 1;
            float scaledT = t * segmentCount;
            int segment = (int)Maths.Floor(scaledT);
            float localT = scaledT - segment;

            if (segment >= segmentCount)
            {
                segment = segmentCount - 1;
                localT = 1f;
            }

            Float3 p0 = ControlPoints[segment];
            Float3 p1 = ControlPoints[(segment + 1) % ControlPoints.Length];
            Float3 t0 = Tangents[segment];
            Float3 t1 = Tangents[(segment + 1) % Tangents.Length];

            // Hermite basis functions
            float t2 = localT * localT;
            float t3 = t2 * localT;

            float h00 = 2f * t3 - 3 * t2 + 1f;
            float h10 = t3 - 2f * t2 + localT;
            float h01 = -2f * t3 + 3 * t2;
            float h11 = t3 - t2;

            return p0 * h00 + t0 * h10 + p1 * h01 + t1 * h11;
        }

        private Float3 EvaluateLinearDerivative(float t)
        {
            if (ControlPoints.Length < 2) return Float3.Zero;

            float scaledT = t * (ControlPoints.Length - 1);
            int index = (int)Maths.Floor(scaledT);

            if (index >= ControlPoints.Length - 1)
            {
                return IsClosed ?
                    (ControlPoints[0] - ControlPoints[ControlPoints.Length - 1]) * (ControlPoints.Length - 1) :
                    Float3.Zero;
            }

            return (ControlPoints[index + 1] - ControlPoints[index]) * (ControlPoints.Length - 1);
        }

        private Float3 EvaluateCatmullRomDerivative(float t)
        {
            int segmentCount = IsClosed ? ControlPoints.Length : ControlPoints.Length - 1;
            float scaledT = t * segmentCount;
            int segment = (int)Maths.Floor(scaledT);
            float localT = scaledT - segment;

            if (segment >= segmentCount)
            {
                segment = segmentCount - 1;
                localT = 1f;
            }

            Float3 p0, p1, p2, p3;
            GetCatmullRomPoints(segment, out p0, out p1, out p2, out p3);

            float t2 = localT * localT;

            float db0 = -3 * Tension * t2 + 4 * Tension * localT - Tension;
            float db1 = 3 * (2f - Tension) * t2 + 2f * (Tension - 3) * localT;
            float db2 = 3 * (Tension - 2f) * t2 + 2f * (3 - 2f * Tension) * localT + Tension;
            float db3 = 3 * Tension * t2 - 2f * Tension * localT;

            return (p0 * db0 + p1 * db1 + p2 * db2 + p3 * db3) * segmentCount;
        }

        private Float3 EvaluateBezierDerivative(float t)
        {
            int segmentCount = (ControlPoints.Length - 1) / 3;
            if (segmentCount == 0) return Float3.Zero;

            float scaledT = t * segmentCount;
            int segment = (int)Maths.Floor(scaledT);
            float localT = scaledT - segment;

            if (segment >= segmentCount)
            {
                segment = segmentCount - 1;
                localT = 1f;
            }

            int baseIndex = segment * 3;
            Float3 p0 = ControlPoints[baseIndex];
            Float3 p1 = ControlPoints[baseIndex + 1];
            Float3 p2 = ControlPoints[baseIndex + 2];
            Float3 p3 = ControlPoints[baseIndex + 3];

            float invT = 1f - localT;
            float invT2 = invT * invT;
            float t2 = localT * localT;

            Float3 derivative = 
                p0 * (-3 * invT2) +
                p1 * (3 * invT2 - 6 * invT * localT) +
                p2 * (6 * invT * localT - 3 * t2) +
                p3 * (3 * t2);

            return derivative * segmentCount;
        }

        private Float3 EvaluateBSplineDerivative(float t)
        {
            if (ControlPoints.Length < 4) return EvaluateLinearDerivative(t);

            int segmentCount = IsClosed ? ControlPoints.Length : ControlPoints.Length - 3;
            float scaledT = t * segmentCount;
            int segment = (int)Maths.Floor(scaledT);
            float localT = scaledT - segment;

            if (segment >= segmentCount)
            {
                segment = segmentCount - 1;
                localT = 1f;
            }

            Float3 p0, p1, p2, p3;
            GetBSplinePoints(segment, out p0, out p1, out p2, out p3);

            float t2 = localT * localT;

            float db0 = -t2 / 2f;
            float db1 = (3 * t2 - 4 * localT) / 2f;
            float db2 = (-3 * t2 + 2f * localT + 1f) / 2f;
            float db3 = t2 / 2f;

            return (p0 * db0 + p1 * db1 + p2 * db2 + p3 * db3) * segmentCount;
        }

        private Float3 EvaluateHermiteDerivative(float t)
        {
            if (Tangents == null) return EvaluateLinearDerivative(t);

            int segmentCount = IsClosed ? ControlPoints.Length : ControlPoints.Length - 1;
            float scaledT = t * segmentCount;
            int segment = (int)Maths.Floor(scaledT);
            float localT = scaledT - segment;

            if (segment >= segmentCount)
            {
                segment = segmentCount - 1;
                localT = 1f;
            }

            Float3 p0 = ControlPoints[segment];
            Float3 p1 = ControlPoints[(segment + 1) % ControlPoints.Length];
            Float3 t0 = Tangents[segment];
            Float3 t1 = Tangents[(segment + 1) % Tangents.Length];

            float t2 = localT * localT;

            float dh00 = 6 * t2 - 6 * localT;
            float dh10 = 3 * t2 - 4 * localT + 1f;
            float dh01 = -6 * t2 + 6 * localT;
            float dh11 = 3 * t2 - 2f * localT;

            return (p0 * dh00 + t0 * dh10 + p1 * dh01 + t1 * dh11) * segmentCount;
        }

        private void GetCatmullRomPoints(int segment, out Float3 p0, out Float3 p1, out Float3 p2, out Float3 p3)
        {
            int count = ControlPoints.Length;
            
            p1 = ControlPoints[segment];
            p2 = ControlPoints[(segment + 1) % count];

            if (IsClosed)
            {
                p0 = ControlPoints[(segment - 1 + count) % count];
                p3 = ControlPoints[(segment + 2) % count];
            }
            else
            {
                p0 = segment > 0 ? ControlPoints[segment - 1] : ControlPoints[0] * 2f - ControlPoints[1];
                p3 = segment < count - 2 ? ControlPoints[segment + 2] : ControlPoints[count - 1] * 2f - ControlPoints[count - 2];
            }
        }

        private void GetBSplinePoints(int segment, out Float3 p0, out Float3 p1, out Float3 p2, out Float3 p3)
        {
            int count = ControlPoints.Length;

            if (IsClosed)
            {
                p0 = ControlPoints[segment % count];
                p1 = ControlPoints[(segment + 1) % count];
                p2 = ControlPoints[(segment + 2) % count];
                p3 = ControlPoints[(segment + 3) % count];
            }
            else
            {
                p0 = ControlPoints[segment];
                p1 = ControlPoints[segment + 1];
                p2 = ControlPoints[segment + 2];
                p3 = ControlPoints[segment + 3];
            }
        }

        private void GenerateDefaultTangents()
        {
            int count = ControlPoints.Length;
            Tangents = new Float3[count];

            for (int i = 0; i < count; i++)
            {
                Float3 prev, next;

                if (IsClosed)
                {
                    prev = ControlPoints[(i - 1 + count) % count];
                    next = ControlPoints[(i + 1) % count];
                }
                else
                {
                    prev = i > 0 ? ControlPoints[i - 1] : ControlPoints[i];
                    next = i < count - 1 ? ControlPoints[i + 1] : ControlPoints[i];
               }

               // Generate tangent as the difference between next and previous points
               Tangents[i] = (next - prev) / 2f;
           }
       }

       #endregion

       #region Utility Methods

       /// <summary>
       /// Adds a control point to the spline.
       /// </summary>
       /// <param name="point">The control point to add.</param>
       public void AddControlPoint(Float3 point)
       {
           if (ControlPoints == null)
           {
               ControlPoints = new Float3[] { point };
           }
           else
           {
               var newArray = new Float3[ControlPoints.Length + 1];
               Array.Copy(ControlPoints, newArray, ControlPoints.Length);
               newArray[ControlPoints.Length] = point;
               ControlPoints = newArray;
           }

           if (Type == SplineType.Hermite)
           {
               GenerateDefaultTangents();
           }
       }

       /// <summary>
       /// Inserts a control point at the specified index.
       /// </summary>
       /// <param name="index">The index to insert at.</param>
       /// <param name="point">The control point to insert.</param>
       public void InsertControlPoint(int index, Float3 point)
       {
           if (ControlPoints == null)
           {
               ControlPoints = new Float3[] { point };
               return;
           }

           if (index < 0 || index > ControlPoints.Length)
               throw new ArgumentOutOfRangeException(nameof(index));

           var newArray = new Float3[ControlPoints.Length + 1];
           Array.Copy(ControlPoints, 0, newArray, 0, index);
           newArray[index] = point;
           Array.Copy(ControlPoints, index, newArray, index + 1, ControlPoints.Length - index);
           ControlPoints = newArray;

           if (Type == SplineType.Hermite)
           {
               GenerateDefaultTangents();
           }
       }

       /// <summary>
       /// Removes the control point at the specified index.
       /// </summary>
       /// <param name="index">The index of the control point to remove.</param>
       public void RemoveControlPoint(int index)
       {
           if (ControlPoints == null || index < 0 || index >= ControlPoints.Length)
               throw new ArgumentOutOfRangeException(nameof(index));

           if (ControlPoints.Length == 1)
           {
               ControlPoints = null;
               Tangents = null;
               return;
           }

           var newArray = new Float3[ControlPoints.Length - 1];
           Array.Copy(ControlPoints, 0, newArray, 0, index);
           Array.Copy(ControlPoints, index + 1, newArray, index, ControlPoints.Length - index - 1);
           ControlPoints = newArray;

           if (Type == SplineType.Hermite)
           {
               GenerateDefaultTangents();
           }
       }

       /// <summary>
       /// Sets the tangent at the specified control point index (for Hermite splines).
       /// </summary>
       /// <param name="index">The control point index.</param>
       /// <param name="tangent">The tangent vector.</param>
       public void SetTangent(int index, Float3 tangent)
       {
           if (Type != SplineType.Hermite)
               throw new InvalidOperationException("Tangents can only be set for Hermite splines");

           if (Tangents == null || index < 0 || index >= Tangents.Length)
               throw new ArgumentOutOfRangeException(nameof(index));

           Tangents[index] = tangent;
       }

       /// <summary>
       /// Gets the tangent at the specified control point index.
       /// </summary>
       /// <param name="index">The control point index.</param>
       /// <returns>The tangent vector at the specified index.</returns>
       public Float3 GetTangent(int index)
       {
           if (Type != SplineType.Hermite || Tangents == null)
               return EvaluateDerivative(index / (float)(ControlPointCount - 1));

           if (index < 0 || index >= Tangents.Length)
               throw new ArgumentOutOfRangeException(nameof(index));

           return Tangents[index];
       }

       /// <summary>
       /// Reverses the direction of the spline.
       /// </summary>
       public void Reverse()
       {
           if (ControlPoints == null) return;

           Array.Reverse(ControlPoints);

           if (Tangents != null)
           {
               Array.Reverse(Tangents);
               // Negate tangents since we're reversing direction
               for (int i = 0; i < Tangents.Length; i++)
               {
                   Tangents[i] = -Tangents[i];
               }
           }
       }

       /// <summary>
       /// Creates a reversed copy of this spline.
       /// </summary>
       /// <returns>A new spline with reversed direction.</returns>
       public Spline Reversed()
       {
           var copy = this;
           copy.Reverse();
           return copy;
       }

       /// <summary>
       /// Subdivides the spline by inserting new control points.
       /// </summary>
       /// <param name="subdivisionsPerSegment">Number of subdivisions per segment.</param>
       public void Subdivide(int subdivisionsPerSegment = 1)
       {
           if (ControlPoints == null || subdivisionsPerSegment < 1) return;

           var newPoints = new List<Float3>();
           int segmentCount = IsClosed ? ControlPoints.Length : ControlPoints.Length - 1;

           for (int segment = 0; segment < segmentCount; segment++)
           {
               float segmentStart = segment / (float)segmentCount;
               float segmentEnd = (segment + 1) / (float)segmentCount;

               newPoints.Add(ControlPoints[segment]);

               for (int sub = 1; sub <= subdivisionsPerSegment; sub++)
               {
                   float t = segmentStart + (segmentEnd - segmentStart) * (sub / (float)(subdivisionsPerSegment + 1));
                   newPoints.Add(Evaluate(t));
               }
           }

           if (!IsClosed)
           {
               newPoints.Add(ControlPoints[ControlPoints.Length - 1]);
           }

           ControlPoints = newPoints.ToArray();

           if (Type == SplineType.Hermite)
           {
               GenerateDefaultTangents();
           }
       }

       /// <summary>
       /// Smooths the spline by averaging control point positions.
       /// </summary>
       /// <param name="iterations">Number of smoothing iterations.</param>
       /// <param name="strength">Smoothing strength (0 = no smoothing, 1 = full averaging).</param>
       public void Smooth(int iterations = 1, float strength = (float)0.5)
       {
           if (ControlPoints == null || ControlPoints.Length < 3) return;

           strength = Maths.Clamp(strength, 0f, 1f);

           for (int iter = 0; iter < iterations; iter++)
           {
               var smoothedPoints = new Float3[ControlPoints.Length];

               for (int i = 0; i < ControlPoints.Length; i++)
               {
                   Float3 prev, next;

                   if (IsClosed)
                   {
                       prev = ControlPoints[(i - 1 + ControlPoints.Length) % ControlPoints.Length];
                       next = ControlPoints[(i + 1) % ControlPoints.Length];
                   }
                   else
                   {
                       prev = i > 0 ? ControlPoints[i - 1] : ControlPoints[i];
                       next = i < ControlPoints.Length - 1 ? ControlPoints[i + 1] : ControlPoints[i];
                   }

                   Float3 averaged = (prev + ControlPoints[i] + next) / 3;
                   smoothedPoints[i] = Maths.Lerp(ControlPoints[i], averaged, strength);
               }

               ControlPoints = smoothedPoints;
           }

           if (Type == SplineType.Hermite)
           {
               GenerateDefaultTangents();
           }
       }

       /// <summary>
       /// Calculates the bounding box of the spline.
       /// </summary>
       /// <param name="subdivisions">Number of subdivisions for accurate bounds calculation.</param>
       /// <returns>The axis-aligned bounding box containing the spline.</returns>
       public AABB GetBounds(int subdivisions = 100)
       {
           if (ControlPoints == null || ControlPoints.Length == 0)
               return new AABB(Float3.Zero, Float3.Zero);

           Float3 min = ControlPoints[0];
           Float3 max = ControlPoints[0];

           // Include all control points
           foreach (var point in ControlPoints)
           {
               min = new Float3(
                   Maths.Min(min.X, point.X),
                   Maths.Min(min.Y, point.Y),
                   Maths.Min(min.Z, point.Z)
               );
               max = new Float3(
                   Maths.Max(max.X, point.X),
                   Maths.Max(max.Y, point.Y),
                   Maths.Max(max.Z, point.Z)
               );
           }

           // Sample the spline for curves that might extend beyond control points
           for (int i = 0; i <= subdivisions; i++)
           {
               float t = i / (float)subdivisions;
               Float3 point = Evaluate(t);

               min = new Float3(
                   Maths.Min(min.X, point.X),
                   Maths.Min(min.Y, point.Y),
                   Maths.Min(min.Z, point.Z)
               );
               max = new Float3(
                   Maths.Max(max.X, point.X),
                   Maths.Max(max.Y, point.Y),
                   Maths.Max(max.Z, point.Z)
               );
           }

           return new AABB(min, max);
       }

       #endregion

       #region Static Factory Methods

       /// <summary>
       /// Creates a linear spline from the given points.
       /// </summary>
       /// <param name="points">The control points.</param>
       /// <param name="closed">Whether the spline should be closed.</param>
       /// <returns>A linear spline.</returns>
       public static Spline CreateLinear(Float3[] points, bool closed = false)
       {
           return new Spline(points, SplineType.Linear, closed);
       }

       /// <summary>
       /// Creates a Catmull-Rom spline from the given points.
       /// </summary>
       /// <param name="points">The control points.</param>
       /// <param name="closed">Whether the spline should be closed.</param>
       /// <param name="tension">Tension parameter (0 = standard Catmull-Rom).</param>
       /// <returns>A Catmull-Rom spline.</returns>
       public static Spline CreateCatmullRom(Float3[] points, bool closed = false, float tension = 0f)
       {
           return new Spline(points, SplineType.CatmullRom, closed, tension);
       }

       /// <summary>
       /// Creates a cubic Bezier spline from control points.
       /// The number of control points should be 3n+1 for n Bezier segments.
       /// </summary>
       /// <param name="points">The control points (must be 3n+1 points).</param>
       /// <returns>A Bezier spline.</returns>
       public static Spline CreateBezier(Float3[] points)
       {
           if ((points.Length - 1) % 3 != 0)
               throw new ArgumentException("Bezier splines require 3n+1 control points for n segments");

           return new Spline(points, SplineType.Bezier, false);
       }

       /// <summary>
       /// Creates a uniform cubic B-spline from the given points.
       /// </summary>
       /// <param name="points">The control points.</param>
       /// <param name="closed">Whether the spline should be closed.</param>
       /// <returns>A B-spline.</returns>
       public static Spline CreateBSpline(Float3[] points, bool closed = false)
       {
           return new Spline(points, SplineType.BSpline, closed);
       }

       /// <summary>
       /// Creates a Hermite spline with automatic tangent generation.
       /// </summary>
       /// <param name="points">The control points.</param>
       /// <param name="closed">Whether the spline should be closed.</param>
       /// <returns>A Hermite spline with auto-generated tangents.</returns>
       public static Spline CreateHermite(Float3[] points, bool closed = false)
       {
           return new Spline(points, SplineType.Hermite, closed);
       }

       /// <summary>
       /// Creates a Hermite spline with explicit tangents.
       /// </summary>
       /// <param name="points">The control points.</param>
       /// <param name="tangents">The tangent vectors at each control point.</param>
       /// <param name="closed">Whether the spline should be closed.</param>
       /// <returns>A Hermite spline with specified tangents.</returns>
       public static Spline CreateHermiteWithTangents(Float3[] points, Float3[] tangents, bool closed = false)
       {
           return new Spline(points, tangents, closed);
       }

       /// <summary>
       /// Creates a circular arc as a spline.
       /// </summary>
       /// <param name="center">Center of the circle.</param>
       /// <param name="radius">Radius of the circle.</param>
       /// <param name="startAngle">Start angle in radians.</param>
       /// <param name="endAngle">End angle in radians.</param>
       /// <param name="segments">Number of segments to approximate the arc.</param>
       /// <returns>A spline approximating the circular arc.</returns>
       public static Spline CreateCircularArc(Float3 center, float radius, float startAngle, float endAngle, int segments = 16)
       {
           var points = new Float3[segments + 1];
           float angleStep = (endAngle - startAngle) / segments;

           for (int i = 0; i <= segments; i++)
           {
               float angle = startAngle + i * angleStep;
               points[i] = center + new Float3(
                   radius * Maths.Cos(angle),
                   radius * Maths.Sin(angle),
                   0f
               );
           }

           return CreateCatmullRom(points);
       }

       /// <summary>
       /// Creates a helix spline.
       /// </summary>
       /// <param name="center">Center axis of the helix.</param>
       /// <param name="radius">Radius of the helix.</param>
       /// <param name="pitch">Vertical distance per revolution.</param>
       /// <param name="turns">Number of turns.</param>
       /// <param name="segments">Number of segments per turn.</param>
       /// <returns>A spline representing a helix.</returns>
       public static Spline CreateHelix(Float3 center, float radius, float pitch, float turns, int segments = 16)
       {
           int totalPoints = (int)(segments * turns) + 1;
           var points = new Float3[totalPoints];
           float angleStep = 2f * (float)Maths.PI / segments;
           float heightStep = pitch / segments;

           for (int i = 0; i < totalPoints; i++)
           {
               float angle = i * angleStep;
               float height = i * heightStep;
               points[i] = center + new Float3(
                   radius * Maths.Cos(angle),
                   radius * Maths.Sin(angle),
                   height
               );
           }

           return CreateCatmullRom(points);
       }

       #endregion

       // --- IEquatable & IFormattable Implementation ---
       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public bool Equals(Spline other)
       {
           if (Type != other.Type || IsClosed != other.IsClosed || !Tension.Equals(other.Tension))
               return false;

           if (ControlPoints?.Length != other.ControlPoints?.Length)
               return false;

           if (ControlPoints != null)
           {
               for (int i = 0; i < ControlPoints.Length; i++)
               {
                   if (!ControlPoints[i].Equals(other.ControlPoints[i]))
                       return false;
               }
           }

           if (Tangents?.Length != other.Tangents?.Length)
               return false;

           if (Tangents != null)
           {
               for (int i = 0; i < Tangents.Length; i++)
               {
                   if (!Tangents[i].Equals(other.Tangents[i]))
                       return false;
               }
           }

           return true;
       }

       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public override bool Equals(object? obj) => obj is Spline other && Equals(other);

       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public override int GetHashCode()
       {
           var hash = new HashCode();
           hash.Add(Type);
           hash.Add(IsClosed);
           hash.Add(Tension);
           
           if (ControlPoints != null)
           {
               foreach (var point in ControlPoints)
                   hash.Add(point);
           }
           
           return hash.ToHashCode();
       }

       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public override string ToString() => ToString(null, CultureInfo.CurrentCulture);

       [MethodImpl(MethodImplOptions.AggressiveInlining)]
       public string ToString(string? format, IFormatProvider? formatProvider = null)
       {
           return string.Format(formatProvider, "Spline(Type: {0}, Points: {1}, Closed: {2})", 
               Type, ControlPointCount, IsClosed);
       }

       public static bool operator ==(Spline left, Spline right) => left.Equals(right);
       public static bool operator !=(Spline left, Spline right) => !left.Equals(right);
   }
}
