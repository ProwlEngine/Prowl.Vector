//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-05-14 12:02:28
//

using System;
using System.Runtime.CompilerServices;

namespace Prowl.Vector
{
    /// <summary>
    /// A static class containing mathematical functions for vectors and scalars.
    /// </summary>
    public static partial class Maths
    {

        // Abs functions
        /// <summary>Returns the abs of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Abs(float x) { return MathF.Abs(x); }
        /// <summary>Returns the abs of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Abs(double x) { return Math.Abs(x); }
        /// <summary>Returns the abs of int x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Abs(int x) { return Math.Abs(x); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Abs(Float2 x) { return new Float2(Abs(x.X), Abs(x.Y)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Abs(Float3 x) { return new Float3(Abs(x.X), Abs(x.Y), Abs(x.Z)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Abs(Float4 x) { return new Float4(Abs(x.X), Abs(x.Y), Abs(x.Z), Abs(x.W)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Abs(Double2 x) { return new Double2(Abs(x.X), Abs(x.Y)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Abs(Double3 x) { return new Double3(Abs(x.X), Abs(x.Y), Abs(x.Z)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Abs(Double4 x) { return new Double4(Abs(x.X), Abs(x.Y), Abs(x.Z), Abs(x.W)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Abs(Int2 x) { return new Int2(Abs(x.X), Abs(x.Y)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Abs(Int3 x) { return new Int3(Abs(x.X), Abs(x.Y), Abs(x.Z)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Abs(Int4 x) { return new Int4(Abs(x.X), Abs(x.Y), Abs(x.Z), Abs(x.W)); }
        // Acos functions
        /// <summary>Returns the acos of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Acos(float x) { return MathF.Acos(x); }
        /// <summary>Returns the acos of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Acos(double x) { return Math.Acos(x); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Acos(Float2 x) { return new Float2(Acos(x.X), Acos(x.Y)); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Acos(Float3 x) { return new Float3(Acos(x.X), Acos(x.Y), Acos(x.Z)); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Acos(Float4 x) { return new Float4(Acos(x.X), Acos(x.Y), Acos(x.Z), Acos(x.W)); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Acos(Double2 x) { return new Double2(Acos(x.X), Acos(x.Y)); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Acos(Double3 x) { return new Double3(Acos(x.X), Acos(x.Y), Acos(x.Z)); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Acos(Double4 x) { return new Double4(Acos(x.X), Acos(x.Y), Acos(x.Z), Acos(x.W)); }
        // AngleBetween functions
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float AngleBetween(Float2 a, Float2 b)
        {
            float dot = Dot(Normalize(a), Normalize(b));
            return MathF.Acos(Clamp(dot, -1f, 1f));
        }
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float AngleBetween(Float3 a, Float3 b)
        {
            float dot = Dot(Normalize(a), Normalize(b));
            return MathF.Acos(Clamp(dot, -1f, 1f));
        }
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float AngleBetween(Float4 a, Float4 b)
        {
            float dot = Dot(Normalize(a), Normalize(b));
            return MathF.Acos(Clamp(dot, -1f, 1f));
        }
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double AngleBetween(Double2 a, Double2 b)
        {
            double dot = Dot(Normalize(a), Normalize(b));
            return Math.Acos(Clamp(dot, -1, 1));
        }
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double AngleBetween(Double3 a, Double3 b)
        {
            double dot = Dot(Normalize(a), Normalize(b));
            return Math.Acos(Clamp(dot, -1, 1));
        }
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double AngleBetween(Double4 a, Double4 b)
        {
            double dot = Dot(Normalize(a), Normalize(b));
            return Math.Acos(Clamp(dot, -1, 1));
        }
        // Asin functions
        /// <summary>Returns the asin of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Asin(float x) { return MathF.Asin(x); }
        /// <summary>Returns the asin of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Asin(double x) { return Math.Asin(x); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Asin(Float2 x) { return new Float2(Asin(x.X), Asin(x.Y)); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Asin(Float3 x) { return new Float3(Asin(x.X), Asin(x.Y), Asin(x.Z)); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Asin(Float4 x) { return new Float4(Asin(x.X), Asin(x.Y), Asin(x.Z), Asin(x.W)); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Asin(Double2 x) { return new Double2(Asin(x.X), Asin(x.Y)); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Asin(Double3 x) { return new Double3(Asin(x.X), Asin(x.Y), Asin(x.Z)); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Asin(Double4 x) { return new Double4(Asin(x.X), Asin(x.Y), Asin(x.Z), Asin(x.W)); }
        // Atan functions
        /// <summary>Returns the atan of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Atan(float x) { return MathF.Atan(x); }
        /// <summary>Returns the atan of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Atan(double x) { return Math.Atan(x); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Atan(Float2 x) { return new Float2(Atan(x.X), Atan(x.Y)); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Atan(Float3 x) { return new Float3(Atan(x.X), Atan(x.Y), Atan(x.Z)); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Atan(Float4 x) { return new Float4(Atan(x.X), Atan(x.Y), Atan(x.Z), Atan(x.W)); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Atan(Double2 x) { return new Double2(Atan(x.X), Atan(x.Y)); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Atan(Double3 x) { return new Double3(Atan(x.X), Atan(x.Y), Atan(x.Z)); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Atan(Double4 x) { return new Double4(Atan(x.X), Atan(x.Y), Atan(x.Z), Atan(x.W)); }
        // Atan2 functions
        /// <summary>Returns the arctangent of y/x in radians.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Atan2(float x, float y) { return MathF.Atan2(x, y); }
        /// <summary>Returns the arctangent of y/x in radians.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Atan2(double x, double y) { return Math.Atan2(x, y); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Atan2(Float2 x, Float2 y) { return new Float2(Atan2(x.X, y.X), Atan2(x.Y, y.Y)); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Atan2(Float3 x, Float3 y) { return new Float3(Atan2(x.X, y.X), Atan2(x.Y, y.Y), Atan2(x.Z, y.Z)); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Atan2(Float4 x, Float4 y) { return new Float4(Atan2(x.X, y.X), Atan2(x.Y, y.Y), Atan2(x.Z, y.Z), Atan2(x.W, y.W)); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Atan2(Double2 x, Double2 y) { return new Double2(Atan2(x.X, y.X), Atan2(x.Y, y.Y)); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Atan2(Double3 x, Double3 y) { return new Double3(Atan2(x.X, y.X), Atan2(x.Y, y.Y), Atan2(x.Z, y.Z)); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Atan2(Double4 x, Double4 y) { return new Double4(Atan2(x.X, y.X), Atan2(x.Y, y.Y), Atan2(x.Z, y.Z), Atan2(x.W, y.W)); }
        // Brightness functions
        /// <summary>Adjusts the brightness of a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Brightness(Float3 color, float brightness)
        {
            return new Float3(
                Max(0f, color.X * brightness),
                Max(0f, color.Y * brightness),
                Max(0f, color.Z * brightness)
            );
        }
        /// <summary>Adjusts the brightness of a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Brightness(Float4 color, float brightness)
        {
            return new Float4(
                Max(0f, color.X * brightness),
                Max(0f, color.Y * brightness),
                Max(0f, color.Z * brightness), color.W
            );
        }
        /// <summary>Adjusts the brightness of a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Brightness(Byte3 color, float brightness)
        {
            return new Byte3(
                (byte)Clamp(color.X * brightness, 0f, 255f),
                (byte)Clamp(color.Y * brightness, 0f, 255f),
                (byte)Clamp(color.Z * brightness, 0f, 255f)
            );
        }
        /// <summary>Adjusts the brightness of a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Brightness(Byte4 color, float brightness)
        {
            return new Byte4(
                (byte)Clamp(color.X * brightness, 0f, 255f),
                (byte)Clamp(color.Y * brightness, 0f, 255f),
                (byte)Clamp(color.Z * brightness, 0f, 255f), color.W
            );
        }
        // Ceiling functions
        /// <summary>Returns the ceiling of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Ceiling(float x) { return MathF.Ceiling(x); }
        /// <summary>Returns the ceiling of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Ceiling(double x) { return Math.Ceiling(x); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Ceiling(Float2 x) { return new Float2(Ceiling(x.X), Ceiling(x.Y)); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Ceiling(Float3 x) { return new Float3(Ceiling(x.X), Ceiling(x.Y), Ceiling(x.Z)); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Ceiling(Float4 x) { return new Float4(Ceiling(x.X), Ceiling(x.Y), Ceiling(x.Z), Ceiling(x.W)); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Ceiling(Double2 x) { return new Double2(Ceiling(x.X), Ceiling(x.Y)); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Ceiling(Double3 x) { return new Double3(Ceiling(x.X), Ceiling(x.Y), Ceiling(x.Z)); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Ceiling(Double4 x) { return new Double4(Ceiling(x.X), Ceiling(x.Y), Ceiling(x.Z), Ceiling(x.W)); }
        // CeilToInt functions
        /// <summary>Ceils a value to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CeilToInt(float x) { return (int)MathF.Ceiling(x); }
        /// <summary>Ceils a value to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CeilToInt(double x) { return (int)Math.Ceiling(x); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 CeilToInt(Float2 x) { return new Int2(CeilToInt(x.X), CeilToInt(x.Y)); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 CeilToInt(Float3 x) { return new Int3(CeilToInt(x.X), CeilToInt(x.Y), CeilToInt(x.Z)); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 CeilToInt(Float4 x) { return new Int4(CeilToInt(x.X), CeilToInt(x.Y), CeilToInt(x.Z), CeilToInt(x.W)); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 CeilToInt(Double2 x) { return new Int2(CeilToInt(x.X), CeilToInt(x.Y)); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 CeilToInt(Double3 x) { return new Int3(CeilToInt(x.X), CeilToInt(x.Y), CeilToInt(x.Z)); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 CeilToInt(Double4 x) { return new Int4(CeilToInt(x.X), CeilToInt(x.Y), CeilToInt(x.Z), CeilToInt(x.W)); }
        // Clamp functions
        /// <summary>Clamps float x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Clamp(float x, float min, float max) { return (float)Math.Clamp(x, min, max); }
        /// <summary>Clamps double x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Clamp(double x, double min, double max) { return (double)Math.Clamp(x, min, max); }
        /// <summary>Clamps int x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Clamp(int x, int min, int max) { return (int)Math.Clamp(x, min, max); }
        /// <summary>Clamps byte x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte Clamp(byte x, byte min, byte max) { return (byte)Math.Clamp(x, min, max); }
        /// <summary>Clamps ushort x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Clamp(ushort x, ushort min, ushort max) { return (ushort)Math.Clamp(x, min, max); }
        /// <summary>Clamps uint x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Clamp(uint x, uint min, uint max) { return (uint)Math.Clamp(x, min, max); }
        /// <summary>Clamps ulong x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Clamp(ulong x, ulong min, ulong max) { return (ulong)Math.Clamp(x, min, max); }
        /// <summary>Returns the componentwise clamp of a Float2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Clamp(Float2 x, Float2 min, Float2 max) { return new Float2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a Float2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Clamp(Float2 x, float min, float max) { return new Float2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a Float3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Clamp(Float3 x, Float3 min, Float3 max) { return new Float3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a Float3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Clamp(Float3 x, float min, float max) { return new Float3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a Float4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Clamp(Float4 x, Float4 min, Float4 max) { return new Float4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a Float4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Clamp(Float4 x, float min, float max) { return new Float4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a Double2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Clamp(Double2 x, Double2 min, Double2 max) { return new Double2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a Double2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Clamp(Double2 x, double min, double max) { return new Double2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a Double3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Clamp(Double3 x, Double3 min, Double3 max) { return new Double3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a Double3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Clamp(Double3 x, double min, double max) { return new Double3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a Double4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Clamp(Double4 x, Double4 min, Double4 max) { return new Double4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a Double4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Clamp(Double4 x, double min, double max) { return new Double4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a Int2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Clamp(Int2 x, Int2 min, Int2 max) { return new Int2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a Int2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Clamp(Int2 x, int min, int max) { return new Int2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a Int3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Clamp(Int3 x, Int3 min, Int3 max) { return new Int3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a Int3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Clamp(Int3 x, int min, int max) { return new Int3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a Int4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Clamp(Int4 x, Int4 min, Int4 max) { return new Int4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a Int4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Clamp(Int4 x, int min, int max) { return new Int4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a Byte2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Clamp(Byte2 x, Byte2 min, Byte2 max) { return new Byte2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a Byte2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Clamp(Byte2 x, byte min, byte max) { return new Byte2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a Byte3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Clamp(Byte3 x, Byte3 min, Byte3 max) { return new Byte3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a Byte3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Clamp(Byte3 x, byte min, byte max) { return new Byte3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a Byte4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Clamp(Byte4 x, Byte4 min, Byte4 max) { return new Byte4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a Byte4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Clamp(Byte4 x, byte min, byte max) { return new Byte4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a UShort2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Clamp(UShort2 x, UShort2 min, UShort2 max) { return new UShort2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a UShort2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Clamp(UShort2 x, ushort min, ushort max) { return new UShort2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a UShort3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Clamp(UShort3 x, UShort3 min, UShort3 max) { return new UShort3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a UShort3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Clamp(UShort3 x, ushort min, ushort max) { return new UShort3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a UShort4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Clamp(UShort4 x, UShort4 min, UShort4 max) { return new UShort4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a UShort4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Clamp(UShort4 x, ushort min, ushort max) { return new UShort4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a UInt2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Clamp(UInt2 x, UInt2 min, UInt2 max) { return new UInt2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a UInt2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Clamp(UInt2 x, uint min, uint max) { return new UInt2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a UInt3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Clamp(UInt3 x, UInt3 min, UInt3 max) { return new UInt3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a UInt3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Clamp(UInt3 x, uint min, uint max) { return new UInt3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a UInt4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Clamp(UInt4 x, UInt4 min, UInt4 max) { return new UInt4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a UInt4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Clamp(UInt4 x, uint min, uint max) { return new UInt4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a ULong2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Clamp(ULong2 x, ULong2 min, ULong2 max) { return new ULong2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a ULong2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Clamp(ULong2 x, ulong min, ulong max) { return new ULong2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a ULong3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Clamp(ULong3 x, ULong3 min, ULong3 max) { return new ULong3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a ULong3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Clamp(ULong3 x, ulong min, ulong max) { return new ULong3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a ULong4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Clamp(ULong4 x, ULong4 min, ULong4 max) { return new ULong4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a ULong4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Clamp(ULong4 x, ulong min, ulong max) { return new ULong4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        // ColorLerp functions
        /// <summary>Performs color-space aware linear interpolation between two RGB colors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 ColorLerp(Float3 from, Float3 to, float t)
        {
            // Convert to HSV for more natural color interpolation
            var hsvFrom = RGBToHSV(from);
            var hsvTo = RGBToHSV(to);

            // Handle hue wrapping for shortest path interpolation
            float deltaHue = hsvTo.X - hsvFrom.X;
            if (deltaHue > 180f)
                hsvFrom.X += 360f;
            else if (deltaHue < -180f)
                hsvTo.X += 360f;

            // Interpolate in HSV space
            var hsvResult = new Float3(
                hsvFrom.X + (hsvTo.X - hsvFrom.X) * t,
                hsvFrom.Y + (hsvTo.Y - hsvFrom.Y) * t,
                hsvFrom.Z + (hsvTo.Z - hsvFrom.Z) * t
            );

            // Wrap hue back to 0-360 range
            if (hsvResult.X < 0f) hsvResult.X += 360f;
            if (hsvResult.X >= 360f) hsvResult.X -= 360f;

            // Convert back to RGB
            return HSVToRGB(hsvResult);
        }
        /// <summary>Performs color-space aware linear interpolation between two RGB colors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 ColorLerp(Float4 from, Float4 to, float t)
        {
            // Convert to HSV for more natural color interpolation
            var hsvFrom = RGBToHSV(from);
            var hsvTo = RGBToHSV(to);

            // Handle hue wrapping for shortest path interpolation
            float deltaHue = hsvTo.X - hsvFrom.X;
            if (deltaHue > 180f)
                hsvFrom.X += 360f;
            else if (deltaHue < -180f)
                hsvTo.X += 360f;

            // Interpolate in HSV space
            var hsvResult = new Float4(
                hsvFrom.X + (hsvTo.X - hsvFrom.X) * t,
                hsvFrom.Y + (hsvTo.Y - hsvFrom.Y) * t,
                hsvFrom.Z + (hsvTo.Z - hsvFrom.Z) * t,
                hsvFrom.W + (hsvTo.W - hsvFrom.W) * t
            );

            // Wrap hue back to 0-360 range
            if (hsvResult.X < 0f) hsvResult.X += 360f;
            if (hsvResult.X >= 360f) hsvResult.X -= 360f;

            // Convert back to RGB
            return HSVToRGB(hsvResult);
        }
        /// <summary>Performs color-space aware linear interpolation between two RGB colors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 ColorLerp(Byte3 from, Byte3 to, float t)
        {
            // Convert to HSV for more natural color interpolation
            var hsvFrom = RGBToHSV(from);
            var hsvTo = RGBToHSV(to);

            // Convert byte HSV values to float for interpolation
            float hFrom = hsvFrom.X * 360f / 255f;
            float sFrom = hsvFrom.Y / 255f;
            float vFrom = hsvFrom.Z / 255f;
            float aFrom = 0f;

            float hTo = hsvTo.X * 360f / 255f;
            float sTo = hsvTo.Y / 255f;
            float vTo = hsvTo.Z / 255f;
            float aTo = 0f;

            // Handle hue wrapping for shortest path interpolation
            float deltaHue = hTo - hFrom;
            if (deltaHue > 180f)
                hFrom += 360f;
            else if (deltaHue < -180f)
                hTo += 360f;

            // Interpolate in HSV space
            float hResult = hFrom + (hTo - hFrom) * t;
            float sResult = sFrom + (sTo - sFrom) * t;
            float vResult = vFrom + (vTo - vFrom) * t;
            

            // Wrap hue back to 0-360 range
            if (hResult < 0f) hResult += 360f;
            if (hResult >= 360f) hResult -= 360f;

            // Convert back to byte HSV format
            var hsvResult = new Byte3(
                (byte)(hResult * 255f / 360f),
                (byte)(sResult * 255f),
                (byte)(vResult * 255f)
            );

            // Convert back to RGB
            return HSVToRGB(hsvResult);
        }
        /// <summary>Performs color-space aware linear interpolation between two RGB colors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 ColorLerp(Byte4 from, Byte4 to, float t)
        {
            // Convert to HSV for more natural color interpolation
            var hsvFrom = RGBToHSV(from);
            var hsvTo = RGBToHSV(to);

            // Convert byte HSV values to float for interpolation
            float hFrom = hsvFrom.X * 360f / 255f;
            float sFrom = hsvFrom.Y / 255f;
            float vFrom = hsvFrom.Z / 255f;
            float aFrom = hsvFrom.W / 255f;

            float hTo = hsvTo.X * 360f / 255f;
            float sTo = hsvTo.Y / 255f;
            float vTo = hsvTo.Z / 255f;
            float aTo = hsvTo.W / 255f;

            // Handle hue wrapping for shortest path interpolation
            float deltaHue = hTo - hFrom;
            if (deltaHue > 180f)
                hFrom += 360f;
            else if (deltaHue < -180f)
                hTo += 360f;

            // Interpolate in HSV space
            float hResult = hFrom + (hTo - hFrom) * t;
            float sResult = sFrom + (sTo - sFrom) * t;
            float vResult = vFrom + (vTo - vFrom) * t;
            float aResult = aFrom + (aTo - aFrom) * t;

            // Wrap hue back to 0-360 range
            if (hResult < 0f) hResult += 360f;
            if (hResult >= 360f) hResult -= 360f;

            // Convert back to byte HSV format
            var hsvResult = new Byte4(
                (byte)(hResult * 255f / 360f),
                (byte)(sResult * 255f),
                (byte)(vResult * 255f),
                (byte)(aResult * 255f)
            );

            // Convert back to RGB
            return HSVToRGB(hsvResult);
        }
        // Contrast functions
        /// <summary>Adjusts the contrast of a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Contrast(Float3 color, float contrast)
        {
            const float midpoint = 0.5f;
            return new Float3(
                Clamp((color.X - midpoint) * contrast + midpoint, 0f, 1f),
                Clamp((color.Y - midpoint) * contrast + midpoint, 0f, 1f),
                Clamp((color.Z - midpoint) * contrast + midpoint, 0f, 1f)
            );
        }
        /// <summary>Adjusts the contrast of a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Contrast(Float4 color, float contrast)
        {
            const float midpoint = 0.5f;
            return new Float4(
                Clamp((color.X - midpoint) * contrast + midpoint, 0f, 1f),
                Clamp((color.Y - midpoint) * contrast + midpoint, 0f, 1f),
                Clamp((color.Z - midpoint) * contrast + midpoint, 0f, 1f), color.W
            );
        }
        /// <summary>Adjusts the contrast of a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Contrast(Byte3 color, float contrast)
        {
            const float midpoint = 127.5f;
            return new Byte3(
                (byte)Clamp((color.X - midpoint) * contrast + midpoint, 0f, 255f),
                (byte)Clamp((color.Y - midpoint) * contrast + midpoint, 0f, 255f),
                (byte)Clamp((color.Z - midpoint) * contrast + midpoint, 0f, 255f)
            );
        }
        /// <summary>Adjusts the contrast of a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Contrast(Byte4 color, float contrast)
        {
            const float midpoint = 127.5f;
            return new Byte4(
                (byte)Clamp((color.X - midpoint) * contrast + midpoint, 0f, 255f),
                (byte)Clamp((color.Y - midpoint) * contrast + midpoint, 0f, 255f),
                (byte)Clamp((color.Z - midpoint) * contrast + midpoint, 0f, 255f), color.W
            );
        }
        // Cos functions
        /// <summary>Returns the cos of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Cos(float x) { return MathF.Cos(x); }
        /// <summary>Returns the cos of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Cos(double x) { return Math.Cos(x); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Cos(Float2 x) { return new Float2(Cos(x.X), Cos(x.Y)); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Cos(Float3 x) { return new Float3(Cos(x.X), Cos(x.Y), Cos(x.Z)); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Cos(Float4 x) { return new Float4(Cos(x.X), Cos(x.Y), Cos(x.Z), Cos(x.W)); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Cos(Double2 x) { return new Double2(Cos(x.X), Cos(x.Y)); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Cos(Double3 x) { return new Double3(Cos(x.X), Cos(x.Y), Cos(x.Z)); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Cos(Double4 x) { return new Double4(Cos(x.X), Cos(x.Y), Cos(x.Z), Cos(x.W)); }
        // Cross functions
        /// <summary>Returns the cross product of two Float3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Cross(Float3 x, Float3 y)
        {
            return new Float3(
                x.Y * y.Z - x.Z * y.Y,
                x.Z * y.X - x.X * y.Z,
                x.X * y.Y - x.Y * y.X
            );
        }
        /// <summary>Returns the cross product of two Double3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Cross(Double3 x, Double3 y)
        {
            return new Double3(
                x.Y * y.Z - x.Z * y.Y,
                x.Z * y.X - x.X * y.Z,
                x.X * y.Y - x.Y * y.X
            );
        }
        // DeltaAngle functions
        /// <summary>Calculates the shortest angle between two angles.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DeltaAngle(float current, float target)
        {
            float delta = Repeat(target - current, 2f * MathF.PI);
            if (delta > MathF.PI)
                delta -= 2f * MathF.PI;
            return delta;
        }
        /// <summary>Calculates the shortest angle between two angles.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DeltaAngle(double current, double target)
        {
            double delta = Repeat(target - current, 2 * Math.PI);
            if (delta > Math.PI)
                delta -= 2 * Math.PI;
            return delta;
        }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 DeltaAngle(Float2 current, Float2 target) { return new Float2(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y)); }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 DeltaAngle(Float3 current, Float3 target) { return new Float3(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y), DeltaAngle(current.Z, target.Z)); }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 DeltaAngle(Float4 current, Float4 target) { return new Float4(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y), DeltaAngle(current.Z, target.Z), DeltaAngle(current.W, target.W)); }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 DeltaAngle(Double2 current, Double2 target) { return new Double2(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y)); }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 DeltaAngle(Double3 current, Double3 target) { return new Double3(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y), DeltaAngle(current.Z, target.Z)); }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 DeltaAngle(Double4 current, Double4 target) { return new Double4(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y), DeltaAngle(current.Z, target.Z), DeltaAngle(current.W, target.W)); }
        // Desaturate functions
        /// <summary>Desaturates a color by blending it towards grayscale.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Desaturate(Float3 color, float amount = 1f)
        {
            // Standard luminance weights for RGB
            float luminance = 0.299f * color.X + 0.587f * color.Y + 0.114f * color.Z;
            var gray = new Float3(luminance, luminance, luminance);
            amount = Clamp(amount, 0f, 1f);
            return color + (gray - color) * amount;
        }
        /// <summary>Desaturates a color by blending it towards grayscale.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Desaturate(Float4 color, float amount = 1f)
        {
            // Standard luminance weights for RGB
            float luminance = 0.299f * color.X + 0.587f * color.Y + 0.114f * color.Z;
            var gray = new Float4(luminance, luminance, luminance, color.W);
            amount = Clamp(amount, 0f, 1f);
            return color + (gray - color) * amount;
        }
        /// <summary>Desaturates a color by blending it towards grayscale.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Desaturate(Byte3 color, float amount = 1f)
        {
            // Standard luminance weights for RGB
            float luminance = 0.299f * color.X + 0.587f * color.Y + 0.114f * color.Z;
            byte grayByte = (byte)Clamp(luminance, 0f, 255f);
            var gray = new Byte3(grayByte, grayByte, grayByte);
            
            amount = Clamp(amount, 0f, 1f);
            return new Byte3(
                (byte)(color.X + (gray.X - color.X) * amount),
                (byte)(color.Y + (gray.Y - color.Y) * amount),
                (byte)(color.Z + (gray.Z - color.Z) * amount)
            );
        }
        /// <summary>Desaturates a color by blending it towards grayscale.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Desaturate(Byte4 color, float amount = 1f)
        {
            // Standard luminance weights for RGB
            float luminance = 0.299f * color.X + 0.587f * color.Y + 0.114f * color.Z;
            byte grayByte = (byte)Clamp(luminance, 0f, 255f);
            var gray = new Byte4(grayByte, grayByte, grayByte, color.W);
            
            amount = Clamp(amount, 0f, 1f);
            return new Byte4(
                (byte)(color.X + (gray.X - color.X) * amount),
                (byte)(color.Y + (gray.Y - color.Y) * amount),
                (byte)(color.Z + (gray.Z - color.Z) * amount), color.W
            );
        }
        // Distance functions
        /// <summary>Returns the distance between two Float2 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Distance(Float2 x, Float2 y)
        {
            return Length(x - y);
        }
        /// <summary>Returns the distance between two Float3 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Distance(Float3 x, Float3 y)
        {
            return Length(x - y);
        }
        /// <summary>Returns the distance between two Float4 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Distance(Float4 x, Float4 y)
        {
            return Length(x - y);
        }
        /// <summary>Returns the distance between two Double2 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Distance(Double2 x, Double2 y)
        {
            return Length(x - y);
        }
        /// <summary>Returns the distance between two Double3 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Distance(Double3 x, Double3 y)
        {
            return Length(x - y);
        }
        /// <summary>Returns the distance between two Double4 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Distance(Double4 x, Double4 y)
        {
            return Length(x - y);
        }
        // DistanceSquared functions
        /// <summary>Returns the squared distance between two Float2 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DistanceSquared(Float2 x, Float2 y)
        {
            return LengthSquared(x - y);
        }
        /// <summary>Returns the squared distance between two Float3 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DistanceSquared(Float3 x, Float3 y)
        {
            return LengthSquared(x - y);
        }
        /// <summary>Returns the squared distance between two Float4 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DistanceSquared(Float4 x, Float4 y)
        {
            return LengthSquared(x - y);
        }
        /// <summary>Returns the squared distance between two Double2 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DistanceSquared(Double2 x, Double2 y)
        {
            return LengthSquared(x - y);
        }
        /// <summary>Returns the squared distance between two Double3 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DistanceSquared(Double3 x, Double3 y)
        {
            return LengthSquared(x - y);
        }
        /// <summary>Returns the squared distance between two Double4 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DistanceSquared(Double4 x, Double4 y)
        {
            return LengthSquared(x - y);
        }
        // Dot functions
        /// <summary>Returns the dot product of two Float2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Dot(Float2 x, Float2 y) { return x.X * y.X + x.Y * y.Y; }
        /// <summary>Returns the dot product of two Float3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Dot(Float3 x, Float3 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z; }
        /// <summary>Returns the dot product of two Float4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Dot(Float4 x, Float4 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z + x.W * y.W; }
        /// <summary>Returns the dot product of two Double2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Dot(Double2 x, Double2 y) { return x.X * y.X + x.Y * y.Y; }
        /// <summary>Returns the dot product of two Double3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Dot(Double3 x, Double3 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z; }
        /// <summary>Returns the dot product of two Double4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Dot(Double4 x, Double4 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z + x.W * y.W; }
        /// <summary>Returns the dot product of two Int2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Dot(Int2 x, Int2 y) { return x.X * y.X + x.Y * y.Y; }
        /// <summary>Returns the dot product of two Int3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Dot(Int3 x, Int3 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z; }
        /// <summary>Returns the dot product of two Int4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Dot(Int4 x, Int4 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z + x.W * y.W; }
        // Exp functions
        /// <summary>Returns e raised to the power of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Exp(float x) { return MathF.Exp(x); }
        /// <summary>Returns e raised to the power of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Exp(double x) { return Math.Exp(x); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Exp(Float2 x) { return new Float2(Exp(x.X), Exp(x.Y)); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Exp(Float3 x) { return new Float3(Exp(x.X), Exp(x.Y), Exp(x.Z)); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Exp(Float4 x) { return new Float4(Exp(x.X), Exp(x.Y), Exp(x.Z), Exp(x.W)); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Exp(Double2 x) { return new Double2(Exp(x.X), Exp(x.Y)); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Exp(Double3 x) { return new Double3(Exp(x.X), Exp(x.Y), Exp(x.Z)); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Exp(Double4 x) { return new Double4(Exp(x.X), Exp(x.Y), Exp(x.Z), Exp(x.W)); }
        // Exp2 functions
        /// <summary>Returns 2 raised to the power of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Exp2(float x) { return MathF.Pow(2f, x); }
        /// <summary>Returns 2 raised to the power of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Exp2(double x) { return Math.Pow(2, x); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Exp2(Float2 x) { return new Float2(Exp2(x.X), Exp2(x.Y)); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Exp2(Float3 x) { return new Float3(Exp2(x.X), Exp2(x.Y), Exp2(x.Z)); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Exp2(Float4 x) { return new Float4(Exp2(x.X), Exp2(x.Y), Exp2(x.Z), Exp2(x.W)); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Exp2(Double2 x) { return new Double2(Exp2(x.X), Exp2(x.Y)); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Exp2(Double3 x) { return new Double3(Exp2(x.X), Exp2(x.Y), Exp2(x.Z)); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Exp2(Double4 x) { return new Double4(Exp2(x.X), Exp2(x.Y), Exp2(x.Z), Exp2(x.W)); }
        // Floor functions
        /// <summary>Returns the floor of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Floor(float x) { return MathF.Floor(x); }
        /// <summary>Returns the floor of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Floor(double x) { return Math.Floor(x); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Floor(Float2 x) { return new Float2(Floor(x.X), Floor(x.Y)); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Floor(Float3 x) { return new Float3(Floor(x.X), Floor(x.Y), Floor(x.Z)); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Floor(Float4 x) { return new Float4(Floor(x.X), Floor(x.Y), Floor(x.Z), Floor(x.W)); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Floor(Double2 x) { return new Double2(Floor(x.X), Floor(x.Y)); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Floor(Double3 x) { return new Double3(Floor(x.X), Floor(x.Y), Floor(x.Z)); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Floor(Double4 x) { return new Double4(Floor(x.X), Floor(x.Y), Floor(x.Z), Floor(x.W)); }
        // FloorToInt functions
        /// <summary>Floors a value to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int FloorToInt(float x) { return (int)MathF.Floor(x); }
        /// <summary>Floors a value to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int FloorToInt(double x) { return (int)Math.Floor(x); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 FloorToInt(Float2 x) { return new Int2(FloorToInt(x.X), FloorToInt(x.Y)); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 FloorToInt(Float3 x) { return new Int3(FloorToInt(x.X), FloorToInt(x.Y), FloorToInt(x.Z)); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 FloorToInt(Float4 x) { return new Int4(FloorToInt(x.X), FloorToInt(x.Y), FloorToInt(x.Z), FloorToInt(x.W)); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 FloorToInt(Double2 x) { return new Int2(FloorToInt(x.X), FloorToInt(x.Y)); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 FloorToInt(Double3 x) { return new Int3(FloorToInt(x.X), FloorToInt(x.Y), FloorToInt(x.Z)); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 FloorToInt(Double4 x) { return new Int4(FloorToInt(x.X), FloorToInt(x.Y), FloorToInt(x.Z), FloorToInt(x.W)); }
        // FMod functions
        /// <summary>Returns the floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float FMod(float x, float y) { return x % y; }
        /// <summary>Returns the floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double FMod(double x, double y) { return x % y; }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 FMod(Float2 x, Float2 y) { return new Float2(FMod(x.X, y.X), FMod(x.Y, y.Y)); }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 FMod(Float3 x, Float3 y) { return new Float3(FMod(x.X, y.X), FMod(x.Y, y.Y), FMod(x.Z, y.Z)); }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 FMod(Float4 x, Float4 y) { return new Float4(FMod(x.X, y.X), FMod(x.Y, y.Y), FMod(x.Z, y.Z), FMod(x.W, y.W)); }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 FMod(Double2 x, Double2 y) { return new Double2(FMod(x.X, y.X), FMod(x.Y, y.Y)); }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 FMod(Double3 x, Double3 y) { return new Double3(FMod(x.X, y.X), FMod(x.Y, y.Y), FMod(x.Z, y.Z)); }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 FMod(Double4 x, Double4 y) { return new Double4(FMod(x.X, y.X), FMod(x.Y, y.Y), FMod(x.Z, y.Z), FMod(x.W, y.W)); }
        // Frac functions
        /// <summary>Returns the fractional part of a number.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Frac(float x) { return x - Floor(x); }
        /// <summary>Returns the fractional part of a number.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Frac(double x) { return x - Floor(x); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Frac(Float2 x) { return new Float2(Frac(x.X), Frac(x.Y)); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Frac(Float3 x) { return new Float3(Frac(x.X), Frac(x.Y), Frac(x.Z)); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Frac(Float4 x) { return new Float4(Frac(x.X), Frac(x.Y), Frac(x.Z), Frac(x.W)); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Frac(Double2 x) { return new Double2(Frac(x.X), Frac(x.Y)); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Frac(Double3 x) { return new Double3(Frac(x.X), Frac(x.Y), Frac(x.Z)); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Frac(Double4 x) { return new Double4(Frac(x.X), Frac(x.Y), Frac(x.Z), Frac(x.W)); }
        // Gamma functions
        /// <summary>Applies gamma correction to a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Gamma(Float3 color, float gamma = 2.2f)
        {
            return new Float3(
                Pow(Max(0f, color.X), 1f / gamma),
                Pow(Max(0f, color.Y), 1f / gamma),
                Pow(Max(0f, color.Z), 1f / gamma)
            );
        }
        /// <summary>Applies gamma correction to a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Gamma(Float4 color, float gamma = 2.2f)
        {
            return new Float4(
                Pow(Max(0f, color.X), 1f / gamma),
                Pow(Max(0f, color.Y), 1f / gamma),
                Pow(Max(0f, color.Z), 1f / gamma), color.W
            );
        }
        /// <summary>Applies gamma correction to a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Gamma(Byte3 color, float gamma = 2.2f)
        {
            return new Byte3(
                (byte)(Pow(Max(0f, color.X / 255f), 1f / gamma) * 255f),
                (byte)(Pow(Max(0f, color.Y / 255f), 1f / gamma) * 255f),
                (byte)(Pow(Max(0f, color.Z / 255f), 1f / gamma) * 255f)
            );
        }
        /// <summary>Applies gamma correction to a color.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Gamma(Byte4 color, float gamma = 2.2f)
        {
            return new Byte4(
                (byte)(Pow(Max(0f, color.X / 255f), 1f / gamma) * 255f),
                (byte)(Pow(Max(0f, color.Y / 255f), 1f / gamma) * 255f),
                (byte)(Pow(Max(0f, color.Z / 255f), 1f / gamma) * 255f), color.W
            );
        }
        // GammaToLinear functions
        /// <summary>Converts a gamma space color to linear space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 GammaToLinear(Float3 gamma)
        {
            return new Float3(
                Pow(Max(0f, gamma.X), 2.2f),
                Pow(Max(0f, gamma.Y), 2.2f),
                Pow(Max(0f, gamma.Z), 2.2f)
            );
        }
        /// <summary>Converts a gamma space color to linear space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 GammaToLinear(Float4 gamma)
        {
            return new Float4(
                Pow(Max(0f, gamma.X), 2.2f),
                Pow(Max(0f, gamma.Y), 2.2f),
                Pow(Max(0f, gamma.Z), 2.2f), gamma.W
            );
        }
        /// <summary>Converts a gamma space color to linear space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 GammaToLinear(Byte3 gamma)
        {
            return new Byte3(
                (byte)(Pow(Max(0f, gamma.X / 255f), 2.2f) * 255f),
                (byte)(Pow(Max(0f, gamma.Y / 255f), 2.2f) * 255f),
                (byte)(Pow(Max(0f, gamma.Z / 255f), 2.2f) * 255f)
            );
        }
        /// <summary>Converts a gamma space color to linear space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 GammaToLinear(Byte4 gamma)
        {
            return new Byte4(
                (byte)(Pow(Max(0f, gamma.X / 255f), 2.2f) * 255f),
                (byte)(Pow(Max(0f, gamma.Y / 255f), 2.2f) * 255f),
                (byte)(Pow(Max(0f, gamma.Z / 255f), 2.2f) * 255f), gamma.W
            );
        }
        // HSLToRGB functions
        /// <summary>Converts HSL to RGB color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 HSLToRGB(Float3 hsl)
        {
            float h = hsl.X, s = hsl.Y, l = hsl.Z;

            if (s <= 0f)
            {
                float gray = l;
                return new Float3(gray, gray, gray);
            }

            float c = (1f - Abs(2f * l - 1f)) * s;
            float x = c * (1f - Abs((h / 60f) % 2f - 1f));
            float m = l - c / 2f;

            float r = 0f, g = 0f, b = 0f;

            if (h >= 0f && h < 60f)
                (r, g, b) = (c, x, 0f);
            else if (h >= 60f && h < 120f)
                (r, g, b) = (x, c, 0f);
            else if (h >= 120f && h < 180f)
                (r, g, b) = (0f, c, x);
            else if (h >= 180f && h < 240f)
                (r, g, b) = (0f, x, c);
            else if (h >= 240f && h < 300f)
                (r, g, b) = (x, 0f, c);
            else if (h >= 300f && h < 360f)
                (r, g, b) = (c, 0f, x);

            r += m; g += m; b += m;

            return new Float3(r, g, b);
        }
        /// <summary>Converts HSL to RGB color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 HSLToRGB(Float4 hsla)
        {
            float h = hsla.X, s = hsla.Y, l = hsla.Z;

            if (s <= 0f)
            {
                float gray = l;
                return new Float4(gray, gray, gray, hsla.W);
            }

            float c = (1f - Abs(2f * l - 1f)) * s;
            float x = c * (1f - Abs((h / 60f) % 2f - 1f));
            float m = l - c / 2f;

            float r = 0f, g = 0f, b = 0f;

            if (h >= 0f && h < 60f)
                (r, g, b) = (c, x, 0f);
            else if (h >= 60f && h < 120f)
                (r, g, b) = (x, c, 0f);
            else if (h >= 120f && h < 180f)
                (r, g, b) = (0f, c, x);
            else if (h >= 180f && h < 240f)
                (r, g, b) = (0f, x, c);
            else if (h >= 240f && h < 300f)
                (r, g, b) = (x, 0f, c);
            else if (h >= 300f && h < 360f)
                (r, g, b) = (c, 0f, x);

            r += m; g += m; b += m;

            return new Float4(r, g, b, hsla.W);
        }
        /// <summary>Converts HSL to RGB color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 HSLToRGB(Byte3 hsl)
        {
            float h = hsl.X * 360f / 255f, s = hsl.Y / 255f, l = hsl.Z / 255f;

            if (s <= 0f)
            {
                float gray = l * 255f;
                return new Byte3((byte)gray, (byte)gray, (byte)gray);
            }

            float c = (1f - Abs(2f * l - 1f)) * s;
            float x = c * (1f - Abs((h / 60f) % 2f - 1f));
            float m = l - c / 2f;

            float r = 0f, g = 0f, b = 0f;

            if (h >= 0f && h < 60f)
                (r, g, b) = (c, x, 0f);
            else if (h >= 60f && h < 120f)
                (r, g, b) = (x, c, 0f);
            else if (h >= 120f && h < 180f)
                (r, g, b) = (0f, c, x);
            else if (h >= 180f && h < 240f)
                (r, g, b) = (0f, x, c);
            else if (h >= 240f && h < 300f)
                (r, g, b) = (x, 0f, c);
            else if (h >= 300f && h < 360f)
                (r, g, b) = (c, 0f, x);

            r += m; g += m; b += m;

            return new Byte3((byte)(r * 255f), (byte)(g * 255f), (byte)(b * 255f));
        }
        /// <summary>Converts HSL to RGB color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 HSLToRGB(Byte4 hsla)
        {
            float h = hsla.X * 360f / 255f, s = hsla.Y / 255f, l = hsla.Z / 255f;

            if (s <= 0f)
            {
                float gray = l * 255f;
                return new Byte4((byte)gray, (byte)gray, (byte)gray, hsla.W);
            }

            float c = (1f - Abs(2f * l - 1f)) * s;
            float x = c * (1f - Abs((h / 60f) % 2f - 1f));
            float m = l - c / 2f;

            float r = 0f, g = 0f, b = 0f;

            if (h >= 0f && h < 60f)
                (r, g, b) = (c, x, 0f);
            else if (h >= 60f && h < 120f)
                (r, g, b) = (x, c, 0f);
            else if (h >= 120f && h < 180f)
                (r, g, b) = (0f, c, x);
            else if (h >= 180f && h < 240f)
                (r, g, b) = (0f, x, c);
            else if (h >= 240f && h < 300f)
                (r, g, b) = (x, 0f, c);
            else if (h >= 300f && h < 360f)
                (r, g, b) = (c, 0f, x);

            r += m; g += m; b += m;

            return new Byte4((byte)(r * 255f), (byte)(g * 255f), (byte)(b * 255f), hsla.W);
        }
        // HSVToRGB functions
        /// <summary>Converts HSV to RGB color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 HSVToRGB(Float3 hsv)
        {
            float h = hsv.X, s = hsv.Y, v = hsv.Z;
            
            if (s <= 0f)
            {
                float gray = v;
                return new Float3(gray, gray, gray);
            }

            float c = v * s;
            float x = c * (1f - Abs((h / 60f) % 2f - 1f));
            float m = v - c;

            float r = 0f, g = 0f, b = 0f;

            if (h >= 0f && h < 60f)
                (r, g, b) = (c, x, 0f);
            else if (h >= 60f && h < 120f)
                (r, g, b) = (x, c, 0f);
            else if (h >= 120f && h < 180f)
                (r, g, b) = (0f, c, x);
            else if (h >= 180f && h < 240f)
                (r, g, b) = (0f, x, c);
            else if (h >= 240f && h < 300f)
                (r, g, b) = (x, 0f, c);
            else if (h >= 300f && h < 360f)
                (r, g, b) = (c, 0f, x);

            r += m; g += m; b += m;

            return new Float3(r, g, b);
        }
        /// <summary>Converts HSV to RGB color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 HSVToRGB(Float4 hsva)
        {
            float h = hsva.X, s = hsva.Y, v = hsva.Z;
            
            if (s <= 0f)
            {
                float gray = v;
                return new Float4(gray, gray, gray, hsva.W);
            }

            float c = v * s;
            float x = c * (1f - Abs((h / 60f) % 2f - 1f));
            float m = v - c;

            float r = 0f, g = 0f, b = 0f;

            if (h >= 0f && h < 60f)
                (r, g, b) = (c, x, 0f);
            else if (h >= 60f && h < 120f)
                (r, g, b) = (x, c, 0f);
            else if (h >= 120f && h < 180f)
                (r, g, b) = (0f, c, x);
            else if (h >= 180f && h < 240f)
                (r, g, b) = (0f, x, c);
            else if (h >= 240f && h < 300f)
                (r, g, b) = (x, 0f, c);
            else if (h >= 300f && h < 360f)
                (r, g, b) = (c, 0f, x);

            r += m; g += m; b += m;

            return new Float4(r, g, b, hsva.W);
        }
        /// <summary>Converts HSV to RGB color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 HSVToRGB(Byte3 hsv)
        {
            float h = hsv.X * 360f / 255f, s = hsv.Y / 255f, v = hsv.Z / 255f;
            
            if (s <= 0f)
            {
                float gray = v * 255f;
                return new Byte3((byte)gray, (byte)gray, (byte)gray);
            }

            float c = v * s;
            float x = c * (1f - Abs((h / 60f) % 2f - 1f));
            float m = v - c;

            float r = 0f, g = 0f, b = 0f;

            if (h >= 0f && h < 60f)
                (r, g, b) = (c, x, 0f);
            else if (h >= 60f && h < 120f)
                (r, g, b) = (x, c, 0f);
            else if (h >= 120f && h < 180f)
                (r, g, b) = (0f, c, x);
            else if (h >= 180f && h < 240f)
                (r, g, b) = (0f, x, c);
            else if (h >= 240f && h < 300f)
                (r, g, b) = (x, 0f, c);
            else if (h >= 300f && h < 360f)
                (r, g, b) = (c, 0f, x);

            r += m; g += m; b += m;

            return new Byte3((byte)(r * 255f), (byte)(g * 255f), (byte)(b * 255f));
        }
        /// <summary>Converts HSV to RGB color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 HSVToRGB(Byte4 hsva)
        {
            float h = hsva.X * 360f / 255f, s = hsva.Y / 255f, v = hsva.Z / 255f;
            
            if (s <= 0f)
            {
                float gray = v * 255f;
                return new Byte4((byte)gray, (byte)gray, (byte)gray, hsva.W);
            }

            float c = v * s;
            float x = c * (1f - Abs((h / 60f) % 2f - 1f));
            float m = v - c;

            float r = 0f, g = 0f, b = 0f;

            if (h >= 0f && h < 60f)
                (r, g, b) = (c, x, 0f);
            else if (h >= 60f && h < 120f)
                (r, g, b) = (x, c, 0f);
            else if (h >= 120f && h < 180f)
                (r, g, b) = (0f, c, x);
            else if (h >= 180f && h < 240f)
                (r, g, b) = (0f, x, c);
            else if (h >= 240f && h < 300f)
                (r, g, b) = (x, 0f, c);
            else if (h >= 300f && h < 360f)
                (r, g, b) = (c, 0f, x);

            r += m; g += m; b += m;

            return new Byte4((byte)(r * 255f), (byte)(g * 255f), (byte)(b * 255f), hsva.W);
        }
        // inverse functions
        /// <summary>Returns the inverse of a Float2x2 matrix using analytical formulas.</summary>
        /// <param name="matrix">The matrix to invert.</param>
        /// <returns>The inverse matrix.</returns>
        /// <exception cref="ArgumentException">Thrown when the matrix is singular (non-invertible).</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x2 Inverse(Float2x2 matrix)
        {
            // 2x2 analytical inverse
            var a = matrix.c0.X; var b = matrix.c1.X;
            var c = matrix.c0.Y; var d = matrix.c1.Y;
            
            var det = a * d - b * c;
            if (MathF.Abs(det) <= 1e-6f)
                throw new ArgumentException("Matrix is singular and cannot be inverted.");
            
            var invDet = 1f / det;
            
            return new Float2x2(
                new Float2(d * invDet, -c * invDet),
                new Float2(-b * invDet, a * invDet)
            );
        }


        /// <summary>Returns the inverse of a Float3x3 matrix using analytical formulas.</summary>
        /// <param name="matrix">The matrix to invert.</param>
        /// <returns>The inverse matrix.</returns>
        /// <exception cref="ArgumentException">Thrown when the matrix is singular (non-invertible).</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x3 Inverse(Float3x3 matrix)
        {
            // 3x3 analytical inverse using cofactor expansion
            var m00 = matrix.c0.X; var m01 = matrix.c1.X; var m02 = matrix.c2.X;
            var m10 = matrix.c0.Y; var m11 = matrix.c1.Y; var m12 = matrix.c2.Y;
            var m20 = matrix.c0.Z; var m21 = matrix.c1.Z; var m22 = matrix.c2.Z;
            
            // Calculate determinant
            var det = m00 * (m11 * m22 - m12 * m21) -
                      m01 * (m10 * m22 - m12 * m20) +
                      m02 * (m10 * m21 - m11 * m20);
            
            if (MathF.Abs(det) <= 1e-6f)
                throw new ArgumentException("Matrix is singular and cannot be inverted.");
            
            var invDet = 1f / det;
            
            // Calculate cofactors and transpose (adjugate matrix)
            return new Float3x3(
                new Float3(
                    (m11 * m22 - m12 * m21) * invDet,  // c00
                    -(m10 * m22 - m12 * m20) * invDet, // c10
                    (m10 * m21 - m11 * m20) * invDet   // c20
                ),
                new Float3(
                    -(m01 * m22 - m02 * m21) * invDet, // c01
                    (m00 * m22 - m02 * m20) * invDet,  // c11
                    -(m00 * m21 - m01 * m20) * invDet  // c21
                ),
                new Float3(
                    (m01 * m12 - m02 * m11) * invDet,  // c02
                    -(m00 * m12 - m02 * m10) * invDet, // c12
                    (m00 * m11 - m01 * m10) * invDet   // c22
                )
            );
        }


        /// <summary>Returns the inverse of a Float4x4 matrix using analytical formulas.</summary>
        /// <param name="matrix">The matrix to invert.</param>
        /// <returns>The inverse matrix.</returns>
        /// <exception cref="ArgumentException">Thrown when the matrix is singular (non-invertible).</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x4 Inverse(Float4x4 matrix)
        {
            // 4x4 analytical inverse using cofactor expansion
            var m00 = matrix.c0.X; var m01 = matrix.c1.X; var m02 = matrix.c2.X; var m03 = matrix.c3.X;
            var m10 = matrix.c0.Y; var m11 = matrix.c1.Y; var m12 = matrix.c2.Y; var m13 = matrix.c3.Y;
            var m20 = matrix.c0.Z; var m21 = matrix.c1.Z; var m22 = matrix.c2.Z; var m23 = matrix.c3.Z;
            var m30 = matrix.c0.W; var m31 = matrix.c1.W; var m32 = matrix.c2.W; var m33 = matrix.c3.W;
            
            // Calculate minors for determinant calculation (cofactors of first row elements)
            // s0 is C00
            var s0 = m11 * (m22 * m33 - m23 * m32) - m12 * (m21 * m33 - m23 * m31) + m13 * (m21 * m32 - m22 * m31);
            // s1 is M01 (minor of m01), so C01 = -s1
            var s1 = m10 * (m22 * m33 - m23 * m32) - m12 * (m20 * m33 - m23 * m30) + m13 * (m20 * m32 - m22 * m30);
            // s2 is C02
            var s2 = m10 * (m21 * m33 - m23 * m31) - m11 * (m20 * m33 - m23 * m30) + m13 * (m20 * m31 - m21 * m30);
            // s3 is M03 (minor of m03), so C03 = -s3
            var s3 = m10 * (m21 * m32 - m22 * m31) - m11 * (m20 * m32 - m22 * m30) + m12 * (m20 * m31 - m21 * m30);
            
            var det = m00 * s0 - m01 * s1 + m02 * s2 - m03 * s3; // = m00*C00 + m01*C01 + m02*C02 + m03*C03
            
            if (MathF.Abs(det) <= 1e-6f)
                throw new ArgumentException("Matrix is singular and cannot be inverted.");
            
            var invDet = 1f / det;
            
            // Construct the inverse matrix (Adjugate / Determinant)
            // Element (i,j) of inverse is Cofactor(j,i) / det
            return new Float4x4(
                new Float4( // Column 0 of Inverse (M_inv_00, M_inv_10, M_inv_20, M_inv_30)
                    (s0) * invDet,    // C00 / det
                    (-s1) * invDet,    // C01 / det
                    (s2) * invDet,    // C02 / det
                    (-s3) * invDet     // C03 / det
                ),
                new Float4( // Column 1 of Inverse (M_inv_01, M_inv_11, M_inv_21, M_inv_31)
                    (-(m01 * (m22 * m33 - m23 * m32) - m02 * (m21 * m33 - m23 * m31) + m03 * (m21 * m32 - m22 * m31))) * invDet,    // C10 / det
                    ( (m00 * (m22 * m33 - m23 * m32) - m02 * (m20 * m33 - m23 * m30) + m03 * (m20 * m32 - m22 * m30))) * invDet,    // C11 / det
                    (-(m00 * (m21 * m33 - m23 * m31) - m01 * (m20 * m33 - m23 * m30) + m03 * (m20 * m31 - m21 * m30))) * invDet,    // C12 / det
                    ( (m00 * (m21 * m32 - m22 * m31) - m01 * (m20 * m32 - m22 * m30) + m02 * (m20 * m31 - m21 * m30))) * invDet     // C13 / det
                ),
                new Float4( // Column 2 of Inverse (M_inv_02, M_inv_12, M_inv_22, M_inv_32)
                    ( (m01 * (m12 * m33 - m13 * m32) - m02 * (m11 * m33 - m13 * m31) + m03 * (m11 * m32 - m12 * m31))) * invDet,    // C20 / det
                    (-(m00 * (m12 * m33 - m13 * m32) - m02 * (m10 * m33 - m13 * m30) + m03 * (m10 * m32 - m12 * m30))) * invDet,    // C21 / det
                    ( (m00 * (m11 * m33 - m13 * m31) - m01 * (m10 * m33 - m13 * m30) + m03 * (m10 * m31 - m11 * m30))) * invDet,    // C22 / det
                    (-(m00 * (m11 * m32 - m12 * m31) - m01 * (m10 * m32 - m12 * m30) + m02 * (m10 * m31 - m11 * m30))) * invDet     // C23 / det
                ),
                new Float4( // Column 3 of Inverse (M_inv_03, M_inv_13, M_inv_23, M_inv_33)
                    (-(m01 * (m12 * m23 - m13 * m22) - m02 * (m11 * m23 - m13 * m21) + m03 * (m11 * m22 - m12 * m21))) * invDet,    // C30 / det
                    ( (m00 * (m12 * m23 - m13 * m22) - m02 * (m10 * m23 - m13 * m20) + m03 * (m10 * m22 - m12 * m20))) * invDet,    // C31 / det
                    (-(m00 * (m11 * m23 - m13 * m21) - m01 * (m10 * m23 - m13 * m20) + m03 * (m10 * m21 - m11 * m20))) * invDet,    // C32 / det
                    ( (m00 * (m11 * m22 - m12 * m21) - m01 * (m10 * m22 - m12 * m20) + m02 * (m10 * m21 - m11 * m20))) * invDet     // C33 / det
                )
            );
        }





        /// <summary>Returns the inverse of a Double2x2 matrix using analytical formulas.</summary>
        /// <param name="matrix">The matrix to invert.</param>
        /// <returns>The inverse matrix.</returns>
        /// <exception cref="ArgumentException">Thrown when the matrix is singular (non-invertible).</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x2 Inverse(Double2x2 matrix)
        {
            // 2x2 analytical inverse
            var a = matrix.c0.X; var b = matrix.c1.X;
            var c = matrix.c0.Y; var d = matrix.c1.Y;
            
            var det = a * d - b * c;
            if (Math.Abs(det) <= 1e-14)
                throw new ArgumentException("Matrix is singular and cannot be inverted.");
            
            var invDet = 1.0 / det;
            
            return new Double2x2(
                new Double2(d * invDet, -c * invDet),
                new Double2(-b * invDet, a * invDet)
            );
        }


        /// <summary>Returns the inverse of a Double3x3 matrix using analytical formulas.</summary>
        /// <param name="matrix">The matrix to invert.</param>
        /// <returns>The inverse matrix.</returns>
        /// <exception cref="ArgumentException">Thrown when the matrix is singular (non-invertible).</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x3 Inverse(Double3x3 matrix)
        {
            // 3x3 analytical inverse using cofactor expansion
            var m00 = matrix.c0.X; var m01 = matrix.c1.X; var m02 = matrix.c2.X;
            var m10 = matrix.c0.Y; var m11 = matrix.c1.Y; var m12 = matrix.c2.Y;
            var m20 = matrix.c0.Z; var m21 = matrix.c1.Z; var m22 = matrix.c2.Z;
            
            // Calculate determinant
            var det = m00 * (m11 * m22 - m12 * m21) -
                      m01 * (m10 * m22 - m12 * m20) +
                      m02 * (m10 * m21 - m11 * m20);
            
            if (Math.Abs(det) <= 1e-14)
                throw new ArgumentException("Matrix is singular and cannot be inverted.");
            
            var invDet = 1.0 / det;
            
            // Calculate cofactors and transpose (adjugate matrix)
            return new Double3x3(
                new Double3(
                    (m11 * m22 - m12 * m21) * invDet,  // c00
                    -(m10 * m22 - m12 * m20) * invDet, // c10
                    (m10 * m21 - m11 * m20) * invDet   // c20
                ),
                new Double3(
                    -(m01 * m22 - m02 * m21) * invDet, // c01
                    (m00 * m22 - m02 * m20) * invDet,  // c11
                    -(m00 * m21 - m01 * m20) * invDet  // c21
                ),
                new Double3(
                    (m01 * m12 - m02 * m11) * invDet,  // c02
                    -(m00 * m12 - m02 * m10) * invDet, // c12
                    (m00 * m11 - m01 * m10) * invDet   // c22
                )
            );
        }


        /// <summary>Returns the inverse of a Double4x4 matrix using analytical formulas.</summary>
        /// <param name="matrix">The matrix to invert.</param>
        /// <returns>The inverse matrix.</returns>
        /// <exception cref="ArgumentException">Thrown when the matrix is singular (non-invertible).</exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x4 Inverse(Double4x4 matrix)
        {
            // 4x4 analytical inverse using cofactor expansion
            var m00 = matrix.c0.X; var m01 = matrix.c1.X; var m02 = matrix.c2.X; var m03 = matrix.c3.X;
            var m10 = matrix.c0.Y; var m11 = matrix.c1.Y; var m12 = matrix.c2.Y; var m13 = matrix.c3.Y;
            var m20 = matrix.c0.Z; var m21 = matrix.c1.Z; var m22 = matrix.c2.Z; var m23 = matrix.c3.Z;
            var m30 = matrix.c0.W; var m31 = matrix.c1.W; var m32 = matrix.c2.W; var m33 = matrix.c3.W;
            
            // Calculate minors for determinant calculation (cofactors of first row elements)
            // s0 is C00
            var s0 = m11 * (m22 * m33 - m23 * m32) - m12 * (m21 * m33 - m23 * m31) + m13 * (m21 * m32 - m22 * m31);
            // s1 is M01 (minor of m01), so C01 = -s1
            var s1 = m10 * (m22 * m33 - m23 * m32) - m12 * (m20 * m33 - m23 * m30) + m13 * (m20 * m32 - m22 * m30);
            // s2 is C02
            var s2 = m10 * (m21 * m33 - m23 * m31) - m11 * (m20 * m33 - m23 * m30) + m13 * (m20 * m31 - m21 * m30);
            // s3 is M03 (minor of m03), so C03 = -s3
            var s3 = m10 * (m21 * m32 - m22 * m31) - m11 * (m20 * m32 - m22 * m30) + m12 * (m20 * m31 - m21 * m30);
            
            var det = m00 * s0 - m01 * s1 + m02 * s2 - m03 * s3; // = m00*C00 + m01*C01 + m02*C02 + m03*C03
            
            if (Math.Abs(det) <= 1e-14)
                throw new ArgumentException("Matrix is singular and cannot be inverted.");
            
            var invDet = 1.0 / det;
            
            // Construct the inverse matrix (Adjugate / Determinant)
            // Element (i,j) of inverse is Cofactor(j,i) / det
            return new Double4x4(
                new Double4( // Column 0 of Inverse (M_inv_00, M_inv_10, M_inv_20, M_inv_30)
                    (s0) * invDet,    // C00 / det
                    (-s1) * invDet,    // C01 / det
                    (s2) * invDet,    // C02 / det
                    (-s3) * invDet     // C03 / det
                ),
                new Double4( // Column 1 of Inverse (M_inv_01, M_inv_11, M_inv_21, M_inv_31)
                    (-(m01 * (m22 * m33 - m23 * m32) - m02 * (m21 * m33 - m23 * m31) + m03 * (m21 * m32 - m22 * m31))) * invDet,    // C10 / det
                    ( (m00 * (m22 * m33 - m23 * m32) - m02 * (m20 * m33 - m23 * m30) + m03 * (m20 * m32 - m22 * m30))) * invDet,    // C11 / det
                    (-(m00 * (m21 * m33 - m23 * m31) - m01 * (m20 * m33 - m23 * m30) + m03 * (m20 * m31 - m21 * m30))) * invDet,    // C12 / det
                    ( (m00 * (m21 * m32 - m22 * m31) - m01 * (m20 * m32 - m22 * m30) + m02 * (m20 * m31 - m21 * m30))) * invDet     // C13 / det
                ),
                new Double4( // Column 2 of Inverse (M_inv_02, M_inv_12, M_inv_22, M_inv_32)
                    ( (m01 * (m12 * m33 - m13 * m32) - m02 * (m11 * m33 - m13 * m31) + m03 * (m11 * m32 - m12 * m31))) * invDet,    // C20 / det
                    (-(m00 * (m12 * m33 - m13 * m32) - m02 * (m10 * m33 - m13 * m30) + m03 * (m10 * m32 - m12 * m30))) * invDet,    // C21 / det
                    ( (m00 * (m11 * m33 - m13 * m31) - m01 * (m10 * m33 - m13 * m30) + m03 * (m10 * m31 - m11 * m30))) * invDet,    // C22 / det
                    (-(m00 * (m11 * m32 - m12 * m31) - m01 * (m10 * m32 - m12 * m30) + m02 * (m10 * m31 - m11 * m30))) * invDet     // C23 / det
                ),
                new Double4( // Column 3 of Inverse (M_inv_03, M_inv_13, M_inv_23, M_inv_33)
                    (-(m01 * (m12 * m23 - m13 * m22) - m02 * (m11 * m23 - m13 * m21) + m03 * (m11 * m22 - m12 * m21))) * invDet,    // C30 / det
                    ( (m00 * (m12 * m23 - m13 * m22) - m02 * (m10 * m23 - m13 * m20) + m03 * (m10 * m22 - m12 * m20))) * invDet,    // C31 / det
                    (-(m00 * (m11 * m23 - m13 * m21) - m01 * (m10 * m23 - m13 * m20) + m03 * (m10 * m21 - m11 * m20))) * invDet,    // C32 / det
                    ( (m00 * (m11 * m22 - m12 * m21) - m01 * (m10 * m22 - m12 * m20) + m02 * (m10 * m21 - m11 * m20))) * invDet     // C33 / det
                )
            );
        }





        // InverseLerp functions
        /// <summary>Finds the t value given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float InverseLerp(float a, float b, float value)
        {
            if (a != b)
                return (value - a) / (b - a);
            else
                return 0f;
        }
        /// <summary>Finds the t value given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double InverseLerp(double a, double b, double value)
        {
            if (a != b)
                return (value - a) / (b - a);
            else
                return 0;
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 InverseLerp(Float2 a, Float2 b, Float2 value)
        {
            return new Float2(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y));
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 InverseLerp(Float3 a, Float3 b, Float3 value)
        {
            return new Float3(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y), InverseLerp(a.Z, b.Z, value.Z));
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 InverseLerp(Float4 a, Float4 b, Float4 value)
        {
            return new Float4(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y), InverseLerp(a.Z, b.Z, value.Z), InverseLerp(a.W, b.W, value.W));
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 InverseLerp(Double2 a, Double2 b, Double2 value)
        {
            return new Double2(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y));
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 InverseLerp(Double3 a, Double3 b, Double3 value)
        {
            return new Double3(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y), InverseLerp(a.Z, b.Z, value.Z));
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 InverseLerp(Double4 a, Double4 b, Double4 value)
        {
            return new Double4(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y), InverseLerp(a.Z, b.Z, value.Z), InverseLerp(a.W, b.W, value.W));
        }
        // IsParallel functions
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Float2 a, Float2 b, float tolerance = 1e-6f)
        {
            float normalizedDot = MathF.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1f - tolerance;
        }
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Float3 a, Float3 b, float tolerance = 1e-6f)
        {
            float normalizedDot = MathF.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1f - tolerance;
        }
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Float4 a, Float4 b, float tolerance = 1e-6f)
        {
            float normalizedDot = MathF.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1f - tolerance;
        }
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Double2 a, Double2 b, double tolerance = 1e-15)
        {
            double normalizedDot = Math.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1 - tolerance;
        }
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Double3 a, Double3 b, double tolerance = 1e-15)
        {
            double normalizedDot = Math.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1 - tolerance;
        }
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Double4 a, Double4 b, double tolerance = 1e-15)
        {
            double normalizedDot = Math.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1 - tolerance;
        }
        // IsPerpendicular functions
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Float2 a, Float2 b, float tolerance = 1e-6f)
        {
            float dot = MathF.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Float3 a, Float3 b, float tolerance = 1e-6f)
        {
            float dot = MathF.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Float4 a, Float4 b, float tolerance = 1e-6f)
        {
            float dot = MathF.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Double2 a, Double2 b, double tolerance = 1e-15)
        {
            double dot = Math.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Double3 a, Double3 b, double tolerance = 1e-15)
        {
            double dot = Math.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Double4 a, Double4 b, double tolerance = 1e-15)
        {
            double dot = Math.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        // Length functions
        /// <summary>Returns the length (magnitude) of a Float2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Length(Float2 x) { return x.Length; }
        /// <summary>Returns the length (magnitude) of a Float3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Length(Float3 x) { return x.Length; }
        /// <summary>Returns the length (magnitude) of a Float4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Length(Float4 x) { return x.Length; }
        /// <summary>Returns the length (magnitude) of a Double2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Length(Double2 x) { return x.Length; }
        /// <summary>Returns the length (magnitude) of a Double3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Length(Double3 x) { return x.Length; }
        /// <summary>Returns the length (magnitude) of a Double4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Length(Double4 x) { return x.Length; }
        // LengthSquared functions
        /// <summary>Returns the squared length of a Float2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float LengthSquared(Float2 x) { return x.LengthSquared; }
        /// <summary>Returns the squared length of a Float3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float LengthSquared(Float3 x) { return x.LengthSquared; }
        /// <summary>Returns the squared length of a Float4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float LengthSquared(Float4 x) { return x.LengthSquared; }
        /// <summary>Returns the squared length of a Double2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double LengthSquared(Double2 x) { return x.LengthSquared; }
        /// <summary>Returns the squared length of a Double3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double LengthSquared(Double3 x) { return x.LengthSquared; }
        /// <summary>Returns the squared length of a Double4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double LengthSquared(Double4 x) { return x.LengthSquared; }
        // Lerp functions
        /// <summary>Linearly interpolates between two float values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Lerp(float a, float b, float t) { return a + (b - a) * Saturate(t); }
        /// <summary>Linearly interpolates between two double values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Lerp(double a, double b, double t) { return a + (b - a) * Saturate(t); }
        /// <summary>Linearly interpolates between two Float2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Lerp(Float2 a, Float2 b, float t) { return new Float2(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t))); }
        /// <summary>Linearly interpolates between two Float3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Lerp(Float3 a, Float3 b, float t) { return new Float3(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t)), Lerp(a.Z, b.Z, Saturate(t))); }
        /// <summary>Linearly interpolates between two Float4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Lerp(Float4 a, Float4 b, float t) { return new Float4(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t)), Lerp(a.Z, b.Z, Saturate(t)), Lerp(a.W, b.W, Saturate(t))); }
        /// <summary>Linearly interpolates between two Double2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Lerp(Double2 a, Double2 b, double t) { return new Double2(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t))); }
        /// <summary>Linearly interpolates between two Double3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Lerp(Double3 a, Double3 b, double t) { return new Double3(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t)), Lerp(a.Z, b.Z, Saturate(t))); }
        /// <summary>Linearly interpolates between two Double4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Lerp(Double4 a, Double4 b, double t) { return new Double4(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t)), Lerp(a.Z, b.Z, Saturate(t)), Lerp(a.W, b.W, Saturate(t))); }
        // LerpAngle functions
        /// <summary>Linearly interpolates between two angles, taking the shortest path around the circle.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float LerpAngle(float a, float b, float t)
        {
            float delta = Repeat(b - a, 2f * MathF.PI);
            if (delta > MathF.PI)
                delta -= 2f * MathF.PI;
            return a + delta * Saturate(t);
        }
        /// <summary>Linearly interpolates between two angles, taking the shortest path around the circle.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double LerpAngle(double a, double b, double t)
        {
            double delta = Repeat(b - a, 2 * Math.PI);
            if (delta > Math.PI)
                delta -= 2 * Math.PI;
            return a + delta * Saturate(t);
        }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 LerpAngle(Float2 a, Float2 b, float t) { return new Float2(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t)); }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 LerpAngle(Float3 a, Float3 b, float t) { return new Float3(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t), LerpAngle(a.Z, b.Z, t)); }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 LerpAngle(Float4 a, Float4 b, float t) { return new Float4(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t), LerpAngle(a.Z, b.Z, t), LerpAngle(a.W, b.W, t)); }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 LerpAngle(Double2 a, Double2 b, double t) { return new Double2(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t)); }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 LerpAngle(Double3 a, Double3 b, double t) { return new Double3(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t), LerpAngle(a.Z, b.Z, t)); }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 LerpAngle(Double4 a, Double4 b, double t) { return new Double4(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t), LerpAngle(a.Z, b.Z, t), LerpAngle(a.W, b.W, t)); }
        // LerpUnclamped functions
        /// <summary>Linearly interpolates between two values without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float LerpUnclamped(float a, float b, float t) { return a + (b - a) * t; }
        /// <summary>Linearly interpolates between two values without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double LerpUnclamped(double a, double b, double t) { return a + (b - a) * t; }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 LerpUnclamped(Float2 a, Float2 b, float t) { return new Float2(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t)); }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 LerpUnclamped(Float3 a, Float3 b, float t) { return new Float3(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t), LerpUnclamped(a.Z, b.Z, t)); }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 LerpUnclamped(Float4 a, Float4 b, float t) { return new Float4(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t), LerpUnclamped(a.Z, b.Z, t), LerpUnclamped(a.W, b.W, t)); }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 LerpUnclamped(Double2 a, Double2 b, double t) { return new Double2(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t)); }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 LerpUnclamped(Double3 a, Double3 b, double t) { return new Double3(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t), LerpUnclamped(a.Z, b.Z, t)); }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 LerpUnclamped(Double4 a, Double4 b, double t) { return new Double4(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t), LerpUnclamped(a.Z, b.Z, t), LerpUnclamped(a.W, b.W, t)); }
        // LinearToGamma functions
        /// <summary>Converts a linear color to gamma space (sRGB).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 LinearToGamma(Float3 linear)
        {
            return Gamma(linear, 2.2f);
        }
        /// <summary>Converts a linear color to gamma space (sRGB).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 LinearToGamma(Float4 linear)
        {
            return Gamma(linear, 2.2f);
        }
        /// <summary>Converts a linear color to gamma space (sRGB).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 LinearToGamma(Byte3 linear)
        {
            return Gamma(linear, 2.2f);
        }
        /// <summary>Converts a linear color to gamma space (sRGB).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 LinearToGamma(Byte4 linear)
        {
            return Gamma(linear, 2.2f);
        }
        // Log functions
        /// <summary>Returns the natural logarithm of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Log(float x) { return MathF.Log(x); }
        /// <summary>Returns the natural logarithm of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Log(double x) { return Math.Log(x); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Log(Float2 x) { return new Float2(Log(x.X), Log(x.Y)); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Log(Float3 x) { return new Float3(Log(x.X), Log(x.Y), Log(x.Z)); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Log(Float4 x) { return new Float4(Log(x.X), Log(x.Y), Log(x.Z), Log(x.W)); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Log(Double2 x) { return new Double2(Log(x.X), Log(x.Y)); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Log(Double3 x) { return new Double3(Log(x.X), Log(x.Y), Log(x.Z)); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Log(Double4 x) { return new Double4(Log(x.X), Log(x.Y), Log(x.Z), Log(x.W)); }
        // Max functions
        /// <summary>Returns the maximum of two float values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Max(float x, float y) { return MathF.Max(x, y); }
        /// <summary>Returns the maximum of two double values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Max(double x, double y) { return Math.Max(x, y); }
        /// <summary>Returns the maximum of two int values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Max(int x, int y) { return Math.Max(x, y); }
        /// <summary>Returns the maximum of two byte values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte Max(byte x, byte y) { return Math.Max(x, y); }
        /// <summary>Returns the maximum of two ushort values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Max(ushort x, ushort y) { return Math.Max(x, y); }
        /// <summary>Returns the maximum of two uint values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Max(uint x, uint y) { return Math.Max(x, y); }
        /// <summary>Returns the maximum of two ulong values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Max(ulong x, ulong y) { return Math.Max(x, y); }
        /// <summary>Returns the componentwise maximum of two Float2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Max(Float2 x, Float2 y) { return new Float2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a Float2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Max(Float2 x, float scalar) { return new Float2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two Float3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Max(Float3 x, Float3 y) { return new Float3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a Float3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Max(Float3 x, float scalar) { return new Float3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two Float4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Max(Float4 x, Float4 y) { return new Float4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a Float4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Max(Float4 x, float scalar) { return new Float4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two Double2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Max(Double2 x, Double2 y) { return new Double2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a Double2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Max(Double2 x, double scalar) { return new Double2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two Double3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Max(Double3 x, Double3 y) { return new Double3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a Double3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Max(Double3 x, double scalar) { return new Double3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two Double4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Max(Double4 x, Double4 y) { return new Double4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a Double4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Max(Double4 x, double scalar) { return new Double4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two Int2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Max(Int2 x, Int2 y) { return new Int2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a Int2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Max(Int2 x, int scalar) { return new Int2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two Int3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Max(Int3 x, Int3 y) { return new Int3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a Int3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Max(Int3 x, int scalar) { return new Int3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two Int4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Max(Int4 x, Int4 y) { return new Int4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a Int4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Max(Int4 x, int scalar) { return new Int4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two Byte2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Max(Byte2 x, Byte2 y) { return new Byte2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a Byte2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Max(Byte2 x, byte scalar) { return new Byte2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two Byte3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Max(Byte3 x, Byte3 y) { return new Byte3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a Byte3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Max(Byte3 x, byte scalar) { return new Byte3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two Byte4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Max(Byte4 x, Byte4 y) { return new Byte4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a Byte4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Max(Byte4 x, byte scalar) { return new Byte4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two UShort2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Max(UShort2 x, UShort2 y) { return new UShort2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a UShort2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Max(UShort2 x, ushort scalar) { return new UShort2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two UShort3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Max(UShort3 x, UShort3 y) { return new UShort3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a UShort3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Max(UShort3 x, ushort scalar) { return new UShort3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two UShort4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Max(UShort4 x, UShort4 y) { return new UShort4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a UShort4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Max(UShort4 x, ushort scalar) { return new UShort4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two UInt2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Max(UInt2 x, UInt2 y) { return new UInt2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a UInt2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Max(UInt2 x, uint scalar) { return new UInt2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two UInt3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Max(UInt3 x, UInt3 y) { return new UInt3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a UInt3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Max(UInt3 x, uint scalar) { return new UInt3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two UInt4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Max(UInt4 x, UInt4 y) { return new UInt4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a UInt4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Max(UInt4 x, uint scalar) { return new UInt4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two ULong2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Max(ULong2 x, ULong2 y) { return new ULong2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a ULong2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Max(ULong2 x, ulong scalar) { return new ULong2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two ULong3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Max(ULong3 x, ULong3 y) { return new ULong3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a ULong3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Max(ULong3 x, ulong scalar) { return new ULong3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two ULong4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Max(ULong4 x, ULong4 y) { return new ULong4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a ULong4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Max(ULong4 x, ulong scalar) { return new ULong4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        // Min functions
        /// <summary>Returns the minimum of two float values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Min(float x, float y) { return MathF.Min(x, y); }
        /// <summary>Returns the minimum of two double values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Min(double x, double y) { return Math.Min(x, y); }
        /// <summary>Returns the minimum of two int values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Min(int x, int y) { return Math.Min(x, y); }
        /// <summary>Returns the minimum of two byte values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte Min(byte x, byte y) { return Math.Min(x, y); }
        /// <summary>Returns the minimum of two ushort values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Min(ushort x, ushort y) { return Math.Min(x, y); }
        /// <summary>Returns the minimum of two uint values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Min(uint x, uint y) { return Math.Min(x, y); }
        /// <summary>Returns the minimum of two ulong values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Min(ulong x, ulong y) { return Math.Min(x, y); }
        /// <summary>Returns the componentwise minimum of two Float2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Min(Float2 x, Float2 y) { return new Float2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a Float2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Min(Float2 x, float scalar) { return new Float2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two Float3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Min(Float3 x, Float3 y) { return new Float3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a Float3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Min(Float3 x, float scalar) { return new Float3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two Float4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Min(Float4 x, Float4 y) { return new Float4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a Float4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Min(Float4 x, float scalar) { return new Float4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two Double2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Min(Double2 x, Double2 y) { return new Double2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a Double2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Min(Double2 x, double scalar) { return new Double2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two Double3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Min(Double3 x, Double3 y) { return new Double3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a Double3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Min(Double3 x, double scalar) { return new Double3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two Double4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Min(Double4 x, Double4 y) { return new Double4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a Double4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Min(Double4 x, double scalar) { return new Double4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two Int2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Min(Int2 x, Int2 y) { return new Int2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a Int2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Min(Int2 x, int scalar) { return new Int2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two Int3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Min(Int3 x, Int3 y) { return new Int3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a Int3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Min(Int3 x, int scalar) { return new Int3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two Int4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Min(Int4 x, Int4 y) { return new Int4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a Int4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Min(Int4 x, int scalar) { return new Int4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two Byte2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Min(Byte2 x, Byte2 y) { return new Byte2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a Byte2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Min(Byte2 x, byte scalar) { return new Byte2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two Byte3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Min(Byte3 x, Byte3 y) { return new Byte3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a Byte3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Min(Byte3 x, byte scalar) { return new Byte3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two Byte4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Min(Byte4 x, Byte4 y) { return new Byte4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a Byte4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Min(Byte4 x, byte scalar) { return new Byte4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two UShort2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Min(UShort2 x, UShort2 y) { return new UShort2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a UShort2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Min(UShort2 x, ushort scalar) { return new UShort2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two UShort3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Min(UShort3 x, UShort3 y) { return new UShort3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a UShort3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Min(UShort3 x, ushort scalar) { return new UShort3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two UShort4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Min(UShort4 x, UShort4 y) { return new UShort4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a UShort4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Min(UShort4 x, ushort scalar) { return new UShort4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two UInt2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Min(UInt2 x, UInt2 y) { return new UInt2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a UInt2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Min(UInt2 x, uint scalar) { return new UInt2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two UInt3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Min(UInt3 x, UInt3 y) { return new UInt3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a UInt3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Min(UInt3 x, uint scalar) { return new UInt3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two UInt4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Min(UInt4 x, UInt4 y) { return new UInt4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a UInt4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Min(UInt4 x, uint scalar) { return new UInt4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two ULong2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Min(ULong2 x, ULong2 y) { return new ULong2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a ULong2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Min(ULong2 x, ulong scalar) { return new ULong2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two ULong3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Min(ULong3 x, ULong3 y) { return new ULong3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a ULong3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Min(ULong3 x, ulong scalar) { return new ULong3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two ULong4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Min(ULong4 x, ULong4 y) { return new ULong4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a ULong4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Min(ULong4 x, ulong scalar) { return new ULong4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        // ModF functions
        /// <summary>Splits a floating-point value into integer and fractional parts.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ModF(float x, out float integerPart)
        {
            integerPart = Floor(x);
            return x - integerPart;
        }
        /// <summary>Splits a floating-point value into integer and fractional parts.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double ModF(double x, out double integerPart)
        {
            integerPart = Floor(x);
            return x - integerPart;
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 ModF(Float2 x, out Float2 integer)
        {
            integer = new Float2();
            return new Float2(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y));
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 ModF(Float3 x, out Float3 integer)
        {
            integer = new Float3();
            return new Float3(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y), ModF(x.Z, out integer.Z));
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 ModF(Float4 x, out Float4 integer)
        {
            integer = new Float4();
            return new Float4(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y), ModF(x.Z, out integer.Z), ModF(x.W, out integer.W));
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 ModF(Double2 x, out Double2 integer)
        {
            integer = new Double2();
            return new Double2(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y));
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 ModF(Double3 x, out Double3 integer)
        {
            integer = new Double3();
            return new Double3(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y), ModF(x.Z, out integer.Z));
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 ModF(Double4 x, out Double4 integer)
        {
            integer = new Double4();
            return new Double4(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y), ModF(x.Z, out integer.Z), ModF(x.W, out integer.W));
        }
        // MoveTowards functions
        /// <summary>Moves a value current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MoveTowards(float current, float target, float maxDelta)
        {
            if (Abs(target - current) <= maxDelta)
                return target;
            return current + Sign(target - current) * maxDelta;
        }
        /// <summary>Moves a value current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MoveTowards(double current, double target, double maxDelta)
        {
            if (Abs(target - current) <= maxDelta)
                return target;
            return current + Sign(target - current) * maxDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 MoveTowards(Float2 current, Float2 target, float maxDistanceDelta)
        {
            Float2 toVector = target - current;
            float distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < float.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 MoveTowards(Float3 current, Float3 target, float maxDistanceDelta)
        {
            Float3 toVector = target - current;
            float distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < float.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 MoveTowards(Float4 current, Float4 target, float maxDistanceDelta)
        {
            Float4 toVector = target - current;
            float distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < float.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 MoveTowards(Double2 current, Double2 target, double maxDistanceDelta)
        {
            Double2 toVector = target - current;
            double distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < double.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 MoveTowards(Double3 current, Double3 target, double maxDistanceDelta)
        {
            Double3 toVector = target - current;
            double distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < double.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 MoveTowards(Double4 current, Double4 target, double maxDistanceDelta)
        {
            Double4 toVector = target - current;
            double distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < double.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        // MoveTowardsAngle functions
        /// <summary>Moves an angle towards a target angle.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MoveTowardsAngle(float current, float target, float maxDelta)
        {
            float deltaAngle = DeltaAngle(current, target);
            if (-maxDelta < deltaAngle && deltaAngle < maxDelta)
                return target;
            target = current + deltaAngle;
            return MoveTowards(current, target, maxDelta);
        }
        /// <summary>Moves an angle towards a target angle.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MoveTowardsAngle(double current, double target, double maxDelta)
        {
            double deltaAngle = DeltaAngle(current, target);
            if (-maxDelta < deltaAngle && deltaAngle < maxDelta)
                return target;
            target = current + deltaAngle;
            return MoveTowards(current, target, maxDelta);
        }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 MoveTowardsAngle(Float2 current, Float2 target, float maxDelta) { return new Float2(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta)); }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 MoveTowardsAngle(Float3 current, Float3 target, float maxDelta) { return new Float3(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta), MoveTowardsAngle(current.Z, target.Z, maxDelta)); }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 MoveTowardsAngle(Float4 current, Float4 target, float maxDelta) { return new Float4(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta), MoveTowardsAngle(current.Z, target.Z, maxDelta), MoveTowardsAngle(current.W, target.W, maxDelta)); }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 MoveTowardsAngle(Double2 current, Double2 target, double maxDelta) { return new Double2(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta)); }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 MoveTowardsAngle(Double3 current, Double3 target, double maxDelta) { return new Double3(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta), MoveTowardsAngle(current.Z, target.Z, maxDelta)); }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 MoveTowardsAngle(Double4 current, Double4 target, double maxDelta) { return new Double4(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta), MoveTowardsAngle(current.Z, target.Z, maxDelta), MoveTowardsAngle(current.W, target.W, maxDelta)); }
        // Mul functions
        /// <summary>Returns the result of scalar multiplication.</summary>
        /// <param name="a">First scalar value.</param>
        /// <param name="b">Second scalar value.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Mul(float a, float b)
        {
            return a * b;
        }

        /// <summary>Returns the dot product of two Float2 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Mul(Float2 a, Float2 b)
        {
            return a.X * b.X + a.Y * b.Y;
        }

        /// <summary>Returns the dot product of two Float3 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Mul(Float3 a, Float3 b)
        {
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
        }

        /// <summary>Returns the dot product of two Float4 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Mul(Float4 a, Float4 b)
        {
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z + a.W * b.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Mul(Float2x2 m, Float2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Mul(Float2 rowVector, Float2x2 matrix)
        {
            return new Float2((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Mul(Float3x3 m, Float3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Mul(Float3 rowVector, Float3x3 matrix)
        {
            return new Float3((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y + rowVector.Z * matrix.c0.Z), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y + rowVector.Z * matrix.c1.Z), (rowVector.X * matrix.c2.X + rowVector.Y * matrix.c2.Y + rowVector.Z * matrix.c2.Z));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Mul(Float4x4 m, Float4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Mul(Float4 rowVector, Float4x4 matrix)
        {
            return new Float4((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y + rowVector.Z * matrix.c0.Z + rowVector.W * matrix.c0.W), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y + rowVector.Z * matrix.c1.Z + rowVector.W * matrix.c1.W), (rowVector.X * matrix.c2.X + rowVector.Y * matrix.c2.Y + rowVector.Z * matrix.c2.Z + rowVector.W * matrix.c2.W), (rowVector.X * matrix.c3.X + rowVector.Y * matrix.c3.Y + rowVector.Z * matrix.c3.Z + rowVector.W * matrix.c3.W));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Float2x3 matrix.</param>
        /// <param name="v">The Float3 vector.</param>
        /// <returns>The result of m * v (Float2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Mul(Float2x3 m, Float3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Float2x4 matrix.</param>
        /// <param name="v">The Float4 vector.</param>
        /// <returns>The result of m * v (Float2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Mul(Float2x4 m, Float4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Float3x2 matrix.</param>
        /// <param name="v">The Float2 vector.</param>
        /// <returns>The result of m * v (Float3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Mul(Float3x2 m, Float2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Float3x4 matrix.</param>
        /// <param name="v">The Float4 vector.</param>
        /// <returns>The result of m * v (Float3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Mul(Float3x4 m, Float4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Float4x2 matrix.</param>
        /// <param name="v">The Float2 vector.</param>
        /// <returns>The result of m * v (Float4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Mul(Float4x2 m, Float2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Float4x3 matrix.</param>
        /// <param name="v">The Float3 vector.</param>
        /// <returns>The result of m * v (Float4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Mul(Float4x3 m, Float3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x2 Mul(Float2x2 a, Float2x2 b)
        {
            return new Float2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x3 Mul(Float3x3 a, Float3x3 b)
        {
            return new Float3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x4 Mul(Float4x4 a, Float4x4 b)
        {
            return new Float4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float2x3).</param>
        /// <param name="b">The second matrix (Float3x2).</param>
        /// <returns>The result of a * b (Float2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x2 Mul(Float2x3 a, Float3x2 b)
        {
            return new Float2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float2x3).</param>
        /// <param name="b">The second matrix (Float3x3).</param>
        /// <returns>The result of a * b (Float2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x3 Mul(Float2x3 a, Float3x3 b)
        {
            return new Float2x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float2x3).</param>
        /// <param name="b">The second matrix (Float3x4).</param>
        /// <returns>The result of a * b (Float2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x4 Mul(Float2x3 a, Float3x4 b)
        {
            return new Float2x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float2x4).</param>
        /// <param name="b">The second matrix (Float4x2).</param>
        /// <returns>The result of a * b (Float2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x2 Mul(Float2x4 a, Float4x2 b)
        {
            return new Float2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float2x4).</param>
        /// <param name="b">The second matrix (Float4x3).</param>
        /// <returns>The result of a * b (Float2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x3 Mul(Float2x4 a, Float4x3 b)
        {
            return new Float2x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float2x4).</param>
        /// <param name="b">The second matrix (Float4x4).</param>
        /// <returns>The result of a * b (Float2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x4 Mul(Float2x4 a, Float4x4 b)
        {
            return new Float2x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float3x2).</param>
        /// <param name="b">The second matrix (Float2x2).</param>
        /// <returns>The result of a * b (Float3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x2 Mul(Float3x2 a, Float2x2 b)
        {
            return new Float3x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float3x2).</param>
        /// <param name="b">The second matrix (Float2x3).</param>
        /// <returns>The result of a * b (Float3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x3 Mul(Float3x2 a, Float2x3 b)
        {
            return new Float3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float3x2).</param>
        /// <param name="b">The second matrix (Float2x4).</param>
        /// <returns>The result of a * b (Float3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x4 Mul(Float3x2 a, Float2x4 b)
        {
            return new Float3x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y,
                a.c0 * b.c3.X + a.c1 * b.c3.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float3x4).</param>
        /// <param name="b">The second matrix (Float4x2).</param>
        /// <returns>The result of a * b (Float3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x2 Mul(Float3x4 a, Float4x2 b)
        {
            return new Float3x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float3x4).</param>
        /// <param name="b">The second matrix (Float4x3).</param>
        /// <returns>The result of a * b (Float3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x3 Mul(Float3x4 a, Float4x3 b)
        {
            return new Float3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float3x4).</param>
        /// <param name="b">The second matrix (Float4x4).</param>
        /// <returns>The result of a * b (Float3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x4 Mul(Float3x4 a, Float4x4 b)
        {
            return new Float3x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float4x2).</param>
        /// <param name="b">The second matrix (Float2x2).</param>
        /// <returns>The result of a * b (Float4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x2 Mul(Float4x2 a, Float2x2 b)
        {
            return new Float4x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float4x2).</param>
        /// <param name="b">The second matrix (Float2x3).</param>
        /// <returns>The result of a * b (Float4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x3 Mul(Float4x2 a, Float2x3 b)
        {
            return new Float4x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float4x2).</param>
        /// <param name="b">The second matrix (Float2x4).</param>
        /// <returns>The result of a * b (Float4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x4 Mul(Float4x2 a, Float2x4 b)
        {
            return new Float4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y,
                a.c0 * b.c3.X + a.c1 * b.c3.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float4x3).</param>
        /// <param name="b">The second matrix (Float3x2).</param>
        /// <returns>The result of a * b (Float4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x2 Mul(Float4x3 a, Float3x2 b)
        {
            return new Float4x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float4x3).</param>
        /// <param name="b">The second matrix (Float3x3).</param>
        /// <returns>The result of a * b (Float4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x3 Mul(Float4x3 a, Float3x3 b)
        {
            return new Float4x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Float4x3).</param>
        /// <param name="b">The second matrix (Float3x4).</param>
        /// <returns>The result of a * b (Float4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x4 Mul(Float4x3 a, Float3x4 b)
        {
            return new Float4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z
            );
        }


        /// <summary>Returns the result of scalar multiplication.</summary>
        /// <param name="a">First scalar value.</param>
        /// <param name="b">Second scalar value.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Mul(double a, double b)
        {
            return a * b;
        }

        /// <summary>Returns the dot product of two Double2 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Mul(Double2 a, Double2 b)
        {
            return a.X * b.X + a.Y * b.Y;
        }

        /// <summary>Returns the dot product of two Double3 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Mul(Double3 a, Double3 b)
        {
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
        }

        /// <summary>Returns the dot product of two Double4 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Mul(Double4 a, Double4 b)
        {
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z + a.W * b.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Mul(Double2x2 m, Double2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Mul(Double2 rowVector, Double2x2 matrix)
        {
            return new Double2((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Mul(Double3x3 m, Double3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Mul(Double3 rowVector, Double3x3 matrix)
        {
            return new Double3((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y + rowVector.Z * matrix.c0.Z), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y + rowVector.Z * matrix.c1.Z), (rowVector.X * matrix.c2.X + rowVector.Y * matrix.c2.Y + rowVector.Z * matrix.c2.Z));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Mul(Double4x4 m, Double4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Mul(Double4 rowVector, Double4x4 matrix)
        {
            return new Double4((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y + rowVector.Z * matrix.c0.Z + rowVector.W * matrix.c0.W), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y + rowVector.Z * matrix.c1.Z + rowVector.W * matrix.c1.W), (rowVector.X * matrix.c2.X + rowVector.Y * matrix.c2.Y + rowVector.Z * matrix.c2.Z + rowVector.W * matrix.c2.W), (rowVector.X * matrix.c3.X + rowVector.Y * matrix.c3.Y + rowVector.Z * matrix.c3.Z + rowVector.W * matrix.c3.W));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Double2x3 matrix.</param>
        /// <param name="v">The Double3 vector.</param>
        /// <returns>The result of m * v (Double2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Mul(Double2x3 m, Double3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Double2x4 matrix.</param>
        /// <param name="v">The Double4 vector.</param>
        /// <returns>The result of m * v (Double2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Mul(Double2x4 m, Double4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Double3x2 matrix.</param>
        /// <param name="v">The Double2 vector.</param>
        /// <returns>The result of m * v (Double3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Mul(Double3x2 m, Double2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Double3x4 matrix.</param>
        /// <param name="v">The Double4 vector.</param>
        /// <returns>The result of m * v (Double3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Mul(Double3x4 m, Double4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Double4x2 matrix.</param>
        /// <param name="v">The Double2 vector.</param>
        /// <returns>The result of m * v (Double4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Mul(Double4x2 m, Double2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Double4x3 matrix.</param>
        /// <param name="v">The Double3 vector.</param>
        /// <returns>The result of m * v (Double4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Mul(Double4x3 m, Double3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x2 Mul(Double2x2 a, Double2x2 b)
        {
            return new Double2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x3 Mul(Double3x3 a, Double3x3 b)
        {
            return new Double3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x4 Mul(Double4x4 a, Double4x4 b)
        {
            return new Double4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double2x3).</param>
        /// <param name="b">The second matrix (Double3x2).</param>
        /// <returns>The result of a * b (Double2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x2 Mul(Double2x3 a, Double3x2 b)
        {
            return new Double2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double2x3).</param>
        /// <param name="b">The second matrix (Double3x3).</param>
        /// <returns>The result of a * b (Double2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x3 Mul(Double2x3 a, Double3x3 b)
        {
            return new Double2x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double2x3).</param>
        /// <param name="b">The second matrix (Double3x4).</param>
        /// <returns>The result of a * b (Double2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x4 Mul(Double2x3 a, Double3x4 b)
        {
            return new Double2x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double2x4).</param>
        /// <param name="b">The second matrix (Double4x2).</param>
        /// <returns>The result of a * b (Double2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x2 Mul(Double2x4 a, Double4x2 b)
        {
            return new Double2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double2x4).</param>
        /// <param name="b">The second matrix (Double4x3).</param>
        /// <returns>The result of a * b (Double2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x3 Mul(Double2x4 a, Double4x3 b)
        {
            return new Double2x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double2x4).</param>
        /// <param name="b">The second matrix (Double4x4).</param>
        /// <returns>The result of a * b (Double2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x4 Mul(Double2x4 a, Double4x4 b)
        {
            return new Double2x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double3x2).</param>
        /// <param name="b">The second matrix (Double2x2).</param>
        /// <returns>The result of a * b (Double3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x2 Mul(Double3x2 a, Double2x2 b)
        {
            return new Double3x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double3x2).</param>
        /// <param name="b">The second matrix (Double2x3).</param>
        /// <returns>The result of a * b (Double3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x3 Mul(Double3x2 a, Double2x3 b)
        {
            return new Double3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double3x2).</param>
        /// <param name="b">The second matrix (Double2x4).</param>
        /// <returns>The result of a * b (Double3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x4 Mul(Double3x2 a, Double2x4 b)
        {
            return new Double3x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y,
                a.c0 * b.c3.X + a.c1 * b.c3.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double3x4).</param>
        /// <param name="b">The second matrix (Double4x2).</param>
        /// <returns>The result of a * b (Double3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x2 Mul(Double3x4 a, Double4x2 b)
        {
            return new Double3x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double3x4).</param>
        /// <param name="b">The second matrix (Double4x3).</param>
        /// <returns>The result of a * b (Double3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x3 Mul(Double3x4 a, Double4x3 b)
        {
            return new Double3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double3x4).</param>
        /// <param name="b">The second matrix (Double4x4).</param>
        /// <returns>The result of a * b (Double3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x4 Mul(Double3x4 a, Double4x4 b)
        {
            return new Double3x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double4x2).</param>
        /// <param name="b">The second matrix (Double2x2).</param>
        /// <returns>The result of a * b (Double4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x2 Mul(Double4x2 a, Double2x2 b)
        {
            return new Double4x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double4x2).</param>
        /// <param name="b">The second matrix (Double2x3).</param>
        /// <returns>The result of a * b (Double4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x3 Mul(Double4x2 a, Double2x3 b)
        {
            return new Double4x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double4x2).</param>
        /// <param name="b">The second matrix (Double2x4).</param>
        /// <returns>The result of a * b (Double4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x4 Mul(Double4x2 a, Double2x4 b)
        {
            return new Double4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y,
                a.c0 * b.c3.X + a.c1 * b.c3.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double4x3).</param>
        /// <param name="b">The second matrix (Double3x2).</param>
        /// <returns>The result of a * b (Double4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x2 Mul(Double4x3 a, Double3x2 b)
        {
            return new Double4x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double4x3).</param>
        /// <param name="b">The second matrix (Double3x3).</param>
        /// <returns>The result of a * b (Double4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x3 Mul(Double4x3 a, Double3x3 b)
        {
            return new Double4x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Double4x3).</param>
        /// <param name="b">The second matrix (Double3x4).</param>
        /// <returns>The result of a * b (Double4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x4 Mul(Double4x3 a, Double3x4 b)
        {
            return new Double4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z
            );
        }


        /// <summary>Returns the result of scalar multiplication.</summary>
        /// <param name="a">First scalar value.</param>
        /// <param name="b">Second scalar value.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Mul(int a, int b)
        {
            return a * b;
        }

        /// <summary>Returns the dot product of two Int2 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Mul(Int2 a, Int2 b)
        {
            return a.X * b.X + a.Y * b.Y;
        }

        /// <summary>Returns the dot product of two Int3 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Mul(Int3 a, Int3 b)
        {
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
        }

        /// <summary>Returns the dot product of two Int4 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Mul(Int4 a, Int4 b)
        {
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z + a.W * b.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Mul(Int2x2 m, Int2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Mul(Int2 rowVector, Int2x2 matrix)
        {
            return new Int2((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Mul(Int3x3 m, Int3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Mul(Int3 rowVector, Int3x3 matrix)
        {
            return new Int3((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y + rowVector.Z * matrix.c0.Z), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y + rowVector.Z * matrix.c1.Z), (rowVector.X * matrix.c2.X + rowVector.Y * matrix.c2.Y + rowVector.Z * matrix.c2.Z));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Mul(Int4x4 m, Int4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Mul(Int4 rowVector, Int4x4 matrix)
        {
            return new Int4((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y + rowVector.Z * matrix.c0.Z + rowVector.W * matrix.c0.W), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y + rowVector.Z * matrix.c1.Z + rowVector.W * matrix.c1.W), (rowVector.X * matrix.c2.X + rowVector.Y * matrix.c2.Y + rowVector.Z * matrix.c2.Z + rowVector.W * matrix.c2.W), (rowVector.X * matrix.c3.X + rowVector.Y * matrix.c3.Y + rowVector.Z * matrix.c3.Z + rowVector.W * matrix.c3.W));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Int2x3 matrix.</param>
        /// <param name="v">The Int3 vector.</param>
        /// <returns>The result of m * v (Int2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Mul(Int2x3 m, Int3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Int2x4 matrix.</param>
        /// <param name="v">The Int4 vector.</param>
        /// <returns>The result of m * v (Int2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Mul(Int2x4 m, Int4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Int3x2 matrix.</param>
        /// <param name="v">The Int2 vector.</param>
        /// <returns>The result of m * v (Int3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Mul(Int3x2 m, Int2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Int3x4 matrix.</param>
        /// <param name="v">The Int4 vector.</param>
        /// <returns>The result of m * v (Int3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Mul(Int3x4 m, Int4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Int4x2 matrix.</param>
        /// <param name="v">The Int2 vector.</param>
        /// <returns>The result of m * v (Int4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Mul(Int4x2 m, Int2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The Int4x3 matrix.</param>
        /// <param name="v">The Int3 vector.</param>
        /// <returns>The result of m * v (Int4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Mul(Int4x3 m, Int3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2x2 Mul(Int2x2 a, Int2x2 b)
        {
            return new Int2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3x3 Mul(Int3x3 a, Int3x3 b)
        {
            return new Int3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4x4 Mul(Int4x4 a, Int4x4 b)
        {
            return new Int4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int2x3).</param>
        /// <param name="b">The second matrix (Int3x2).</param>
        /// <returns>The result of a * b (Int2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2x2 Mul(Int2x3 a, Int3x2 b)
        {
            return new Int2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int2x3).</param>
        /// <param name="b">The second matrix (Int3x3).</param>
        /// <returns>The result of a * b (Int2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2x3 Mul(Int2x3 a, Int3x3 b)
        {
            return new Int2x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int2x3).</param>
        /// <param name="b">The second matrix (Int3x4).</param>
        /// <returns>The result of a * b (Int2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2x4 Mul(Int2x3 a, Int3x4 b)
        {
            return new Int2x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int2x4).</param>
        /// <param name="b">The second matrix (Int4x2).</param>
        /// <returns>The result of a * b (Int2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2x2 Mul(Int2x4 a, Int4x2 b)
        {
            return new Int2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int2x4).</param>
        /// <param name="b">The second matrix (Int4x3).</param>
        /// <returns>The result of a * b (Int2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2x3 Mul(Int2x4 a, Int4x3 b)
        {
            return new Int2x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int2x4).</param>
        /// <param name="b">The second matrix (Int4x4).</param>
        /// <returns>The result of a * b (Int2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2x4 Mul(Int2x4 a, Int4x4 b)
        {
            return new Int2x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int3x2).</param>
        /// <param name="b">The second matrix (Int2x2).</param>
        /// <returns>The result of a * b (Int3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3x2 Mul(Int3x2 a, Int2x2 b)
        {
            return new Int3x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int3x2).</param>
        /// <param name="b">The second matrix (Int2x3).</param>
        /// <returns>The result of a * b (Int3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3x3 Mul(Int3x2 a, Int2x3 b)
        {
            return new Int3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int3x2).</param>
        /// <param name="b">The second matrix (Int2x4).</param>
        /// <returns>The result of a * b (Int3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3x4 Mul(Int3x2 a, Int2x4 b)
        {
            return new Int3x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y,
                a.c0 * b.c3.X + a.c1 * b.c3.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int3x4).</param>
        /// <param name="b">The second matrix (Int4x2).</param>
        /// <returns>The result of a * b (Int3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3x2 Mul(Int3x4 a, Int4x2 b)
        {
            return new Int3x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int3x4).</param>
        /// <param name="b">The second matrix (Int4x3).</param>
        /// <returns>The result of a * b (Int3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3x3 Mul(Int3x4 a, Int4x3 b)
        {
            return new Int3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int3x4).</param>
        /// <param name="b">The second matrix (Int4x4).</param>
        /// <returns>The result of a * b (Int3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3x4 Mul(Int3x4 a, Int4x4 b)
        {
            return new Int3x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int4x2).</param>
        /// <param name="b">The second matrix (Int2x2).</param>
        /// <returns>The result of a * b (Int4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4x2 Mul(Int4x2 a, Int2x2 b)
        {
            return new Int4x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int4x2).</param>
        /// <param name="b">The second matrix (Int2x3).</param>
        /// <returns>The result of a * b (Int4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4x3 Mul(Int4x2 a, Int2x3 b)
        {
            return new Int4x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int4x2).</param>
        /// <param name="b">The second matrix (Int2x4).</param>
        /// <returns>The result of a * b (Int4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4x4 Mul(Int4x2 a, Int2x4 b)
        {
            return new Int4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y,
                a.c0 * b.c3.X + a.c1 * b.c3.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int4x3).</param>
        /// <param name="b">The second matrix (Int3x2).</param>
        /// <returns>The result of a * b (Int4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4x2 Mul(Int4x3 a, Int3x2 b)
        {
            return new Int4x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int4x3).</param>
        /// <param name="b">The second matrix (Int3x3).</param>
        /// <returns>The result of a * b (Int4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4x3 Mul(Int4x3 a, Int3x3 b)
        {
            return new Int4x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (Int4x3).</param>
        /// <param name="b">The second matrix (Int3x4).</param>
        /// <returns>The result of a * b (Int4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4x4 Mul(Int4x3 a, Int3x4 b)
        {
            return new Int4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z
            );
        }


        /// <summary>Returns the result of scalar multiplication.</summary>
        /// <param name="a">First scalar value.</param>
        /// <param name="b">Second scalar value.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Mul(uint a, uint b)
        {
            return a * b;
        }

        /// <summary>Returns the dot product of two UInt2 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Mul(UInt2 a, UInt2 b)
        {
            return a.X * b.X + a.Y * b.Y;
        }

        /// <summary>Returns the dot product of two UInt3 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Mul(UInt3 a, UInt3 b)
        {
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z;
        }

        /// <summary>Returns the dot product of two UInt4 vectors.</summary>
        /// <param name="a">First vector.</param>
        /// <param name="b">Second vector.</param>
        /// <returns>The dot product a · b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Mul(UInt4 a, UInt4 b)
        {
            return a.X * b.X + a.Y * b.Y + a.Z * b.Z + a.W * b.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Mul(UInt2x2 m, UInt2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Mul(UInt2 rowVector, UInt2x2 matrix)
        {
            return new UInt2((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Mul(UInt3x3 m, UInt3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Mul(UInt3 rowVector, UInt3x3 matrix)
        {
            return new UInt3((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y + rowVector.Z * matrix.c0.Z), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y + rowVector.Z * matrix.c1.Z), (rowVector.X * matrix.c2.X + rowVector.Y * matrix.c2.Y + rowVector.Z * matrix.c2.Z));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The matrix.</param>
        /// <param name="v">The vector.</param>
        /// <returns>The result of m * v.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Mul(UInt4x4 m, UInt4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a row vector-matrix multiplication.</summary>
        /// <param name="rowVector">The row vector.</param>
        /// <param name="matrix">The matrix.</param>
        /// <returns>The result of rowVector * matrix.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Mul(UInt4 rowVector, UInt4x4 matrix)
        {
            return new UInt4((rowVector.X * matrix.c0.X + rowVector.Y * matrix.c0.Y + rowVector.Z * matrix.c0.Z + rowVector.W * matrix.c0.W), (rowVector.X * matrix.c1.X + rowVector.Y * matrix.c1.Y + rowVector.Z * matrix.c1.Z + rowVector.W * matrix.c1.W), (rowVector.X * matrix.c2.X + rowVector.Y * matrix.c2.Y + rowVector.Z * matrix.c2.Z + rowVector.W * matrix.c2.W), (rowVector.X * matrix.c3.X + rowVector.Y * matrix.c3.Y + rowVector.Z * matrix.c3.Z + rowVector.W * matrix.c3.W));
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The UInt2x3 matrix.</param>
        /// <param name="v">The UInt3 vector.</param>
        /// <returns>The result of m * v (UInt2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Mul(UInt2x3 m, UInt3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The UInt2x4 matrix.</param>
        /// <param name="v">The UInt4 vector.</param>
        /// <returns>The result of m * v (UInt2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Mul(UInt2x4 m, UInt4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The UInt3x2 matrix.</param>
        /// <param name="v">The UInt2 vector.</param>
        /// <returns>The result of m * v (UInt3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Mul(UInt3x2 m, UInt2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The UInt3x4 matrix.</param>
        /// <param name="v">The UInt4 vector.</param>
        /// <returns>The result of m * v (UInt3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Mul(UInt3x4 m, UInt4 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z +
                m.c3 * v.W;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The UInt4x2 matrix.</param>
        /// <param name="v">The UInt2 vector.</param>
        /// <returns>The result of m * v (UInt4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Mul(UInt4x2 m, UInt2 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y;
        }

        /// <summary>Returns the result of a matrix-vector multiplication.</summary>
        /// <param name="m">The UInt4x3 matrix.</param>
        /// <param name="v">The UInt3 vector.</param>
        /// <returns>The result of m * v (UInt4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Mul(UInt4x3 m, UInt3 v)
        {
            return
                m.c0 * v.X +
                m.c1 * v.Y +
                m.c2 * v.Z;
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2x2 Mul(UInt2x2 a, UInt2x2 b)
        {
            return new UInt2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3x3 Mul(UInt3x3 a, UInt3x3 b)
        {
            return new UInt3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix.</param>
        /// <param name="b">The second matrix.</param>
        /// <returns>The result of a * b.</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4x4 Mul(UInt4x4 a, UInt4x4 b)
        {
            return new UInt4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt2x3).</param>
        /// <param name="b">The second matrix (UInt3x2).</param>
        /// <returns>The result of a * b (UInt2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2x2 Mul(UInt2x3 a, UInt3x2 b)
        {
            return new UInt2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt2x3).</param>
        /// <param name="b">The second matrix (UInt3x3).</param>
        /// <returns>The result of a * b (UInt2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2x3 Mul(UInt2x3 a, UInt3x3 b)
        {
            return new UInt2x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt2x3).</param>
        /// <param name="b">The second matrix (UInt3x4).</param>
        /// <returns>The result of a * b (UInt2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2x4 Mul(UInt2x3 a, UInt3x4 b)
        {
            return new UInt2x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt2x4).</param>
        /// <param name="b">The second matrix (UInt4x2).</param>
        /// <returns>The result of a * b (UInt2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2x2 Mul(UInt2x4 a, UInt4x2 b)
        {
            return new UInt2x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt2x4).</param>
        /// <param name="b">The second matrix (UInt4x3).</param>
        /// <returns>The result of a * b (UInt2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2x3 Mul(UInt2x4 a, UInt4x3 b)
        {
            return new UInt2x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt2x4).</param>
        /// <param name="b">The second matrix (UInt4x4).</param>
        /// <returns>The result of a * b (UInt2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2x4 Mul(UInt2x4 a, UInt4x4 b)
        {
            return new UInt2x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt3x2).</param>
        /// <param name="b">The second matrix (UInt2x2).</param>
        /// <returns>The result of a * b (UInt3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3x2 Mul(UInt3x2 a, UInt2x2 b)
        {
            return new UInt3x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt3x2).</param>
        /// <param name="b">The second matrix (UInt2x3).</param>
        /// <returns>The result of a * b (UInt3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3x3 Mul(UInt3x2 a, UInt2x3 b)
        {
            return new UInt3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt3x2).</param>
        /// <param name="b">The second matrix (UInt2x4).</param>
        /// <returns>The result of a * b (UInt3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3x4 Mul(UInt3x2 a, UInt2x4 b)
        {
            return new UInt3x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y,
                a.c0 * b.c3.X + a.c1 * b.c3.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt3x4).</param>
        /// <param name="b">The second matrix (UInt4x2).</param>
        /// <returns>The result of a * b (UInt3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3x2 Mul(UInt3x4 a, UInt4x2 b)
        {
            return new UInt3x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt3x4).</param>
        /// <param name="b">The second matrix (UInt4x3).</param>
        /// <returns>The result of a * b (UInt3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3x3 Mul(UInt3x4 a, UInt4x3 b)
        {
            return new UInt3x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt3x4).</param>
        /// <param name="b">The second matrix (UInt4x4).</param>
        /// <returns>The result of a * b (UInt3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3x4 Mul(UInt3x4 a, UInt4x4 b)
        {
            return new UInt3x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z + a.c3 * b.c0.W,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z + a.c3 * b.c1.W,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z + a.c3 * b.c2.W,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z + a.c3 * b.c3.W
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt4x2).</param>
        /// <param name="b">The second matrix (UInt2x2).</param>
        /// <returns>The result of a * b (UInt4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4x2 Mul(UInt4x2 a, UInt2x2 b)
        {
            return new UInt4x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt4x2).</param>
        /// <param name="b">The second matrix (UInt2x3).</param>
        /// <returns>The result of a * b (UInt4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4x3 Mul(UInt4x2 a, UInt2x3 b)
        {
            return new UInt4x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt4x2).</param>
        /// <param name="b">The second matrix (UInt2x4).</param>
        /// <returns>The result of a * b (UInt4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4x4 Mul(UInt4x2 a, UInt2x4 b)
        {
            return new UInt4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y,
                a.c0 * b.c1.X + a.c1 * b.c1.Y,
                a.c0 * b.c2.X + a.c1 * b.c2.Y,
                a.c0 * b.c3.X + a.c1 * b.c3.Y
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt4x3).</param>
        /// <param name="b">The second matrix (UInt3x2).</param>
        /// <returns>The result of a * b (UInt4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4x2 Mul(UInt4x3 a, UInt3x2 b)
        {
            return new UInt4x2(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt4x3).</param>
        /// <param name="b">The second matrix (UInt3x3).</param>
        /// <returns>The result of a * b (UInt4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4x3 Mul(UInt4x3 a, UInt3x3 b)
        {
            return new UInt4x3(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z
            );
        }

        /// <summary>Returns the result of a matrix-matrix multiplication.</summary>
        /// <param name="a">The first matrix (UInt4x3).</param>
        /// <param name="b">The second matrix (UInt3x4).</param>
        /// <returns>The result of a * b (UInt4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4x4 Mul(UInt4x3 a, UInt3x4 b)
        {
            return new UInt4x4(
                a.c0 * b.c0.X + a.c1 * b.c0.Y + a.c2 * b.c0.Z,
                a.c0 * b.c1.X + a.c1 * b.c1.Y + a.c2 * b.c1.Z,
                a.c0 * b.c2.X + a.c1 * b.c2.Y + a.c2 * b.c2.Z,
                a.c0 * b.c3.X + a.c1 * b.c3.Y + a.c2 * b.c3.Z
            );
        }














        // Normalize functions
        /// <summary>Returns the normalized version of a Float2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Normalize(Float2 x) { return x.Normalized; }
        /// <summary>Returns the normalized version of a Float3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Normalize(Float3 x) { return x.Normalized; }
        /// <summary>Returns the normalized version of a Float4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Normalize(Float4 x) { return x.Normalized; }
        /// <summary>Returns the normalized version of a Double2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Normalize(Double2 x) { return x.Normalized; }
        /// <summary>Returns the normalized version of a Double3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Normalize(Double3 x) { return x.Normalized; }
        /// <summary>Returns the normalized version of a Double4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Normalize(Double4 x) { return x.Normalized; }
        // OrthoNormalize functions
        /// <summary>Orthonormalizes a set of three vectors using Gram-Schmidt process.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrthoNormalize(ref Float3 normal, ref Float3 tangent, ref Float3 binormal)
        {
            normal = Normalize(normal);
            tangent = Normalize(tangent - Project(tangent, normal));
            binormal = Cross(normal, tangent);
        }

        /// <summary>Orthonormalizes two vectors using Gram-Schmidt process.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrthoNormalize(ref Float3 normal, ref Float3 tangent)
        {
            normal = Normalize(normal);
            tangent = Normalize(tangent - Project(tangent, normal));
        }
        /// <summary>Orthonormalizes a set of three vectors using Gram-Schmidt process.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrthoNormalize(ref Double3 normal, ref Double3 tangent, ref Double3 binormal)
        {
            normal = Normalize(normal);
            tangent = Normalize(tangent - Project(tangent, normal));
            binormal = Cross(normal, tangent);
        }

        /// <summary>Orthonormalizes two vectors using Gram-Schmidt process.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrthoNormalize(ref Double3 normal, ref Double3 tangent)
        {
            normal = Normalize(normal);
            tangent = Normalize(tangent - Project(tangent, normal));
        }
        // PingPong functions
        /// <summary>PingPongs the value t, so that it is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float PingPong(float t, float length)
        {
            t = Repeat(t, length * 2f);
            return length - Abs(t - length);
        }
        /// <summary>PingPongs the value t, so that it is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double PingPong(double t, double length)
        {
            t = Repeat(t, length * 2);
            return length - Abs(t - length);
        }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 PingPong(Float2 t, Float2 length) { return new Float2(PingPong(t.X, length.X), PingPong(t.Y, length.Y)); }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 PingPong(Float3 t, Float3 length) { return new Float3(PingPong(t.X, length.X), PingPong(t.Y, length.Y), PingPong(t.Z, length.Z)); }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 PingPong(Float4 t, Float4 length) { return new Float4(PingPong(t.X, length.X), PingPong(t.Y, length.Y), PingPong(t.Z, length.Z), PingPong(t.W, length.W)); }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 PingPong(Double2 t, Double2 length) { return new Double2(PingPong(t.X, length.X), PingPong(t.Y, length.Y)); }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 PingPong(Double3 t, Double3 length) { return new Double3(PingPong(t.X, length.X), PingPong(t.Y, length.Y), PingPong(t.Z, length.Z)); }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 PingPong(Double4 t, Double4 length) { return new Double4(PingPong(t.X, length.X), PingPong(t.Y, length.Y), PingPong(t.Z, length.Z), PingPong(t.W, length.W)); }
        // Pow functions
        /// <summary>Returns x raised to the power of y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Pow(float x, float y) { return MathF.Pow(x, y); }
        /// <summary>Returns x raised to the power of y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Pow(double x, double y) { return Math.Pow(x, y); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Pow(Float2 x, Float2 y) { return new Float2(Pow(x.X, y.X), Pow(x.Y, y.Y)); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Pow(Float3 x, Float3 y) { return new Float3(Pow(x.X, y.X), Pow(x.Y, y.Y), Pow(x.Z, y.Z)); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Pow(Float4 x, Float4 y) { return new Float4(Pow(x.X, y.X), Pow(x.Y, y.Y), Pow(x.Z, y.Z), Pow(x.W, y.W)); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Pow(Double2 x, Double2 y) { return new Double2(Pow(x.X, y.X), Pow(x.Y, y.Y)); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Pow(Double3 x, Double3 y) { return new Double3(Pow(x.X, y.X), Pow(x.Y, y.Y), Pow(x.Z, y.Z)); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Pow(Double4 x, Double4 y) { return new Double4(Pow(x.X, y.X), Pow(x.Y, y.Y), Pow(x.Z, y.Z), Pow(x.W, y.W)); }
        // Project functions
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Project(Float2 a, Float2 b)
        {
            float denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Float2.Zero;
            return b * (Dot(a, b) / denominator);
        }
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Project(Float3 a, Float3 b)
        {
            float denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Float3.Zero;
            return b * (Dot(a, b) / denominator);
        }
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Project(Float4 a, Float4 b)
        {
            float denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Float4.Zero;
            return b * (Dot(a, b) / denominator);
        }
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Project(Double2 a, Double2 b)
        {
            double denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Double2.Zero;
            return b * (Dot(a, b) / denominator);
        }
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Project(Double3 a, Double3 b)
        {
            double denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Double3.Zero;
            return b * (Dot(a, b) / denominator);
        }
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Project(Double4 a, Double4 b)
        {
            double denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Double4.Zero;
            return b * (Dot(a, b) / denominator);
        }
        // ProjectOntoPlane functions
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 ProjectOntoPlane(Float2 vector, Float2 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 ProjectOntoPlane(Float3 vector, Float3 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 ProjectOntoPlane(Float4 vector, Float4 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 ProjectOntoPlane(Double2 vector, Double2 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 ProjectOntoPlane(Double3 vector, Double3 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 ProjectOntoPlane(Double4 vector, Double4 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        // Reflect functions
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Reflect(Float2 vector, Float2 normal)
        {
            float dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Reflect(Float3 vector, Float3 normal)
        {
            float dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Reflect(Float4 vector, Float4 normal)
        {
            float dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Reflect(Double2 vector, Double2 normal)
        {
            double dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Reflect(Double3 vector, Double3 normal)
        {
            double dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Reflect(Double4 vector, Double4 normal)
        {
            double dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        // Refract functions
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Refract(Float2 incident, Float2 normal, float eta)
        {
            float dotNI = Dot(normal, incident);
            float k = 1f - eta * eta * (1f - dotNI * dotNI);
            return k < 0f ? new Float2(0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Refract(Float3 incident, Float3 normal, float eta)
        {
            float dotNI = Dot(normal, incident);
            float k = 1f - eta * eta * (1f - dotNI * dotNI);
            return k < 0f ? new Float3(0, 0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Refract(Float4 incident, Float4 normal, float eta)
        {
            float dotNI = Dot(normal, incident);
            float k = 1f - eta * eta * (1f - dotNI * dotNI);
            return k < 0f ? new Float4(0, 0, 0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Refract(Double2 incident, Double2 normal, double eta)
        {
            double dotNI = Dot(normal, incident);
            double k = 1 - eta * eta * (1 - dotNI * dotNI);
            return k < 0 ? new Double2(0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Refract(Double3 incident, Double3 normal, double eta)
        {
            double dotNI = Dot(normal, incident);
            double k = 1 - eta * eta * (1 - dotNI * dotNI);
            return k < 0 ? new Double3(0, 0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Refract(Double4 incident, Double4 normal, double eta)
        {
            double dotNI = Dot(normal, incident);
            double k = 1 - eta * eta * (1 - dotNI * dotNI);
            return k < 0 ? new Double4(0, 0, 0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        // Remap functions
        /// <summary>Remaps a value from one range to another.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Remap(float value, float inputMin, float inputMax, float outputMin, float outputMax)
        {
            return outputMin + ((value - inputMin) * (outputMax - outputMin) / (inputMax - inputMin));
        }
        /// <summary>Remaps a value from one range to another.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Remap(double value, double inputMin, double inputMax, double outputMin, double outputMax)
        {
            return outputMin + ((value - inputMin) * (outputMax - outputMin) / (inputMax - inputMin));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Remap(Float2 value, Float2 inputMin, Float2 inputMax, Float2 outputMin, Float2 outputMax)
        {
            return new Float2(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Remap(Float3 value, Float3 inputMin, Float3 inputMax, Float3 outputMin, Float3 outputMax)
        {
            return new Float3(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y), Remap(value.Z, inputMin.Z, inputMax.Z, outputMin.Z, outputMax.Z));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Remap(Float4 value, Float4 inputMin, Float4 inputMax, Float4 outputMin, Float4 outputMax)
        {
            return new Float4(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y), Remap(value.Z, inputMin.Z, inputMax.Z, outputMin.Z, outputMax.Z), Remap(value.W, inputMin.W, inputMax.W, outputMin.W, outputMax.W));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Remap(Double2 value, Double2 inputMin, Double2 inputMax, Double2 outputMin, Double2 outputMax)
        {
            return new Double2(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Remap(Double3 value, Double3 inputMin, Double3 inputMax, Double3 outputMin, Double3 outputMax)
        {
            return new Double3(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y), Remap(value.Z, inputMin.Z, inputMax.Z, outputMin.Z, outputMax.Z));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Remap(Double4 value, Double4 inputMin, Double4 inputMax, Double4 outputMin, Double4 outputMax)
        {
            return new Double4(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y), Remap(value.Z, inputMin.Z, inputMax.Z, outputMin.Z, outputMax.Z), Remap(value.W, inputMin.W, inputMax.W, outputMin.W, outputMax.W));
        }
        // Repeat functions
        /// <summary>Wraps the given value between 0 and length.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Repeat(float t, float length)
        {
            return Clamp(t - MathF.Floor(t / length) * length, 0f, length);
        }
        /// <summary>Wraps the given value between 0 and length.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Repeat(double t, double length)
        {
            return Clamp(t - Math.Floor(t / length) * length, 0, length);
        }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Repeat(Float2 t, Float2 length) { return new Float2(Repeat(t.X, length.X), Repeat(t.Y, length.Y)); }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Repeat(Float3 t, Float3 length) { return new Float3(Repeat(t.X, length.X), Repeat(t.Y, length.Y), Repeat(t.Z, length.Z)); }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Repeat(Float4 t, Float4 length) { return new Float4(Repeat(t.X, length.X), Repeat(t.Y, length.Y), Repeat(t.Z, length.Z), Repeat(t.W, length.W)); }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Repeat(Double2 t, Double2 length) { return new Double2(Repeat(t.X, length.X), Repeat(t.Y, length.Y)); }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Repeat(Double3 t, Double3 length) { return new Double3(Repeat(t.X, length.X), Repeat(t.Y, length.Y), Repeat(t.Z, length.Z)); }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Repeat(Double4 t, Double4 length) { return new Double4(Repeat(t.X, length.X), Repeat(t.Y, length.Y), Repeat(t.Z, length.Z), Repeat(t.W, length.W)); }
        // RGBToHSL functions
        /// <summary>Converts RGB to HSL color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 RGBToHSL(Float3 rgb)
        {
            float r = rgb.X, g = rgb.Y, b = rgb.Z;
            float max = Max(r, Max(g, b));
            float min = Min(r, Min(g, b));
            float delta = max - min;

            float h = 0f, s = 0f, l = (max + min) / 2f;

            if (delta > 0f)
            {
                s = l > 0.5f ? delta / (2f - max - min) : delta / (max + min);

                if (max == r)
                    h = 60f * (((g - b) / delta) % 6f);
                else if (max == g)
                    h = 60f * ((b - r) / delta + 2f);
                else if (max == b)
                    h = 60f * ((r - g) / delta + 4f);

                if (h < 0f) h += 360f;
            }

            return new Float3(h, s, l);
        }
        /// <summary>Converts RGB to HSL color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 RGBToHSL(Float4 rgba)
        {
            float r = rgba.X, g = rgba.Y, b = rgba.Z;
            float max = Max(r, Max(g, b));
            float min = Min(r, Min(g, b));
            float delta = max - min;

            float h = 0f, s = 0f, l = (max + min) / 2f;

            if (delta > 0f)
            {
                s = l > 0.5f ? delta / (2f - max - min) : delta / (max + min);

                if (max == r)
                    h = 60f * (((g - b) / delta) % 6f);
                else if (max == g)
                    h = 60f * ((b - r) / delta + 2f);
                else if (max == b)
                    h = 60f * ((r - g) / delta + 4f);

                if (h < 0f) h += 360f;
            }

            return new Float4(h, s, l, rgba.W);
        }
        /// <summary>Converts RGB to HSL color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 RGBToHSL(Byte3 rgb)
        {
            float r = rgb.X / 255f, g = rgb.Y / 255f, b = rgb.Z / 255f;
            float max = Max(r, Max(g, b));
            float min = Min(r, Min(g, b));
            float delta = max - min;

            float h = 0f, s = 0f, l = (max + min) / 2f;

            if (delta > 0f)
            {
                s = l > 0.5f ? delta / (2f - max - min) : delta / (max + min);

                if (max == r)
                    h = 60f * (((g - b) / delta) % 6f);
                else if (max == g)
                    h = 60f * ((b - r) / delta + 2f);
                else if (max == b)
                    h = 60f * ((r - g) / delta + 4f);

                if (h < 0f) h += 360f;
            }

            return new Byte3((byte)(h * 255f / 360f), (byte)(s * 255f), (byte)(l * 255f));
        }
        /// <summary>Converts RGB to HSL color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 RGBToHSL(Byte4 rgba)
        {
            float r = rgba.X / 255f, g = rgba.Y / 255f, b = rgba.Z / 255f;
            float max = Max(r, Max(g, b));
            float min = Min(r, Min(g, b));
            float delta = max - min;

            float h = 0f, s = 0f, l = (max + min) / 2f;

            if (delta > 0f)
            {
                s = l > 0.5f ? delta / (2f - max - min) : delta / (max + min);

                if (max == r)
                    h = 60f * (((g - b) / delta) % 6f);
                else if (max == g)
                    h = 60f * ((b - r) / delta + 2f);
                else if (max == b)
                    h = 60f * ((r - g) / delta + 4f);

                if (h < 0f) h += 360f;
            }

            return new Byte4((byte)(h * 255f / 360f), (byte)(s * 255f), (byte)(l * 255f), rgba.W);
        }
        // RGBToHSV functions
        /// <summary>Converts RGB to HSV color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 RGBToHSV(Float3 rgb)
        {
            float r = rgb.X, g = rgb.Y, b = rgb.Z;
            float max = Max(r, Max(g, b));
            float min = Min(r, Min(g, b));
            float delta = max - min;

            float h = 0f, s = 0f, v = max;

            if (delta > 0f)
            {
                s = delta / max;

                if (max == r)
                    h = 60f * (((g - b) / delta) % 6f);
                else if (max == g)
                    h = 60f * ((b - r) / delta + 2f);
                else if (max == b)
                    h = 60f * ((r - g) / delta + 4f);

                if (h < 0f) h += 360f;
            }

            return new Float3(h, s, v);
        }
        /// <summary>Converts RGB to HSV color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 RGBToHSV(Float4 rgba)
        {
            float r = rgba.X, g = rgba.Y, b = rgba.Z;
            float max = Max(r, Max(g, b));
            float min = Min(r, Min(g, b));
            float delta = max - min;

            float h = 0f, s = 0f, v = max;

            if (delta > 0f)
            {
                s = delta / max;

                if (max == r)
                    h = 60f * (((g - b) / delta) % 6f);
                else if (max == g)
                    h = 60f * ((b - r) / delta + 2f);
                else if (max == b)
                    h = 60f * ((r - g) / delta + 4f);

                if (h < 0f) h += 360f;
            }

            return new Float4(h, s, v, rgba.W);
        }
        /// <summary>Converts RGB to HSV color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 RGBToHSV(Byte3 rgb)
        {
            float r = rgb.X / 255f, g = rgb.Y / 255f, b = rgb.Z / 255f;
            float max = Max(r, Max(g, b));
            float min = Min(r, Min(g, b));
            float delta = max - min;

            float h = 0f, s = 0f, v = max;

            if (delta > 0f)
            {
                s = delta / max;

                if (max == r)
                    h = 60f * (((g - b) / delta) % 6f);
                else if (max == g)
                    h = 60f * ((b - r) / delta + 2f);
                else if (max == b)
                    h = 60f * ((r - g) / delta + 4f);

                if (h < 0f) h += 360f;
            }

            return new Byte3((byte)(h * 255f / 360f), (byte)(s * 255f), (byte)(v * 255f));
        }
        /// <summary>Converts RGB to HSV color space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 RGBToHSV(Byte4 rgba)
        {
            float r = rgba.X / 255f, g = rgba.Y / 255f, b = rgba.Z / 255f;
            float max = Max(r, Max(g, b));
            float min = Min(r, Min(g, b));
            float delta = max - min;

            float h = 0f, s = 0f, v = max;

            if (delta > 0f)
            {
                s = delta / max;

                if (max == r)
                    h = 60f * (((g - b) / delta) % 6f);
                else if (max == g)
                    h = 60f * ((b - r) / delta + 2f);
                else if (max == b)
                    h = 60f * ((r - g) / delta + 4f);

                if (h < 0f) h += 360f;
            }

            return new Byte4((byte)(h * 255f / 360f), (byte)(s * 255f), (byte)(v * 255f), rgba.W);
        }
        // Round functions
        /// <summary>Returns the round of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Round(float x) { return MathF.Round(x); }
        /// <summary>Returns the round of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Round(double x) { return Math.Round(x); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Round(Float2 x) { return new Float2(Round(x.X), Round(x.Y)); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Round(Float3 x) { return new Float3(Round(x.X), Round(x.Y), Round(x.Z)); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Round(Float4 x) { return new Float4(Round(x.X), Round(x.Y), Round(x.Z), Round(x.W)); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Round(Double2 x) { return new Double2(Round(x.X), Round(x.Y)); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Round(Double3 x) { return new Double3(Round(x.X), Round(x.Y), Round(x.Z)); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Round(Double4 x) { return new Double4(Round(x.X), Round(x.Y), Round(x.Z), Round(x.W)); }
        // RoundToInt functions
        /// <summary>Rounds a value to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int RoundToInt(float x) { return (int)MathF.Round(x); }
        /// <summary>Rounds a value to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int RoundToInt(double x) { return (int)Math.Round(x); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 RoundToInt(Float2 x) { return new Int2(RoundToInt(x.X), RoundToInt(x.Y)); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 RoundToInt(Float3 x) { return new Int3(RoundToInt(x.X), RoundToInt(x.Y), RoundToInt(x.Z)); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 RoundToInt(Float4 x) { return new Int4(RoundToInt(x.X), RoundToInt(x.Y), RoundToInt(x.Z), RoundToInt(x.W)); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 RoundToInt(Double2 x) { return new Int2(RoundToInt(x.X), RoundToInt(x.Y)); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 RoundToInt(Double3 x) { return new Int3(RoundToInt(x.X), RoundToInt(x.Y), RoundToInt(x.Z)); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 RoundToInt(Double4 x) { return new Int4(RoundToInt(x.X), RoundToInt(x.Y), RoundToInt(x.Z), RoundToInt(x.W)); }
        // Saturate functions
        /// <summary>Clamps a value between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Saturate(float x) { return Clamp(x, 0f, 1f); }
        /// <summary>Clamps a value between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Saturate(double x) { return Clamp(x, 0.0, 1.0); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Saturate(Float2 x) { return new Float2(Saturate(x.X), Saturate(x.Y)); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Saturate(Float3 x) { return new Float3(Saturate(x.X), Saturate(x.Y), Saturate(x.Z)); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Saturate(Float4 x) { return new Float4(Saturate(x.X), Saturate(x.Y), Saturate(x.Z), Saturate(x.W)); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Saturate(Double2 x) { return new Double2(Saturate(x.X), Saturate(x.Y)); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Saturate(Double3 x) { return new Double3(Saturate(x.X), Saturate(x.Y), Saturate(x.Z)); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Saturate(Double4 x) { return new Double4(Saturate(x.X), Saturate(x.Y), Saturate(x.Z), Saturate(x.W)); }
        // Sign functions
        /// <summary>Returns the sign of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Sign(float x) { return MathF.Sign(x); }
        /// <summary>Returns the sign of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Sign(double x) { return Math.Sign(x); }
        /// <summary>Returns the sign of int x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Sign(int x) { return Math.Sign(x); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Sign(Float2 x) { return new Float2(Sign(x.X), Sign(x.Y)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Sign(Float3 x) { return new Float3(Sign(x.X), Sign(x.Y), Sign(x.Z)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Sign(Float4 x) { return new Float4(Sign(x.X), Sign(x.Y), Sign(x.Z), Sign(x.W)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Sign(Double2 x) { return new Double2(Sign(x.X), Sign(x.Y)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Sign(Double3 x) { return new Double3(Sign(x.X), Sign(x.Y), Sign(x.Z)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Sign(Double4 x) { return new Double4(Sign(x.X), Sign(x.Y), Sign(x.Z), Sign(x.W)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Sign(Int2 x) { return new Int2(Sign(x.X), Sign(x.Y)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Sign(Int3 x) { return new Int3(Sign(x.X), Sign(x.Y), Sign(x.Z)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Sign(Int4 x) { return new Int4(Sign(x.X), Sign(x.Y), Sign(x.Z), Sign(x.W)); }
        // SignedAngleBetween functions
        /// <summary>Returns the signed angle in radians between two 2D vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float SignedAngleBetween(Float2 a, Float2 b)
        {
            return MathF.Atan2(a.X * b.Y - a.Y * b.X, a.X * b.X + a.Y * b.Y);
        }
        /// <summary>Returns the signed angle in radians between two 3D vectors around a reference axis.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float SignedAngleBetween(Float3 a, Float3 b, Float3 axis)
        {
            float angle = AngleBetween(a, b);
            Float3 cross = Cross(a, b);
            float sign = Dot(cross, axis) < 0f ? -1f : 1f;
            return angle * sign;
        }
        /// <summary>Returns the signed angle in radians between two 2D vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double SignedAngleBetween(Double2 a, Double2 b)
        {
            return Math.Atan2(a.X * b.Y - a.Y * b.X, a.X * b.X + a.Y * b.Y);
        }
        /// <summary>Returns the signed angle in radians between two 3D vectors around a reference axis.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double SignedAngleBetween(Double3 a, Double3 b, Double3 axis)
        {
            double angle = AngleBetween(a, b);
            Double3 cross = Cross(a, b);
            double sign = Dot(cross, axis) < 0 ? -1 : 1;
            return angle * sign;
        }
        // Sin functions
        /// <summary>Returns the sin of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Sin(float x) { return MathF.Sin(x); }
        /// <summary>Returns the sin of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Sin(double x) { return Math.Sin(x); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Sin(Float2 x) { return new Float2(Sin(x.X), Sin(x.Y)); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Sin(Float3 x) { return new Float3(Sin(x.X), Sin(x.Y), Sin(x.Z)); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Sin(Float4 x) { return new Float4(Sin(x.X), Sin(x.Y), Sin(x.Z), Sin(x.W)); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Sin(Double2 x) { return new Double2(Sin(x.X), Sin(x.Y)); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Sin(Double3 x) { return new Double3(Sin(x.X), Sin(x.Y), Sin(x.Z)); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Sin(Double4 x) { return new Double4(Sin(x.X), Sin(x.Y), Sin(x.Z), Sin(x.W)); }
        // Slerp functions
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Slerp(Float2 a, Float2 b, float t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Slerp(Float3 a, Float3 b, float t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Slerp(Float4 a, Float4 b, float t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Slerp(Double2 a, Double2 b, double t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Slerp(Double3 a, Double3 b, double t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Slerp(Double4 a, Double4 b, double t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        // SlerpUnclamped functions
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 SlerpUnclamped(Float2 a, Float2 b, float t)
        {
            Float2 result;

            // Normalize the vectors
            Float2 normalizedA = Normalize(a);
            Float2 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            float dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0f)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1f - 1e-6f)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            float angle = MathF.Acos(Abs(dot));
            float sinAngle = MathF.Sin(angle);
            
            // Calculate the scale factors
            float scale1 = MathF.Sin((1f - t) * angle) / sinAngle;
            float scale2 = MathF.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 SlerpUnclamped(Float3 a, Float3 b, float t)
        {
            Float3 result;

            // Normalize the vectors
            Float3 normalizedA = Normalize(a);
            Float3 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            float dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0f)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1f - 1e-6f)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            float angle = MathF.Acos(Abs(dot));
            float sinAngle = MathF.Sin(angle);
            
            // Calculate the scale factors
            float scale1 = MathF.Sin((1f - t) * angle) / sinAngle;
            float scale2 = MathF.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 SlerpUnclamped(Float4 a, Float4 b, float t)
        {
            Float4 result;

            // Normalize the vectors
            Float4 normalizedA = Normalize(a);
            Float4 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            float dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0f)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1f - 1e-6f)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            float angle = MathF.Acos(Abs(dot));
            float sinAngle = MathF.Sin(angle);
            
            // Calculate the scale factors
            float scale1 = MathF.Sin((1f - t) * angle) / sinAngle;
            float scale2 = MathF.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 SlerpUnclamped(Double2 a, Double2 b, double t)
        {
            Double2 result;

            // Normalize the vectors
            Double2 normalizedA = Normalize(a);
            Double2 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            double dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1 - 1e-15)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            double angle = Math.Acos(Abs(dot));
            double sinAngle = Math.Sin(angle);
            
            // Calculate the scale factors
            double scale1 = Math.Sin((1 - t) * angle) / sinAngle;
            double scale2 = Math.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 SlerpUnclamped(Double3 a, Double3 b, double t)
        {
            Double3 result;

            // Normalize the vectors
            Double3 normalizedA = Normalize(a);
            Double3 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            double dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1 - 1e-15)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            double angle = Math.Acos(Abs(dot));
            double sinAngle = Math.Sin(angle);
            
            // Calculate the scale factors
            double scale1 = Math.Sin((1 - t) * angle) / sinAngle;
            double scale2 = Math.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 SlerpUnclamped(Double4 a, Double4 b, double t)
        {
            Double4 result;

            // Normalize the vectors
            Double4 normalizedA = Normalize(a);
            Double4 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            double dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1 - 1e-15)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            double angle = Math.Acos(Abs(dot));
            double sinAngle = Math.Sin(angle);
            
            // Calculate the scale factors
            double scale1 = Math.Sin((1 - t) * angle) / sinAngle;
            double scale2 = Math.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        // SmoothLerp functions
        /// <summary>Smoothly interpolates between two values using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float SmoothLerp(float a, float b, float t) 
        {
            return Lerp(a, b, Smoothstep(0f, 1f, t));
        }
        /// <summary>Smoothly interpolates between two values using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double SmoothLerp(double a, double b, double t) 
        {
            return Lerp(a, b, Smoothstep(0, 1, t));
        }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 SmoothLerp(Float2 a, Float2 b, float t) { return new Float2(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t)); }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 SmoothLerp(Float3 a, Float3 b, float t) { return new Float3(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t), SmoothLerp(a.Z, b.Z, t)); }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 SmoothLerp(Float4 a, Float4 b, float t) { return new Float4(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t), SmoothLerp(a.Z, b.Z, t), SmoothLerp(a.W, b.W, t)); }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 SmoothLerp(Double2 a, Double2 b, double t) { return new Double2(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t)); }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 SmoothLerp(Double3 a, Double3 b, double t) { return new Double3(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t), SmoothLerp(a.Z, b.Z, t)); }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 SmoothLerp(Double4 a, Double4 b, double t) { return new Double4(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t), SmoothLerp(a.Z, b.Z, t), SmoothLerp(a.W, b.W, t)); }
        // Smoothstep functions
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Smoothstep(float edge0, float edge1, float x)
        {
            float t = Saturate((x - edge0) / (edge1 - edge0));
            return t * t * (3f - 2f * t);
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Smoothstep(double edge0, double edge1, double x)
        {
            double t = Saturate((x - edge0) / (edge1 - edge0));
            return t * t * (3 - 2 * t);
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Smoothstep(Float2 edge0, Float2 edge1, Float2 x)
        {
            return new Float2(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y));
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Smoothstep(Float3 edge0, Float3 edge1, Float3 x)
        {
            return new Float3(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y), Smoothstep(edge0.Z, edge1.Z, x.Z));
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Smoothstep(Float4 edge0, Float4 edge1, Float4 x)
        {
            return new Float4(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y), Smoothstep(edge0.Z, edge1.Z, x.Z), Smoothstep(edge0.W, edge1.W, x.W));
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Smoothstep(Double2 edge0, Double2 edge1, Double2 x)
        {
            return new Double2(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y));
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Smoothstep(Double3 edge0, Double3 edge1, Double3 x)
        {
            return new Double3(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y), Smoothstep(edge0.Z, edge1.Z, x.Z));
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Smoothstep(Double4 edge0, Double4 edge1, Double4 x)
        {
            return new Double4(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y), Smoothstep(edge0.Z, edge1.Z, x.Z), Smoothstep(edge0.W, edge1.W, x.W));
        }
        // Sqrt functions
        /// <summary>Returns the sqrt of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Sqrt(float x) { return MathF.Sqrt(x); }
        /// <summary>Returns the sqrt of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Sqrt(double x) { return Math.Sqrt(x); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Sqrt(Float2 x) { return new Float2(Sqrt(x.X), Sqrt(x.Y)); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Sqrt(Float3 x) { return new Float3(Sqrt(x.X), Sqrt(x.Y), Sqrt(x.Z)); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Sqrt(Float4 x) { return new Float4(Sqrt(x.X), Sqrt(x.Y), Sqrt(x.Z), Sqrt(x.W)); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Sqrt(Double2 x) { return new Double2(Sqrt(x.X), Sqrt(x.Y)); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Sqrt(Double3 x) { return new Double3(Sqrt(x.X), Sqrt(x.Y), Sqrt(x.Z)); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Sqrt(Double4 x) { return new Double4(Sqrt(x.X), Sqrt(x.Y), Sqrt(x.Z), Sqrt(x.W)); }
        // Step functions
        /// <summary>Returns 0 if x < edge, otherwise returns 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Step(float edge, float x) { return x < edge ? 0f : 1f; }
        /// <summary>Returns 0 if x < edge, otherwise returns 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Step(double edge, double x) { return x < edge ? 0.0 : 1.0; }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Step(Float2 edge, Float2 x) { return new Float2(Step(edge.X, x.X), Step(edge.Y, x.Y)); }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Step(Float3 edge, Float3 x) { return new Float3(Step(edge.X, x.X), Step(edge.Y, x.Y), Step(edge.Z, x.Z)); }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Step(Float4 edge, Float4 x) { return new Float4(Step(edge.X, x.X), Step(edge.Y, x.Y), Step(edge.Z, x.Z), Step(edge.W, x.W)); }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Step(Double2 edge, Double2 x) { return new Double2(Step(edge.X, x.X), Step(edge.Y, x.Y)); }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Step(Double3 edge, Double3 x) { return new Double3(Step(edge.X, x.X), Step(edge.Y, x.Y), Step(edge.Z, x.Z)); }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Step(Double4 edge, Double4 x) { return new Double4(Step(edge.X, x.X), Step(edge.Y, x.Y), Step(edge.Z, x.Z), Step(edge.W, x.W)); }
        // Tan functions
        /// <summary>Returns the tan of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Tan(float x) { return MathF.Tan(x); }
        /// <summary>Returns the tan of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Tan(double x) { return Math.Tan(x); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Tan(Float2 x) { return new Float2(Tan(x.X), Tan(x.Y)); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Tan(Float3 x) { return new Float3(Tan(x.X), Tan(x.Y), Tan(x.Z)); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Tan(Float4 x) { return new Float4(Tan(x.X), Tan(x.Y), Tan(x.Z), Tan(x.W)); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Tan(Double2 x) { return new Double2(Tan(x.X), Tan(x.Y)); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Tan(Double3 x) { return new Double3(Tan(x.X), Tan(x.Y), Tan(x.Z)); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Tan(Double4 x) { return new Double4(Tan(x.X), Tan(x.Y), Tan(x.Z), Tan(x.W)); }
        // ToDegrees functions
        /// <summary>Converts radians to degrees.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ToDegrees(float radians) { return radians * 180f / MathF.PI; }
        /// <summary>Converts radians to degrees.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double ToDegrees(double radians) { return radians * 180 / Math.PI; }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 ToDegrees(Float2 radians) { return new Float2(ToDegrees(radians.X), ToDegrees(radians.Y)); }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 ToDegrees(Float3 radians) { return new Float3(ToDegrees(radians.X), ToDegrees(radians.Y), ToDegrees(radians.Z)); }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 ToDegrees(Float4 radians) { return new Float4(ToDegrees(radians.X), ToDegrees(radians.Y), ToDegrees(radians.Z), ToDegrees(radians.W)); }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 ToDegrees(Double2 radians) { return new Double2(ToDegrees(radians.X), ToDegrees(radians.Y)); }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 ToDegrees(Double3 radians) { return new Double3(ToDegrees(radians.X), ToDegrees(radians.Y), ToDegrees(radians.Z)); }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 ToDegrees(Double4 radians) { return new Double4(ToDegrees(radians.X), ToDegrees(radians.Y), ToDegrees(radians.Z), ToDegrees(radians.W)); }
        // ToRadians functions
        /// <summary>Converts degrees to radians.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ToRadians(float degrees) { return degrees * MathF.PI / 180f; }
        /// <summary>Converts degrees to radians.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double ToRadians(double degrees) { return degrees * Math.PI / 180; }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 ToRadians(Float2 degrees) { return new Float2(ToRadians(degrees.X), ToRadians(degrees.Y)); }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 ToRadians(Float3 degrees) { return new Float3(ToRadians(degrees.X), ToRadians(degrees.Y), ToRadians(degrees.Z)); }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 ToRadians(Float4 degrees) { return new Float4(ToRadians(degrees.X), ToRadians(degrees.Y), ToRadians(degrees.Z), ToRadians(degrees.W)); }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 ToRadians(Double2 degrees) { return new Double2(ToRadians(degrees.X), ToRadians(degrees.Y)); }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 ToRadians(Double3 degrees) { return new Double3(ToRadians(degrees.X), ToRadians(degrees.Y), ToRadians(degrees.Z)); }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 ToRadians(Double4 degrees) { return new Double4(ToRadians(degrees.X), ToRadians(degrees.Y), ToRadians(degrees.Z), ToRadians(degrees.W)); }
        // Transpose functions
        /// <summary>Returns the transpose of a Float2x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Float2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x2 Transpose(Float2x2 m)
        {
            return new Float2x2(
                new Float2(m.c0.X, m.c1.X),
                new Float2(m.c0.Y, m.c1.Y)
            );
        }


        /// <summary>Returns the transpose of a Float3x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Float3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x3 Transpose(Float3x3 m)
        {
            return new Float3x3(
                new Float3(m.c0.X, m.c1.X, m.c2.X),
                new Float3(m.c0.Y, m.c1.Y, m.c2.Y),
                new Float3(m.c0.Z, m.c1.Z, m.c2.Z)
            );
        }


        /// <summary>Returns the transpose of a Float4x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Float4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x4 Transpose(Float4x4 m)
        {
            return new Float4x4(
                new Float4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new Float4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y),
                new Float4(m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z),
                new Float4(m.c0.W, m.c1.W, m.c2.W, m.c3.W)
            );
        }


        /// <summary>Returns the transpose of a Float2x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Float3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x2 Transpose(Float2x3 m)
        {
            return new Float3x2(
                new Float3(m.c0.X, m.c1.X, m.c2.X),
                new Float3(m.c0.Y, m.c1.Y, m.c2.Y)
            );
        }


        /// <summary>Returns the transpose of a Float2x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Float4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x2 Transpose(Float2x4 m)
        {
            return new Float4x2(
                new Float4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new Float4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y)
            );
        }


        /// <summary>Returns the transpose of a Float3x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Float2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x3 Transpose(Float3x2 m)
        {
            return new Float2x3(
                new Float2(m.c0.X, m.c1.X),
                new Float2(m.c0.Y, m.c1.Y),
                new Float2(m.c0.Z, m.c1.Z)
            );
        }


        /// <summary>Returns the transpose of a Float3x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Float4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x3 Transpose(Float3x4 m)
        {
            return new Float4x3(
                new Float4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new Float4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y),
                new Float4(m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z)
            );
        }


        /// <summary>Returns the transpose of a Float4x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Float2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x4 Transpose(Float4x2 m)
        {
            return new Float2x4(
                new Float2(m.c0.X, m.c1.X),
                new Float2(m.c0.Y, m.c1.Y),
                new Float2(m.c0.Z, m.c1.Z),
                new Float2(m.c0.W, m.c1.W)
            );
        }


        /// <summary>Returns the transpose of a Float4x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Float3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x4 Transpose(Float4x3 m)
        {
            return new Float3x4(
                new Float3(m.c0.X, m.c1.X, m.c2.X),
                new Float3(m.c0.Y, m.c1.Y, m.c2.Y),
                new Float3(m.c0.Z, m.c1.Z, m.c2.Z),
                new Float3(m.c0.W, m.c1.W, m.c2.W)
            );
        }





        /// <summary>Returns the transpose of a Double2x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Double2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x2 Transpose(Double2x2 m)
        {
            return new Double2x2(
                new Double2(m.c0.X, m.c1.X),
                new Double2(m.c0.Y, m.c1.Y)
            );
        }


        /// <summary>Returns the transpose of a Double3x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Double3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x3 Transpose(Double3x3 m)
        {
            return new Double3x3(
                new Double3(m.c0.X, m.c1.X, m.c2.X),
                new Double3(m.c0.Y, m.c1.Y, m.c2.Y),
                new Double3(m.c0.Z, m.c1.Z, m.c2.Z)
            );
        }


        /// <summary>Returns the transpose of a Double4x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Double4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x4 Transpose(Double4x4 m)
        {
            return new Double4x4(
                new Double4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new Double4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y),
                new Double4(m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z),
                new Double4(m.c0.W, m.c1.W, m.c2.W, m.c3.W)
            );
        }


        /// <summary>Returns the transpose of a Double2x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Double3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x2 Transpose(Double2x3 m)
        {
            return new Double3x2(
                new Double3(m.c0.X, m.c1.X, m.c2.X),
                new Double3(m.c0.Y, m.c1.Y, m.c2.Y)
            );
        }


        /// <summary>Returns the transpose of a Double2x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Double4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x2 Transpose(Double2x4 m)
        {
            return new Double4x2(
                new Double4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new Double4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y)
            );
        }


        /// <summary>Returns the transpose of a Double3x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Double2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x3 Transpose(Double3x2 m)
        {
            return new Double2x3(
                new Double2(m.c0.X, m.c1.X),
                new Double2(m.c0.Y, m.c1.Y),
                new Double2(m.c0.Z, m.c1.Z)
            );
        }


        /// <summary>Returns the transpose of a Double3x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Double4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x3 Transpose(Double3x4 m)
        {
            return new Double4x3(
                new Double4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new Double4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y),
                new Double4(m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z)
            );
        }


        /// <summary>Returns the transpose of a Double4x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Double2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x4 Transpose(Double4x2 m)
        {
            return new Double2x4(
                new Double2(m.c0.X, m.c1.X),
                new Double2(m.c0.Y, m.c1.Y),
                new Double2(m.c0.Z, m.c1.Z),
                new Double2(m.c0.W, m.c1.W)
            );
        }


        /// <summary>Returns the transpose of a Double4x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Double3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x4 Transpose(Double4x3 m)
        {
            return new Double3x4(
                new Double3(m.c0.X, m.c1.X, m.c2.X),
                new Double3(m.c0.Y, m.c1.Y, m.c2.Y),
                new Double3(m.c0.Z, m.c1.Z, m.c2.Z),
                new Double3(m.c0.W, m.c1.W, m.c2.W)
            );
        }





        /// <summary>Returns the transpose of a Int2x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Int2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2x2 Transpose(Int2x2 m)
        {
            return new Int2x2(
                new Int2(m.c0.X, m.c1.X),
                new Int2(m.c0.Y, m.c1.Y)
            );
        }


        /// <summary>Returns the transpose of a Int3x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Int3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3x3 Transpose(Int3x3 m)
        {
            return new Int3x3(
                new Int3(m.c0.X, m.c1.X, m.c2.X),
                new Int3(m.c0.Y, m.c1.Y, m.c2.Y),
                new Int3(m.c0.Z, m.c1.Z, m.c2.Z)
            );
        }


        /// <summary>Returns the transpose of a Int4x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Int4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4x4 Transpose(Int4x4 m)
        {
            return new Int4x4(
                new Int4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new Int4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y),
                new Int4(m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z),
                new Int4(m.c0.W, m.c1.W, m.c2.W, m.c3.W)
            );
        }


        /// <summary>Returns the transpose of a Int2x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Int3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3x2 Transpose(Int2x3 m)
        {
            return new Int3x2(
                new Int3(m.c0.X, m.c1.X, m.c2.X),
                new Int3(m.c0.Y, m.c1.Y, m.c2.Y)
            );
        }


        /// <summary>Returns the transpose of a Int2x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Int4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4x2 Transpose(Int2x4 m)
        {
            return new Int4x2(
                new Int4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new Int4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y)
            );
        }


        /// <summary>Returns the transpose of a Int3x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Int2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2x3 Transpose(Int3x2 m)
        {
            return new Int2x3(
                new Int2(m.c0.X, m.c1.X),
                new Int2(m.c0.Y, m.c1.Y),
                new Int2(m.c0.Z, m.c1.Z)
            );
        }


        /// <summary>Returns the transpose of a Int3x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Int4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4x3 Transpose(Int3x4 m)
        {
            return new Int4x3(
                new Int4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new Int4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y),
                new Int4(m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z)
            );
        }


        /// <summary>Returns the transpose of a Int4x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Int2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2x4 Transpose(Int4x2 m)
        {
            return new Int2x4(
                new Int2(m.c0.X, m.c1.X),
                new Int2(m.c0.Y, m.c1.Y),
                new Int2(m.c0.Z, m.c1.Z),
                new Int2(m.c0.W, m.c1.W)
            );
        }


        /// <summary>Returns the transpose of a Int4x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (Int3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3x4 Transpose(Int4x3 m)
        {
            return new Int3x4(
                new Int3(m.c0.X, m.c1.X, m.c2.X),
                new Int3(m.c0.Y, m.c1.Y, m.c2.Y),
                new Int3(m.c0.Z, m.c1.Z, m.c2.Z),
                new Int3(m.c0.W, m.c1.W, m.c2.W)
            );
        }





        /// <summary>Returns the transpose of a UInt2x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (UInt2x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2x2 Transpose(UInt2x2 m)
        {
            return new UInt2x2(
                new UInt2(m.c0.X, m.c1.X),
                new UInt2(m.c0.Y, m.c1.Y)
            );
        }


        /// <summary>Returns the transpose of a UInt3x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (UInt3x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3x3 Transpose(UInt3x3 m)
        {
            return new UInt3x3(
                new UInt3(m.c0.X, m.c1.X, m.c2.X),
                new UInt3(m.c0.Y, m.c1.Y, m.c2.Y),
                new UInt3(m.c0.Z, m.c1.Z, m.c2.Z)
            );
        }


        /// <summary>Returns the transpose of a UInt4x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (UInt4x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4x4 Transpose(UInt4x4 m)
        {
            return new UInt4x4(
                new UInt4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new UInt4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y),
                new UInt4(m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z),
                new UInt4(m.c0.W, m.c1.W, m.c2.W, m.c3.W)
            );
        }


        /// <summary>Returns the transpose of a UInt2x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (UInt3x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3x2 Transpose(UInt2x3 m)
        {
            return new UInt3x2(
                new UInt3(m.c0.X, m.c1.X, m.c2.X),
                new UInt3(m.c0.Y, m.c1.Y, m.c2.Y)
            );
        }


        /// <summary>Returns the transpose of a UInt2x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (UInt4x2).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4x2 Transpose(UInt2x4 m)
        {
            return new UInt4x2(
                new UInt4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new UInt4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y)
            );
        }


        /// <summary>Returns the transpose of a UInt3x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (UInt2x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2x3 Transpose(UInt3x2 m)
        {
            return new UInt2x3(
                new UInt2(m.c0.X, m.c1.X),
                new UInt2(m.c0.Y, m.c1.Y),
                new UInt2(m.c0.Z, m.c1.Z)
            );
        }


        /// <summary>Returns the transpose of a UInt3x4 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (UInt4x3).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4x3 Transpose(UInt3x4 m)
        {
            return new UInt4x3(
                new UInt4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
                new UInt4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y),
                new UInt4(m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z)
            );
        }


        /// <summary>Returns the transpose of a UInt4x2 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (UInt2x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2x4 Transpose(UInt4x2 m)
        {
            return new UInt2x4(
                new UInt2(m.c0.X, m.c1.X),
                new UInt2(m.c0.Y, m.c1.Y),
                new UInt2(m.c0.Z, m.c1.Z),
                new UInt2(m.c0.W, m.c1.W)
            );
        }


        /// <summary>Returns the transpose of a UInt4x3 matrix.</summary>
        /// <param name="m">The matrix to transpose.</param>
        /// <returns>The transposed matrix (UInt3x4).</returns>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3x4 Transpose(UInt4x3 m)
        {
            return new UInt3x4(
                new UInt3(m.c0.X, m.c1.X, m.c2.X),
                new UInt3(m.c0.Y, m.c1.Y, m.c2.Y),
                new UInt3(m.c0.Z, m.c1.Z, m.c2.Z),
                new UInt3(m.c0.W, m.c1.W, m.c2.W)
            );
        }





    }
}
