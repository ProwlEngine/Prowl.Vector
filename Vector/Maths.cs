//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-05-14 00:55:48
//

using System;
using System.Runtime.CompilerServices;

namespace Prowl.Vector
{
    /// <summary>
    /// A static class containing mathematical functions for vectors and scalars.
    /// </summary>
    public static partial class Maths
    {

        // Abs functions
        /// <summary>Returns the abs of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Abs(float x) { return MathF.Abs(x); }
        /// <summary>Returns the abs of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Abs(double x) { return Math.Abs(x); }
        /// <summary>Returns the abs of int x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Abs(int x) { return Math.Abs(x); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Abs(Float2 x) { return new Float2(Abs(x.X), Abs(x.Y)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Abs(Float3 x) { return new Float3(Abs(x.X), Abs(x.Y), Abs(x.Z)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Abs(Float4 x) { return new Float4(Abs(x.X), Abs(x.Y), Abs(x.Z), Abs(x.W)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Abs(Double2 x) { return new Double2(Abs(x.X), Abs(x.Y)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Abs(Double3 x) { return new Double3(Abs(x.X), Abs(x.Y), Abs(x.Z)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Abs(Double4 x) { return new Double4(Abs(x.X), Abs(x.Y), Abs(x.Z), Abs(x.W)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Abs(Int2 x) { return new Int2(Abs(x.X), Abs(x.Y)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Abs(Int3 x) { return new Int3(Abs(x.X), Abs(x.Y), Abs(x.Z)); }
        /// <summary>Returns the componentwise abs of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Abs(Int4 x) { return new Int4(Abs(x.X), Abs(x.Y), Abs(x.Z), Abs(x.W)); }
        // Acos functions
        /// <summary>Returns the acos of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Acos(float x) { return MathF.Acos(x); }
        /// <summary>Returns the acos of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Acos(double x) { return Math.Acos(x); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Acos(Float2 x) { return new Float2(Acos(x.X), Acos(x.Y)); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Acos(Float3 x) { return new Float3(Acos(x.X), Acos(x.Y), Acos(x.Z)); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Acos(Float4 x) { return new Float4(Acos(x.X), Acos(x.Y), Acos(x.Z), Acos(x.W)); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Acos(Double2 x) { return new Double2(Acos(x.X), Acos(x.Y)); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Acos(Double3 x) { return new Double3(Acos(x.X), Acos(x.Y), Acos(x.Z)); }
        /// <summary>Returns the componentwise acos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Acos(Double4 x) { return new Double4(Acos(x.X), Acos(x.Y), Acos(x.Z), Acos(x.W)); }
        // AngleBetween functions
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float AngleBetween(Float2 a, Float2 b)
        {
            float dot = Dot(Normalize(a), Normalize(b));
            return MathF.Acos(Clamp(dot, -1f, 1f));
        }
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float AngleBetween(Float3 a, Float3 b)
        {
            float dot = Dot(Normalize(a), Normalize(b));
            return MathF.Acos(Clamp(dot, -1f, 1f));
        }
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float AngleBetween(Float4 a, Float4 b)
        {
            float dot = Dot(Normalize(a), Normalize(b));
            return MathF.Acos(Clamp(dot, -1f, 1f));
        }
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double AngleBetween(Double2 a, Double2 b)
        {
            double dot = Dot(Normalize(a), Normalize(b));
            return Math.Acos(Clamp(dot, -1, 1));
        }
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double AngleBetween(Double3 a, Double3 b)
        {
            double dot = Dot(Normalize(a), Normalize(b));
            return Math.Acos(Clamp(dot, -1, 1));
        }
        /// <summary>Returns the angle in radians between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double AngleBetween(Double4 a, Double4 b)
        {
            double dot = Dot(Normalize(a), Normalize(b));
            return Math.Acos(Clamp(dot, -1, 1));
        }
        // Asin functions
        /// <summary>Returns the asin of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Asin(float x) { return MathF.Asin(x); }
        /// <summary>Returns the asin of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Asin(double x) { return Math.Asin(x); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Asin(Float2 x) { return new Float2(Asin(x.X), Asin(x.Y)); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Asin(Float3 x) { return new Float3(Asin(x.X), Asin(x.Y), Asin(x.Z)); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Asin(Float4 x) { return new Float4(Asin(x.X), Asin(x.Y), Asin(x.Z), Asin(x.W)); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Asin(Double2 x) { return new Double2(Asin(x.X), Asin(x.Y)); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Asin(Double3 x) { return new Double3(Asin(x.X), Asin(x.Y), Asin(x.Z)); }
        /// <summary>Returns the componentwise asin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Asin(Double4 x) { return new Double4(Asin(x.X), Asin(x.Y), Asin(x.Z), Asin(x.W)); }
        // Atan functions
        /// <summary>Returns the atan of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Atan(float x) { return MathF.Atan(x); }
        /// <summary>Returns the atan of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Atan(double x) { return Math.Atan(x); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Atan(Float2 x) { return new Float2(Atan(x.X), Atan(x.Y)); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Atan(Float3 x) { return new Float3(Atan(x.X), Atan(x.Y), Atan(x.Z)); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Atan(Float4 x) { return new Float4(Atan(x.X), Atan(x.Y), Atan(x.Z), Atan(x.W)); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Atan(Double2 x) { return new Double2(Atan(x.X), Atan(x.Y)); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Atan(Double3 x) { return new Double3(Atan(x.X), Atan(x.Y), Atan(x.Z)); }
        /// <summary>Returns the componentwise atan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Atan(Double4 x) { return new Double4(Atan(x.X), Atan(x.Y), Atan(x.Z), Atan(x.W)); }
        // Atan2 functions
        /// <summary>Returns the arctangent of y/x in radians.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Atan2(float x, float y) { return MathF.Atan2(x, y); }
        /// <summary>Returns the arctangent of y/x in radians.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Atan2(double x, double y) { return Math.Atan2(x, y); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Atan2(Float2 x, Float2 y) { return new Float2(Atan2(x.X, y.X), Atan2(x.Y, y.Y)); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Atan2(Float3 x, Float3 y) { return new Float3(Atan2(x.X, y.X), Atan2(x.Y, y.Y), Atan2(x.Z, y.Z)); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Atan2(Float4 x, Float4 y) { return new Float4(Atan2(x.X, y.X), Atan2(x.Y, y.Y), Atan2(x.Z, y.Z), Atan2(x.W, y.W)); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Atan2(Double2 x, Double2 y) { return new Double2(Atan2(x.X, y.X), Atan2(x.Y, y.Y)); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Atan2(Double3 x, Double3 y) { return new Double3(Atan2(x.X, y.X), Atan2(x.Y, y.Y), Atan2(x.Z, y.Z)); }
        /// <summary>Returns the componentwise arctangent of y/x for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Atan2(Double4 x, Double4 y) { return new Double4(Atan2(x.X, y.X), Atan2(x.Y, y.Y), Atan2(x.Z, y.Z), Atan2(x.W, y.W)); }
        // Ceiling functions
        /// <summary>Returns the ceiling of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Ceiling(float x) { return MathF.Ceiling(x); }
        /// <summary>Returns the ceiling of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Ceiling(double x) { return Math.Ceiling(x); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Ceiling(Float2 x) { return new Float2(Ceiling(x.X), Ceiling(x.Y)); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Ceiling(Float3 x) { return new Float3(Ceiling(x.X), Ceiling(x.Y), Ceiling(x.Z)); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Ceiling(Float4 x) { return new Float4(Ceiling(x.X), Ceiling(x.Y), Ceiling(x.Z), Ceiling(x.W)); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Ceiling(Double2 x) { return new Double2(Ceiling(x.X), Ceiling(x.Y)); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Ceiling(Double3 x) { return new Double3(Ceiling(x.X), Ceiling(x.Y), Ceiling(x.Z)); }
        /// <summary>Returns the componentwise ceiling of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Ceiling(Double4 x) { return new Double4(Ceiling(x.X), Ceiling(x.Y), Ceiling(x.Z), Ceiling(x.W)); }
        // CeilToInt functions
        /// <summary>Ceils a value to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CeilToInt(float x) { return (int)MathF.Ceiling(x); }
        /// <summary>Ceils a value to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int CeilToInt(double x) { return (int)Math.Ceiling(x); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 CeilToInt(Float2 x) { return new Int2(CeilToInt(x.X), CeilToInt(x.Y)); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 CeilToInt(Float3 x) { return new Int3(CeilToInt(x.X), CeilToInt(x.Y), CeilToInt(x.Z)); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 CeilToInt(Float4 x) { return new Int4(CeilToInt(x.X), CeilToInt(x.Y), CeilToInt(x.Z), CeilToInt(x.W)); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 CeilToInt(Double2 x) { return new Int2(CeilToInt(x.X), CeilToInt(x.Y)); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 CeilToInt(Double3 x) { return new Int3(CeilToInt(x.X), CeilToInt(x.Y), CeilToInt(x.Z)); }
        /// <summary>Ceils each component to the nearest higher integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 CeilToInt(Double4 x) { return new Int4(CeilToInt(x.X), CeilToInt(x.Y), CeilToInt(x.Z), CeilToInt(x.W)); }
        // Clamp functions
        /// <summary>Clamps float x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Clamp(float x, float min, float max) { return (float)Math.Clamp(x, min, max); }
        /// <summary>Clamps double x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Clamp(double x, double min, double max) { return (double)Math.Clamp(x, min, max); }
        /// <summary>Clamps int x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Clamp(int x, int min, int max) { return (int)Math.Clamp(x, min, max); }
        /// <summary>Clamps byte x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte Clamp(byte x, byte min, byte max) { return (byte)Math.Clamp(x, min, max); }
        /// <summary>Clamps ushort x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Clamp(ushort x, ushort min, ushort max) { return (ushort)Math.Clamp(x, min, max); }
        /// <summary>Clamps uint x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Clamp(uint x, uint min, uint max) { return (uint)Math.Clamp(x, min, max); }
        /// <summary>Clamps ulong x between min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Clamp(ulong x, ulong min, ulong max) { return (ulong)Math.Clamp(x, min, max); }
        /// <summary>Returns the componentwise clamp of a Float2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Clamp(Float2 x, Float2 min, Float2 max) { return new Float2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a Float2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Clamp(Float2 x, float min, float max) { return new Float2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a Float3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Clamp(Float3 x, Float3 min, Float3 max) { return new Float3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a Float3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Clamp(Float3 x, float min, float max) { return new Float3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a Float4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Clamp(Float4 x, Float4 min, Float4 max) { return new Float4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a Float4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Clamp(Float4 x, float min, float max) { return new Float4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a Double2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Clamp(Double2 x, Double2 min, Double2 max) { return new Double2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a Double2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Clamp(Double2 x, double min, double max) { return new Double2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a Double3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Clamp(Double3 x, Double3 min, Double3 max) { return new Double3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a Double3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Clamp(Double3 x, double min, double max) { return new Double3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a Double4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Clamp(Double4 x, Double4 min, Double4 max) { return new Double4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a Double4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Clamp(Double4 x, double min, double max) { return new Double4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a Int2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Clamp(Int2 x, Int2 min, Int2 max) { return new Int2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a Int2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Clamp(Int2 x, int min, int max) { return new Int2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a Int3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Clamp(Int3 x, Int3 min, Int3 max) { return new Int3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a Int3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Clamp(Int3 x, int min, int max) { return new Int3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a Int4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Clamp(Int4 x, Int4 min, Int4 max) { return new Int4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a Int4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Clamp(Int4 x, int min, int max) { return new Int4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a Byte2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Clamp(Byte2 x, Byte2 min, Byte2 max) { return new Byte2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a Byte2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Clamp(Byte2 x, byte min, byte max) { return new Byte2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a Byte3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Clamp(Byte3 x, Byte3 min, Byte3 max) { return new Byte3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a Byte3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Clamp(Byte3 x, byte min, byte max) { return new Byte3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a Byte4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Clamp(Byte4 x, Byte4 min, Byte4 max) { return new Byte4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a Byte4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Clamp(Byte4 x, byte min, byte max) { return new Byte4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a UShort2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Clamp(UShort2 x, UShort2 min, UShort2 max) { return new UShort2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a UShort2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Clamp(UShort2 x, ushort min, ushort max) { return new UShort2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a UShort3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Clamp(UShort3 x, UShort3 min, UShort3 max) { return new UShort3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a UShort3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Clamp(UShort3 x, ushort min, ushort max) { return new UShort3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a UShort4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Clamp(UShort4 x, UShort4 min, UShort4 max) { return new UShort4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a UShort4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Clamp(UShort4 x, ushort min, ushort max) { return new UShort4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a UInt2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Clamp(UInt2 x, UInt2 min, UInt2 max) { return new UInt2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a UInt2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Clamp(UInt2 x, uint min, uint max) { return new UInt2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a UInt3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Clamp(UInt3 x, UInt3 min, UInt3 max) { return new UInt3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a UInt3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Clamp(UInt3 x, uint min, uint max) { return new UInt3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a UInt4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Clamp(UInt4 x, UInt4 min, UInt4 max) { return new UInt4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a UInt4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Clamp(UInt4 x, uint min, uint max) { return new UInt4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        /// <summary>Returns the componentwise clamp of a ULong2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Clamp(ULong2 x, ULong2 min, ULong2 max) { return new ULong2(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y)); }

        /// <summary>Clamps each component of a ULong2 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Clamp(ULong2 x, ulong min, ulong max) { return new ULong2(Clamp(x.X, min, max), Clamp(x.Y, min, max)); }
        /// <summary>Returns the componentwise clamp of a ULong3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Clamp(ULong3 x, ULong3 min, ULong3 max) { return new ULong3(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z)); }

        /// <summary>Clamps each component of a ULong3 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Clamp(ULong3 x, ulong min, ulong max) { return new ULong3(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max)); }
        /// <summary>Returns the componentwise clamp of a ULong4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Clamp(ULong4 x, ULong4 min, ULong4 max) { return new ULong4(Clamp(x.X, min.X, max.X), Clamp(x.Y, min.Y, max.Y), Clamp(x.Z, min.Z, max.Z), Clamp(x.W, min.W, max.W)); }

        /// <summary>Clamps each component of a ULong4 vector between scalar min and max values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Clamp(ULong4 x, ulong min, ulong max) { return new ULong4(Clamp(x.X, min, max), Clamp(x.Y, min, max), Clamp(x.Z, min, max), Clamp(x.W, min, max)); }
        // Cos functions
        /// <summary>Returns the cos of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Cos(float x) { return MathF.Cos(x); }
        /// <summary>Returns the cos of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Cos(double x) { return Math.Cos(x); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Cos(Float2 x) { return new Float2(Cos(x.X), Cos(x.Y)); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Cos(Float3 x) { return new Float3(Cos(x.X), Cos(x.Y), Cos(x.Z)); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Cos(Float4 x) { return new Float4(Cos(x.X), Cos(x.Y), Cos(x.Z), Cos(x.W)); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Cos(Double2 x) { return new Double2(Cos(x.X), Cos(x.Y)); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Cos(Double3 x) { return new Double3(Cos(x.X), Cos(x.Y), Cos(x.Z)); }
        /// <summary>Returns the componentwise cos of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Cos(Double4 x) { return new Double4(Cos(x.X), Cos(x.Y), Cos(x.Z), Cos(x.W)); }
        // Cross functions
        /// <summary>Returns the cross product of two Float3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Cross(Float3 x, Float3 y)
        {
            return new Float3(
                x.Y * y.Z - x.Z * y.Y,
                x.Z * y.X - x.X * y.Z,
                x.X * y.Y - x.Y * y.X
            );
        }
        /// <summary>Returns the cross product of two Double3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Cross(Double3 x, Double3 y)
        {
            return new Double3(
                x.Y * y.Z - x.Z * y.Y,
                x.Z * y.X - x.X * y.Z,
                x.X * y.Y - x.Y * y.X
            );
        }
        // DeltaAngle functions
        /// <summary>Calculates the shortest angle between two angles.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DeltaAngle(float current, float target)
        {
            float delta = Repeat(target - current, 2f * MathF.PI);
            if (delta > MathF.PI)
                delta -= 2f * MathF.PI;
            return delta;
        }
        /// <summary>Calculates the shortest angle between two angles.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DeltaAngle(double current, double target)
        {
            double delta = Repeat(target - current, 2 * Math.PI);
            if (delta > Math.PI)
                delta -= 2 * Math.PI;
            return delta;
        }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 DeltaAngle(Float2 current, Float2 target) { return new Float2(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y)); }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 DeltaAngle(Float3 current, Float3 target) { return new Float3(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y), DeltaAngle(current.Z, target.Z)); }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 DeltaAngle(Float4 current, Float4 target) { return new Float4(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y), DeltaAngle(current.Z, target.Z), DeltaAngle(current.W, target.W)); }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 DeltaAngle(Double2 current, Double2 target) { return new Double2(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y)); }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 DeltaAngle(Double3 current, Double3 target) { return new Double3(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y), DeltaAngle(current.Z, target.Z)); }
        /// <summary>Calculates the shortest angle between two angle vectors componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 DeltaAngle(Double4 current, Double4 target) { return new Double4(DeltaAngle(current.X, target.X), DeltaAngle(current.Y, target.Y), DeltaAngle(current.Z, target.Z), DeltaAngle(current.W, target.W)); }
        // Distance functions
        /// <summary>Returns the distance between two Float2 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Distance(Float2 x, Float2 y)
        {
            return Length(x - y);
        }
        /// <summary>Returns the distance between two Float3 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Distance(Float3 x, Float3 y)
        {
            return Length(x - y);
        }
        /// <summary>Returns the distance between two Float4 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Distance(Float4 x, Float4 y)
        {
            return Length(x - y);
        }
        /// <summary>Returns the distance between two Double2 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Distance(Double2 x, Double2 y)
        {
            return Length(x - y);
        }
        /// <summary>Returns the distance between two Double3 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Distance(Double3 x, Double3 y)
        {
            return Length(x - y);
        }
        /// <summary>Returns the distance between two Double4 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Distance(Double4 x, Double4 y)
        {
            return Length(x - y);
        }
        // DistanceSquared functions
        /// <summary>Returns the squared distance between two Float2 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DistanceSquared(Float2 x, Float2 y)
        {
            return LengthSquared(x - y);
        }
        /// <summary>Returns the squared distance between two Float3 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DistanceSquared(Float3 x, Float3 y)
        {
            return LengthSquared(x - y);
        }
        /// <summary>Returns the squared distance between two Float4 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float DistanceSquared(Float4 x, Float4 y)
        {
            return LengthSquared(x - y);
        }
        /// <summary>Returns the squared distance between two Double2 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DistanceSquared(Double2 x, Double2 y)
        {
            return LengthSquared(x - y);
        }
        /// <summary>Returns the squared distance between two Double3 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DistanceSquared(Double3 x, Double3 y)
        {
            return LengthSquared(x - y);
        }
        /// <summary>Returns the squared distance between two Double4 points.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double DistanceSquared(Double4 x, Double4 y)
        {
            return LengthSquared(x - y);
        }
        // Dot functions
        /// <summary>Returns the dot product of two Float2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Dot(Float2 x, Float2 y) { return x.X * y.X + x.Y * y.Y; }
        /// <summary>Returns the dot product of two Float3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Dot(Float3 x, Float3 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z; }
        /// <summary>Returns the dot product of two Float4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Dot(Float4 x, Float4 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z + x.W * y.W; }
        /// <summary>Returns the dot product of two Double2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Dot(Double2 x, Double2 y) { return x.X * y.X + x.Y * y.Y; }
        /// <summary>Returns the dot product of two Double3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Dot(Double3 x, Double3 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z; }
        /// <summary>Returns the dot product of two Double4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Dot(Double4 x, Double4 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z + x.W * y.W; }
        /// <summary>Returns the dot product of two Int2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Dot(Int2 x, Int2 y) { return x.X * y.X + x.Y * y.Y; }
        /// <summary>Returns the dot product of two Int3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Dot(Int3 x, Int3 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z; }
        /// <summary>Returns the dot product of two Int4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Dot(Int4 x, Int4 y) { return x.X * y.X + x.Y * y.Y + x.Z * y.Z + x.W * y.W; }
        // Exp functions
        /// <summary>Returns e raised to the power of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Exp(float x) { return MathF.Exp(x); }
        /// <summary>Returns e raised to the power of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Exp(double x) { return Math.Exp(x); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Exp(Float2 x) { return new Float2(Exp(x.X), Exp(x.Y)); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Exp(Float3 x) { return new Float3(Exp(x.X), Exp(x.Y), Exp(x.Z)); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Exp(Float4 x) { return new Float4(Exp(x.X), Exp(x.Y), Exp(x.Z), Exp(x.W)); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Exp(Double2 x) { return new Double2(Exp(x.X), Exp(x.Y)); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Exp(Double3 x) { return new Double3(Exp(x.X), Exp(x.Y), Exp(x.Z)); }
        /// <summary>Returns the componentwise exponential function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Exp(Double4 x) { return new Double4(Exp(x.X), Exp(x.Y), Exp(x.Z), Exp(x.W)); }
        // Exp2 functions
        /// <summary>Returns 2 raised to the power of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Exp2(float x) { return MathF.Pow(2f, x); }
        /// <summary>Returns 2 raised to the power of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Exp2(double x) { return Math.Pow(2, x); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Exp2(Float2 x) { return new Float2(Exp2(x.X), Exp2(x.Y)); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Exp2(Float3 x) { return new Float3(Exp2(x.X), Exp2(x.Y), Exp2(x.Z)); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Exp2(Float4 x) { return new Float4(Exp2(x.X), Exp2(x.Y), Exp2(x.Z), Exp2(x.W)); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Exp2(Double2 x) { return new Double2(Exp2(x.X), Exp2(x.Y)); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Exp2(Double3 x) { return new Double3(Exp2(x.X), Exp2(x.Y), Exp2(x.Z)); }
        /// <summary>Returns the componentwise power of 2 raised to x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Exp2(Double4 x) { return new Double4(Exp2(x.X), Exp2(x.Y), Exp2(x.Z), Exp2(x.W)); }
        // Floor functions
        /// <summary>Returns the floor of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Floor(float x) { return MathF.Floor(x); }
        /// <summary>Returns the floor of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Floor(double x) { return Math.Floor(x); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Floor(Float2 x) { return new Float2(Floor(x.X), Floor(x.Y)); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Floor(Float3 x) { return new Float3(Floor(x.X), Floor(x.Y), Floor(x.Z)); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Floor(Float4 x) { return new Float4(Floor(x.X), Floor(x.Y), Floor(x.Z), Floor(x.W)); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Floor(Double2 x) { return new Double2(Floor(x.X), Floor(x.Y)); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Floor(Double3 x) { return new Double3(Floor(x.X), Floor(x.Y), Floor(x.Z)); }
        /// <summary>Returns the componentwise floor of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Floor(Double4 x) { return new Double4(Floor(x.X), Floor(x.Y), Floor(x.Z), Floor(x.W)); }
        // FloorToInt functions
        /// <summary>Floors a value to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int FloorToInt(float x) { return (int)MathF.Floor(x); }
        /// <summary>Floors a value to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int FloorToInt(double x) { return (int)Math.Floor(x); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 FloorToInt(Float2 x) { return new Int2(FloorToInt(x.X), FloorToInt(x.Y)); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 FloorToInt(Float3 x) { return new Int3(FloorToInt(x.X), FloorToInt(x.Y), FloorToInt(x.Z)); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 FloorToInt(Float4 x) { return new Int4(FloorToInt(x.X), FloorToInt(x.Y), FloorToInt(x.Z), FloorToInt(x.W)); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 FloorToInt(Double2 x) { return new Int2(FloorToInt(x.X), FloorToInt(x.Y)); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 FloorToInt(Double3 x) { return new Int3(FloorToInt(x.X), FloorToInt(x.Y), FloorToInt(x.Z)); }
        /// <summary>Floors each component to the nearest lower integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 FloorToInt(Double4 x) { return new Int4(FloorToInt(x.X), FloorToInt(x.Y), FloorToInt(x.Z), FloorToInt(x.W)); }
        // FMod functions
        /// <summary>Returns the floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float FMod(float x, float y) { return x % y; }
        /// <summary>Returns the floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double FMod(double x, double y) { return x % y; }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 FMod(Float2 x, Float2 y) { return new Float2(FMod(x.X, y.X), FMod(x.Y, y.Y)); }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 FMod(Float3 x, Float3 y) { return new Float3(FMod(x.X, y.X), FMod(x.Y, y.Y), FMod(x.Z, y.Z)); }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 FMod(Float4 x, Float4 y) { return new Float4(FMod(x.X, y.X), FMod(x.Y, y.Y), FMod(x.Z, y.Z), FMod(x.W, y.W)); }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 FMod(Double2 x, Double2 y) { return new Double2(FMod(x.X, y.X), FMod(x.Y, y.Y)); }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 FMod(Double3 x, Double3 y) { return new Double3(FMod(x.X, y.X), FMod(x.Y, y.Y), FMod(x.Z, y.Z)); }
        /// <summary>Returns the componentwise floating-point remainder of x/y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 FMod(Double4 x, Double4 y) { return new Double4(FMod(x.X, y.X), FMod(x.Y, y.Y), FMod(x.Z, y.Z), FMod(x.W, y.W)); }
        // Frac functions
        /// <summary>Returns the fractional part of a number.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Frac(float x) { return x - Floor(x); }
        /// <summary>Returns the fractional part of a number.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Frac(double x) { return x - Floor(x); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Frac(Float2 x) { return new Float2(Frac(x.X), Frac(x.Y)); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Frac(Float3 x) { return new Float3(Frac(x.X), Frac(x.Y), Frac(x.Z)); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Frac(Float4 x) { return new Float4(Frac(x.X), Frac(x.Y), Frac(x.Z), Frac(x.W)); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Frac(Double2 x) { return new Double2(Frac(x.X), Frac(x.Y)); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Frac(Double3 x) { return new Double3(Frac(x.X), Frac(x.Y), Frac(x.Z)); }
        /// <summary>Returns the componentwise fractional part of a vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Frac(Double4 x) { return new Double4(Frac(x.X), Frac(x.Y), Frac(x.Z), Frac(x.W)); }
        // InverseLerp functions
        /// <summary>Finds the t value given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float InverseLerp(float a, float b, float value)
        {
            if (a != b)
                return (value - a) / (b - a);
            else
                return 0f;
        }
        /// <summary>Finds the t value given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double InverseLerp(double a, double b, double value)
        {
            if (a != b)
                return (value - a) / (b - a);
            else
                return 0;
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 InverseLerp(Float2 a, Float2 b, Float2 value)
        {
            return new Float2(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y));
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 InverseLerp(Float3 a, Float3 b, Float3 value)
        {
            return new Float3(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y), InverseLerp(a.Z, b.Z, value.Z));
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 InverseLerp(Float4 a, Float4 b, Float4 value)
        {
            return new Float4(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y), InverseLerp(a.Z, b.Z, value.Z), InverseLerp(a.W, b.W, value.W));
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 InverseLerp(Double2 a, Double2 b, Double2 value)
        {
            return new Double2(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y));
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 InverseLerp(Double3 a, Double3 b, Double3 value)
        {
            return new Double3(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y), InverseLerp(a.Z, b.Z, value.Z));
        }
        /// <summary>Finds the t value for each component given a, b, and the result of a lerp.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 InverseLerp(Double4 a, Double4 b, Double4 value)
        {
            return new Double4(InverseLerp(a.X, b.X, value.X), InverseLerp(a.Y, b.Y, value.Y), InverseLerp(a.Z, b.Z, value.Z), InverseLerp(a.W, b.W, value.W));
        }
        // IsParallel functions
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Float2 a, Float2 b, float tolerance = 1e-6f)
        {
            float normalizedDot = MathF.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1f - tolerance;
        }
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Float3 a, Float3 b, float tolerance = 1e-6f)
        {
            float normalizedDot = MathF.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1f - tolerance;
        }
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Float4 a, Float4 b, float tolerance = 1e-6f)
        {
            float normalizedDot = MathF.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1f - tolerance;
        }
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Double2 a, Double2 b, double tolerance = 1e-15)
        {
            double normalizedDot = Math.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1 - tolerance;
        }
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Double3 a, Double3 b, double tolerance = 1e-15)
        {
            double normalizedDot = Math.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1 - tolerance;
        }
        /// <summary>Checks if two vectors are parallel within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsParallel(Double4 a, Double4 b, double tolerance = 1e-15)
        {
            double normalizedDot = Math.Abs(Dot(Normalize(a), Normalize(b)));
            return normalizedDot >= 1 - tolerance;
        }
        // IsPerpendicular functions
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Float2 a, Float2 b, float tolerance = 1e-6f)
        {
            float dot = MathF.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Float3 a, Float3 b, float tolerance = 1e-6f)
        {
            float dot = MathF.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Float4 a, Float4 b, float tolerance = 1e-6f)
        {
            float dot = MathF.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Double2 a, Double2 b, double tolerance = 1e-15)
        {
            double dot = Math.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Double3 a, Double3 b, double tolerance = 1e-15)
        {
            double dot = Math.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        /// <summary>Checks if two vectors are perpendicular within a tolerance.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsPerpendicular(Double4 a, Double4 b, double tolerance = 1e-15)
        {
            double dot = Math.Abs(Dot(a, b));
            return dot <= tolerance;
        }
        // Length functions
        /// <summary>Returns the length (magnitude) of a Float2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Length(Float2 x) { return x.Length; }
        /// <summary>Returns the length (magnitude) of a Float3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Length(Float3 x) { return x.Length; }
        /// <summary>Returns the length (magnitude) of a Float4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Length(Float4 x) { return x.Length; }
        /// <summary>Returns the length (magnitude) of a Double2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Length(Double2 x) { return x.Length; }
        /// <summary>Returns the length (magnitude) of a Double3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Length(Double3 x) { return x.Length; }
        /// <summary>Returns the length (magnitude) of a Double4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Length(Double4 x) { return x.Length; }
        // LengthSquared functions
        /// <summary>Returns the squared length of a Float2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float LengthSquared(Float2 x) { return x.LengthSquared; }
        /// <summary>Returns the squared length of a Float3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float LengthSquared(Float3 x) { return x.LengthSquared; }
        /// <summary>Returns the squared length of a Float4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float LengthSquared(Float4 x) { return x.LengthSquared; }
        /// <summary>Returns the squared length of a Double2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double LengthSquared(Double2 x) { return x.LengthSquared; }
        /// <summary>Returns the squared length of a Double3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double LengthSquared(Double3 x) { return x.LengthSquared; }
        /// <summary>Returns the squared length of a Double4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double LengthSquared(Double4 x) { return x.LengthSquared; }
        // Lerp functions
        /// <summary>Linearly interpolates between two float values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Lerp(float a, float b, float t) { return a + (b - a) * Saturate(t); }
        /// <summary>Linearly interpolates between two double values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Lerp(double a, double b, double t) { return a + (b - a) * Saturate(t); }
        /// <summary>Linearly interpolates between two Float2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Lerp(Float2 a, Float2 b, float t) { return new Float2(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t))); }
        /// <summary>Linearly interpolates between two Float3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Lerp(Float3 a, Float3 b, float t) { return new Float3(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t)), Lerp(a.Z, b.Z, Saturate(t))); }
        /// <summary>Linearly interpolates between two Float4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Lerp(Float4 a, Float4 b, float t) { return new Float4(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t)), Lerp(a.Z, b.Z, Saturate(t)), Lerp(a.W, b.W, Saturate(t))); }
        /// <summary>Linearly interpolates between two Double2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Lerp(Double2 a, Double2 b, double t) { return new Double2(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t))); }
        /// <summary>Linearly interpolates between two Double3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Lerp(Double3 a, Double3 b, double t) { return new Double3(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t)), Lerp(a.Z, b.Z, Saturate(t))); }
        /// <summary>Linearly interpolates between two Double4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Lerp(Double4 a, Double4 b, double t) { return new Double4(Lerp(a.X, b.X, Saturate(t)), Lerp(a.Y, b.Y, Saturate(t)), Lerp(a.Z, b.Z, Saturate(t)), Lerp(a.W, b.W, Saturate(t))); }
        // LerpAngle functions
        /// <summary>Linearly interpolates between two angles, taking the shortest path around the circle.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float LerpAngle(float a, float b, float t)
        {
            float delta = Repeat(b - a, 2f * MathF.PI);
            if (delta > MathF.PI)
                delta -= 2f * MathF.PI;
            return a + delta * Saturate(t);
        }
        /// <summary>Linearly interpolates between two angles, taking the shortest path around the circle.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double LerpAngle(double a, double b, double t)
        {
            double delta = Repeat(b - a, 2 * Math.PI);
            if (delta > Math.PI)
                delta -= 2 * Math.PI;
            return a + delta * Saturate(t);
        }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 LerpAngle(Float2 a, Float2 b, float t) { return new Float2(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t)); }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 LerpAngle(Float3 a, Float3 b, float t) { return new Float3(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t), LerpAngle(a.Z, b.Z, t)); }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 LerpAngle(Float4 a, Float4 b, float t) { return new Float4(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t), LerpAngle(a.Z, b.Z, t), LerpAngle(a.W, b.W, t)); }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 LerpAngle(Double2 a, Double2 b, double t) { return new Double2(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t)); }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 LerpAngle(Double3 a, Double3 b, double t) { return new Double3(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t), LerpAngle(a.Z, b.Z, t)); }
        /// <summary>Linearly interpolates between two angle vectors, taking the shortest path for each component.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 LerpAngle(Double4 a, Double4 b, double t) { return new Double4(LerpAngle(a.X, b.X, t), LerpAngle(a.Y, b.Y, t), LerpAngle(a.Z, b.Z, t), LerpAngle(a.W, b.W, t)); }
        // LerpUnclamped functions
        /// <summary>Linearly interpolates between two values without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float LerpUnclamped(float a, float b, float t) { return a + (b - a) * t; }
        /// <summary>Linearly interpolates between two values without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double LerpUnclamped(double a, double b, double t) { return a + (b - a) * t; }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 LerpUnclamped(Float2 a, Float2 b, float t) { return new Float2(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t)); }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 LerpUnclamped(Float3 a, Float3 b, float t) { return new Float3(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t), LerpUnclamped(a.Z, b.Z, t)); }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 LerpUnclamped(Float4 a, Float4 b, float t) { return new Float4(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t), LerpUnclamped(a.Z, b.Z, t), LerpUnclamped(a.W, b.W, t)); }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 LerpUnclamped(Double2 a, Double2 b, double t) { return new Double2(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t)); }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 LerpUnclamped(Double3 a, Double3 b, double t) { return new Double3(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t), LerpUnclamped(a.Z, b.Z, t)); }
        /// <summary>Linearly interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 LerpUnclamped(Double4 a, Double4 b, double t) { return new Double4(LerpUnclamped(a.X, b.X, t), LerpUnclamped(a.Y, b.Y, t), LerpUnclamped(a.Z, b.Z, t), LerpUnclamped(a.W, b.W, t)); }
        // Log functions
        /// <summary>Returns the natural logarithm of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Log(float x) { return MathF.Log(x); }
        /// <summary>Returns the natural logarithm of x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Log(double x) { return Math.Log(x); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Log(Float2 x) { return new Float2(Log(x.X), Log(x.Y)); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Log(Float3 x) { return new Float3(Log(x.X), Log(x.Y), Log(x.Z)); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Log(Float4 x) { return new Float4(Log(x.X), Log(x.Y), Log(x.Z), Log(x.W)); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Log(Double2 x) { return new Double2(Log(x.X), Log(x.Y)); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Log(Double3 x) { return new Double3(Log(x.X), Log(x.Y), Log(x.Z)); }
        /// <summary>Returns the componentwise natural logarithm.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Log(Double4 x) { return new Double4(Log(x.X), Log(x.Y), Log(x.Z), Log(x.W)); }
        // Max functions
        /// <summary>Returns the maximum of two float values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Max(float x, float y) { return MathF.Max(x, y); }
        /// <summary>Returns the maximum of two double values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Max(double x, double y) { return Math.Max(x, y); }
        /// <summary>Returns the maximum of two int values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Max(int x, int y) { return Math.Max(x, y); }
        /// <summary>Returns the maximum of two byte values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte Max(byte x, byte y) { return Math.Max(x, y); }
        /// <summary>Returns the maximum of two ushort values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Max(ushort x, ushort y) { return Math.Max(x, y); }
        /// <summary>Returns the maximum of two uint values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Max(uint x, uint y) { return Math.Max(x, y); }
        /// <summary>Returns the maximum of two ulong values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Max(ulong x, ulong y) { return Math.Max(x, y); }
        /// <summary>Returns the componentwise maximum of two Float2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Max(Float2 x, Float2 y) { return new Float2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a Float2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Max(Float2 x, float scalar) { return new Float2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two Float3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Max(Float3 x, Float3 y) { return new Float3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a Float3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Max(Float3 x, float scalar) { return new Float3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two Float4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Max(Float4 x, Float4 y) { return new Float4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a Float4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Max(Float4 x, float scalar) { return new Float4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two Double2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Max(Double2 x, Double2 y) { return new Double2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a Double2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Max(Double2 x, double scalar) { return new Double2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two Double3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Max(Double3 x, Double3 y) { return new Double3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a Double3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Max(Double3 x, double scalar) { return new Double3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two Double4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Max(Double4 x, Double4 y) { return new Double4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a Double4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Max(Double4 x, double scalar) { return new Double4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two Int2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Max(Int2 x, Int2 y) { return new Int2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a Int2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Max(Int2 x, int scalar) { return new Int2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two Int3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Max(Int3 x, Int3 y) { return new Int3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a Int3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Max(Int3 x, int scalar) { return new Int3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two Int4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Max(Int4 x, Int4 y) { return new Int4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a Int4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Max(Int4 x, int scalar) { return new Int4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two Byte2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Max(Byte2 x, Byte2 y) { return new Byte2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a Byte2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Max(Byte2 x, byte scalar) { return new Byte2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two Byte3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Max(Byte3 x, Byte3 y) { return new Byte3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a Byte3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Max(Byte3 x, byte scalar) { return new Byte3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two Byte4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Max(Byte4 x, Byte4 y) { return new Byte4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a Byte4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Max(Byte4 x, byte scalar) { return new Byte4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two UShort2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Max(UShort2 x, UShort2 y) { return new UShort2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a UShort2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Max(UShort2 x, ushort scalar) { return new UShort2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two UShort3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Max(UShort3 x, UShort3 y) { return new UShort3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a UShort3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Max(UShort3 x, ushort scalar) { return new UShort3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two UShort4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Max(UShort4 x, UShort4 y) { return new UShort4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a UShort4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Max(UShort4 x, ushort scalar) { return new UShort4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two UInt2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Max(UInt2 x, UInt2 y) { return new UInt2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a UInt2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Max(UInt2 x, uint scalar) { return new UInt2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two UInt3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Max(UInt3 x, UInt3 y) { return new UInt3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a UInt3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Max(UInt3 x, uint scalar) { return new UInt3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two UInt4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Max(UInt4 x, UInt4 y) { return new UInt4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a UInt4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Max(UInt4 x, uint scalar) { return new UInt4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        /// <summary>Returns the componentwise maximum of two ULong2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Max(ULong2 x, ULong2 y) { return new ULong2(Max(x.X, y.X), Max(x.Y, y.Y)); }

        /// <summary>Returns the componentwise maximum of a ULong2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Max(ULong2 x, ulong scalar) { return new ULong2(Max(x.X, scalar), Max(x.Y, scalar)); }
        /// <summary>Returns the componentwise maximum of two ULong3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Max(ULong3 x, ULong3 y) { return new ULong3(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z)); }

        /// <summary>Returns the componentwise maximum of a ULong3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Max(ULong3 x, ulong scalar) { return new ULong3(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar)); }
        /// <summary>Returns the componentwise maximum of two ULong4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Max(ULong4 x, ULong4 y) { return new ULong4(Max(x.X, y.X), Max(x.Y, y.Y), Max(x.Z, y.Z), Max(x.W, y.W)); }

        /// <summary>Returns the componentwise maximum of a ULong4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Max(ULong4 x, ulong scalar) { return new ULong4(Max(x.X, scalar), Max(x.Y, scalar), Max(x.Z, scalar), Max(x.W, scalar)); }
        // Min functions
        /// <summary>Returns the minimum of two float values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Min(float x, float y) { return MathF.Min(x, y); }
        /// <summary>Returns the minimum of two double values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Min(double x, double y) { return Math.Min(x, y); }
        /// <summary>Returns the minimum of two int values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Min(int x, int y) { return Math.Min(x, y); }
        /// <summary>Returns the minimum of two byte values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static byte Min(byte x, byte y) { return Math.Min(x, y); }
        /// <summary>Returns the minimum of two ushort values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ushort Min(ushort x, ushort y) { return Math.Min(x, y); }
        /// <summary>Returns the minimum of two uint values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static uint Min(uint x, uint y) { return Math.Min(x, y); }
        /// <summary>Returns the minimum of two ulong values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ulong Min(ulong x, ulong y) { return Math.Min(x, y); }
        /// <summary>Returns the componentwise minimum of two Float2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Min(Float2 x, Float2 y) { return new Float2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a Float2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Min(Float2 x, float scalar) { return new Float2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two Float3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Min(Float3 x, Float3 y) { return new Float3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a Float3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Min(Float3 x, float scalar) { return new Float3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two Float4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Min(Float4 x, Float4 y) { return new Float4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a Float4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Min(Float4 x, float scalar) { return new Float4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two Double2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Min(Double2 x, Double2 y) { return new Double2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a Double2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Min(Double2 x, double scalar) { return new Double2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two Double3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Min(Double3 x, Double3 y) { return new Double3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a Double3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Min(Double3 x, double scalar) { return new Double3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two Double4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Min(Double4 x, Double4 y) { return new Double4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a Double4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Min(Double4 x, double scalar) { return new Double4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two Int2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Min(Int2 x, Int2 y) { return new Int2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a Int2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Min(Int2 x, int scalar) { return new Int2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two Int3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Min(Int3 x, Int3 y) { return new Int3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a Int3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Min(Int3 x, int scalar) { return new Int3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two Int4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Min(Int4 x, Int4 y) { return new Int4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a Int4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Min(Int4 x, int scalar) { return new Int4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two Byte2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Min(Byte2 x, Byte2 y) { return new Byte2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a Byte2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte2 Min(Byte2 x, byte scalar) { return new Byte2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two Byte3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Min(Byte3 x, Byte3 y) { return new Byte3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a Byte3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte3 Min(Byte3 x, byte scalar) { return new Byte3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two Byte4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Min(Byte4 x, Byte4 y) { return new Byte4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a Byte4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Byte4 Min(Byte4 x, byte scalar) { return new Byte4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two UShort2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Min(UShort2 x, UShort2 y) { return new UShort2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a UShort2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort2 Min(UShort2 x, ushort scalar) { return new UShort2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two UShort3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Min(UShort3 x, UShort3 y) { return new UShort3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a UShort3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort3 Min(UShort3 x, ushort scalar) { return new UShort3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two UShort4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Min(UShort4 x, UShort4 y) { return new UShort4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a UShort4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UShort4 Min(UShort4 x, ushort scalar) { return new UShort4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two UInt2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Min(UInt2 x, UInt2 y) { return new UInt2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a UInt2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt2 Min(UInt2 x, uint scalar) { return new UInt2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two UInt3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Min(UInt3 x, UInt3 y) { return new UInt3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a UInt3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt3 Min(UInt3 x, uint scalar) { return new UInt3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two UInt4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Min(UInt4 x, UInt4 y) { return new UInt4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a UInt4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static UInt4 Min(UInt4 x, uint scalar) { return new UInt4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        /// <summary>Returns the componentwise minimum of two ULong2 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Min(ULong2 x, ULong2 y) { return new ULong2(Min(x.X, y.X), Min(x.Y, y.Y)); }

        /// <summary>Returns the componentwise minimum of a ULong2 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong2 Min(ULong2 x, ulong scalar) { return new ULong2(Min(x.X, scalar), Min(x.Y, scalar)); }
        /// <summary>Returns the componentwise minimum of two ULong3 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Min(ULong3 x, ULong3 y) { return new ULong3(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z)); }

        /// <summary>Returns the componentwise minimum of a ULong3 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong3 Min(ULong3 x, ulong scalar) { return new ULong3(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar)); }
        /// <summary>Returns the componentwise minimum of two ULong4 vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Min(ULong4 x, ULong4 y) { return new ULong4(Min(x.X, y.X), Min(x.Y, y.Y), Min(x.Z, y.Z), Min(x.W, y.W)); }

        /// <summary>Returns the componentwise minimum of a ULong4 vector and a scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static ULong4 Min(ULong4 x, ulong scalar) { return new ULong4(Min(x.X, scalar), Min(x.Y, scalar), Min(x.Z, scalar), Min(x.W, scalar)); }
        // ModF functions
        /// <summary>Splits a floating-point value into integer and fractional parts.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ModF(float x, out float integerPart)
        {
            integerPart = Floor(x);
            return x - integerPart;
        }
        /// <summary>Splits a floating-point value into integer and fractional parts.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double ModF(double x, out double integerPart)
        {
            integerPart = Floor(x);
            return x - integerPart;
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 ModF(Float2 x, out Float2 integer)
        {
            integer = new Float2();
            return new Float2(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y));
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 ModF(Float3 x, out Float3 integer)
        {
            integer = new Float3();
            return new Float3(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y), ModF(x.Z, out integer.Z));
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 ModF(Float4 x, out Float4 integer)
        {
            integer = new Float4();
            return new Float4(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y), ModF(x.Z, out integer.Z), ModF(x.W, out integer.W));
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 ModF(Double2 x, out Double2 integer)
        {
            integer = new Double2();
            return new Double2(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y));
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 ModF(Double3 x, out Double3 integer)
        {
            integer = new Double3();
            return new Double3(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y), ModF(x.Z, out integer.Z));
        }
        /// <summary>Splits a vector into integer and fractional parts componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 ModF(Double4 x, out Double4 integer)
        {
            integer = new Double4();
            return new Double4(ModF(x.X, out integer.X), ModF(x.Y, out integer.Y), ModF(x.Z, out integer.Z), ModF(x.W, out integer.W));
        }
        // MoveTowards functions
        /// <summary>Moves a value current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MoveTowards(float current, float target, float maxDelta)
        {
            if (Abs(target - current) <= maxDelta)
                return target;
            return current + Sign(target - current) * maxDelta;
        }
        /// <summary>Moves a value current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MoveTowards(double current, double target, double maxDelta)
        {
            if (Abs(target - current) <= maxDelta)
                return target;
            return current + Sign(target - current) * maxDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 MoveTowards(Float2 current, Float2 target, float maxDistanceDelta)
        {
            Float2 toVector = target - current;
            float distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < float.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 MoveTowards(Float3 current, Float3 target, float maxDistanceDelta)
        {
            Float3 toVector = target - current;
            float distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < float.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 MoveTowards(Float4 current, Float4 target, float maxDistanceDelta)
        {
            Float4 toVector = target - current;
            float distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < float.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 MoveTowards(Double2 current, Double2 target, double maxDistanceDelta)
        {
            Double2 toVector = target - current;
            double distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < double.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 MoveTowards(Double3 current, Double3 target, double maxDistanceDelta)
        {
            Double3 toVector = target - current;
            double distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < double.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        /// <summary>Moves a vector current towards target.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 MoveTowards(Double4 current, Double4 target, double maxDistanceDelta)
        {
            Double4 toVector = target - current;
            double distance = Length(toVector);
            if (distance <= maxDistanceDelta || distance < double.Epsilon)
                return target;
            return current + toVector / distance * maxDistanceDelta;
        }
        // MoveTowardsAngle functions
        /// <summary>Moves an angle towards a target angle.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float MoveTowardsAngle(float current, float target, float maxDelta)
        {
            float deltaAngle = DeltaAngle(current, target);
            if (-maxDelta < deltaAngle && deltaAngle < maxDelta)
                return target;
            target = current + deltaAngle;
            return MoveTowards(current, target, maxDelta);
        }
        /// <summary>Moves an angle towards a target angle.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double MoveTowardsAngle(double current, double target, double maxDelta)
        {
            double deltaAngle = DeltaAngle(current, target);
            if (-maxDelta < deltaAngle && deltaAngle < maxDelta)
                return target;
            target = current + deltaAngle;
            return MoveTowards(current, target, maxDelta);
        }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 MoveTowardsAngle(Float2 current, Float2 target, float maxDelta) { return new Float2(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta)); }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 MoveTowardsAngle(Float3 current, Float3 target, float maxDelta) { return new Float3(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta), MoveTowardsAngle(current.Z, target.Z, maxDelta)); }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 MoveTowardsAngle(Float4 current, Float4 target, float maxDelta) { return new Float4(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta), MoveTowardsAngle(current.Z, target.Z, maxDelta), MoveTowardsAngle(current.W, target.W, maxDelta)); }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 MoveTowardsAngle(Double2 current, Double2 target, double maxDelta) { return new Double2(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta)); }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 MoveTowardsAngle(Double3 current, Double3 target, double maxDelta) { return new Double3(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta), MoveTowardsAngle(current.Z, target.Z, maxDelta)); }
        /// <summary>Moves an angle vector towards a target angle vector componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 MoveTowardsAngle(Double4 current, Double4 target, double maxDelta) { return new Double4(MoveTowardsAngle(current.X, target.X, maxDelta), MoveTowardsAngle(current.Y, target.Y, maxDelta), MoveTowardsAngle(current.Z, target.Z, maxDelta), MoveTowardsAngle(current.W, target.W, maxDelta)); }
        // Normalize functions
        /// <summary>Returns the normalized version of a Float2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Normalize(Float2 x) { return x.Normalized; }
        /// <summary>Returns the normalized version of a Float3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Normalize(Float3 x) { return x.Normalized; }
        /// <summary>Returns the normalized version of a Float4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Normalize(Float4 x) { return x.Normalized; }
        /// <summary>Returns the normalized version of a Double2 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Normalize(Double2 x) { return x.Normalized; }
        /// <summary>Returns the normalized version of a Double3 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Normalize(Double3 x) { return x.Normalized; }
        /// <summary>Returns the normalized version of a Double4 vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Normalize(Double4 x) { return x.Normalized; }
        // OrthoNormalize functions
        /// <summary>Orthonormalizes a set of three vectors using Gram-Schmidt process.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrthoNormalize(ref Float3 normal, ref Float3 tangent, ref Float3 binormal)
        {
            normal = Normalize(normal);
            tangent = Normalize(tangent - Project(tangent, normal));
            binormal = Cross(normal, tangent);
        }

        /// <summary>Orthonormalizes two vectors using Gram-Schmidt process.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrthoNormalize(ref Float3 normal, ref Float3 tangent)
        {
            normal = Normalize(normal);
            tangent = Normalize(tangent - Project(tangent, normal));
        }
        /// <summary>Orthonormalizes a set of three vectors using Gram-Schmidt process.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrthoNormalize(ref Double3 normal, ref Double3 tangent, ref Double3 binormal)
        {
            normal = Normalize(normal);
            tangent = Normalize(tangent - Project(tangent, normal));
            binormal = Cross(normal, tangent);
        }

        /// <summary>Orthonormalizes two vectors using Gram-Schmidt process.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static void OrthoNormalize(ref Double3 normal, ref Double3 tangent)
        {
            normal = Normalize(normal);
            tangent = Normalize(tangent - Project(tangent, normal));
        }
        // PingPong functions
        /// <summary>PingPongs the value t, so that it is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float PingPong(float t, float length)
        {
            t = Repeat(t, length * 2f);
            return length - Abs(t - length);
        }
        /// <summary>PingPongs the value t, so that it is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double PingPong(double t, double length)
        {
            t = Repeat(t, length * 2);
            return length - Abs(t - length);
        }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 PingPong(Float2 t, Float2 length) { return new Float2(PingPong(t.X, length.X), PingPong(t.Y, length.Y)); }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 PingPong(Float3 t, Float3 length) { return new Float3(PingPong(t.X, length.X), PingPong(t.Y, length.Y), PingPong(t.Z, length.Z)); }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 PingPong(Float4 t, Float4 length) { return new Float4(PingPong(t.X, length.X), PingPong(t.Y, length.Y), PingPong(t.Z, length.Z), PingPong(t.W, length.W)); }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 PingPong(Double2 t, Double2 length) { return new Double2(PingPong(t.X, length.X), PingPong(t.Y, length.Y)); }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 PingPong(Double3 t, Double3 length) { return new Double3(PingPong(t.X, length.X), PingPong(t.Y, length.Y), PingPong(t.Z, length.Z)); }
        /// <summary>PingPongs the vector t, so that each component is never larger than length and never smaller than 0.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 PingPong(Double4 t, Double4 length) { return new Double4(PingPong(t.X, length.X), PingPong(t.Y, length.Y), PingPong(t.Z, length.Z), PingPong(t.W, length.W)); }
        // Pow functions
        /// <summary>Returns x raised to the power of y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Pow(float x, float y) { return MathF.Pow(x, y); }
        /// <summary>Returns x raised to the power of y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Pow(double x, double y) { return Math.Pow(x, y); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Pow(Float2 x, Float2 y) { return new Float2(Pow(x.X, y.X), Pow(x.Y, y.Y)); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Pow(Float3 x, Float3 y) { return new Float3(Pow(x.X, y.X), Pow(x.Y, y.Y), Pow(x.Z, y.Z)); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Pow(Float4 x, Float4 y) { return new Float4(Pow(x.X, y.X), Pow(x.Y, y.Y), Pow(x.Z, y.Z), Pow(x.W, y.W)); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Pow(Double2 x, Double2 y) { return new Double2(Pow(x.X, y.X), Pow(x.Y, y.Y)); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Pow(Double3 x, Double3 y) { return new Double3(Pow(x.X, y.X), Pow(x.Y, y.Y), Pow(x.Z, y.Z)); }
        /// <summary>Returns the componentwise power of x raised to y.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Pow(Double4 x, Double4 y) { return new Double4(Pow(x.X, y.X), Pow(x.Y, y.Y), Pow(x.Z, y.Z), Pow(x.W, y.W)); }
        // Project functions
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Project(Float2 a, Float2 b)
        {
            float denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Float2.Zero;
            return b * (Dot(a, b) / denominator);
        }
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Project(Float3 a, Float3 b)
        {
            float denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Float3.Zero;
            return b * (Dot(a, b) / denominator);
        }
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Project(Float4 a, Float4 b)
        {
            float denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Float4.Zero;
            return b * (Dot(a, b) / denominator);
        }
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Project(Double2 a, Double2 b)
        {
            double denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Double2.Zero;
            return b * (Dot(a, b) / denominator);
        }
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Project(Double3 a, Double3 b)
        {
            double denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Double3.Zero;
            return b * (Dot(a, b) / denominator);
        }
        /// <summary>Projects vector a onto vector b.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Project(Double4 a, Double4 b)
        {
            double denominator = Dot(b, b);
            if (denominator <= Epsilon)
                return Double4.Zero;
            return b * (Dot(a, b) / denominator);
        }
        // ProjectOntoPlane functions
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 ProjectOntoPlane(Float2 vector, Float2 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 ProjectOntoPlane(Float3 vector, Float3 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 ProjectOntoPlane(Float4 vector, Float4 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 ProjectOntoPlane(Double2 vector, Double2 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 ProjectOntoPlane(Double3 vector, Double3 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        /// <summary>Projects a vector onto a plane defined by a normal vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 ProjectOntoPlane(Double4 vector, Double4 planeNormal)
        {
            return vector - Project(vector, planeNormal);
        }
        // Reflect functions
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Reflect(Float2 vector, Float2 normal)
        {
            float dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Reflect(Float3 vector, Float3 normal)
        {
            float dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Reflect(Float4 vector, Float4 normal)
        {
            float dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Reflect(Double2 vector, Double2 normal)
        {
            double dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Reflect(Double3 vector, Double3 normal)
        {
            double dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        /// <summary>Reflects a vector off a normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Reflect(Double4 vector, Double4 normal)
        {
            double dot = Dot(vector, normal);
            return vector - 2 * dot * normal;
        }
        // Refract functions
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Refract(Float2 incident, Float2 normal, float eta)
        {
            float dotNI = Dot(normal, incident);
            float k = 1f - eta * eta * (1f - dotNI * dotNI);
            return k < 0f ? new Float2(0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Refract(Float3 incident, Float3 normal, float eta)
        {
            float dotNI = Dot(normal, incident);
            float k = 1f - eta * eta * (1f - dotNI * dotNI);
            return k < 0f ? new Float3(0, 0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Refract(Float4 incident, Float4 normal, float eta)
        {
            float dotNI = Dot(normal, incident);
            float k = 1f - eta * eta * (1f - dotNI * dotNI);
            return k < 0f ? new Float4(0, 0, 0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Refract(Double2 incident, Double2 normal, double eta)
        {
            double dotNI = Dot(normal, incident);
            double k = 1 - eta * eta * (1 - dotNI * dotNI);
            return k < 0 ? new Double2(0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Refract(Double3 incident, Double3 normal, double eta)
        {
            double dotNI = Dot(normal, incident);
            double k = 1 - eta * eta * (1 - dotNI * dotNI);
            return k < 0 ? new Double3(0, 0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        /// <summary>Calculates the refraction direction for an incident vector and surface normal.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Refract(Double4 incident, Double4 normal, double eta)
        {
            double dotNI = Dot(normal, incident);
            double k = 1 - eta * eta * (1 - dotNI * dotNI);
            return k < 0 ? new Double4(0, 0, 0, 0) : eta * incident - (eta * dotNI + Sqrt(k)) * normal;
        }
        // Remap functions
        /// <summary>Remaps a value from one range to another.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Remap(float value, float inputMin, float inputMax, float outputMin, float outputMax)
        {
            return outputMin + ((value - inputMin) * (outputMax - outputMin) / (inputMax - inputMin));
        }
        /// <summary>Remaps a value from one range to another.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Remap(double value, double inputMin, double inputMax, double outputMin, double outputMax)
        {
            return outputMin + ((value - inputMin) * (outputMax - outputMin) / (inputMax - inputMin));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Remap(Float2 value, Float2 inputMin, Float2 inputMax, Float2 outputMin, Float2 outputMax)
        {
            return new Float2(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Remap(Float3 value, Float3 inputMin, Float3 inputMax, Float3 outputMin, Float3 outputMax)
        {
            return new Float3(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y), Remap(value.Z, inputMin.Z, inputMax.Z, outputMin.Z, outputMax.Z));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Remap(Float4 value, Float4 inputMin, Float4 inputMax, Float4 outputMin, Float4 outputMax)
        {
            return new Float4(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y), Remap(value.Z, inputMin.Z, inputMax.Z, outputMin.Z, outputMax.Z), Remap(value.W, inputMin.W, inputMax.W, outputMin.W, outputMax.W));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Remap(Double2 value, Double2 inputMin, Double2 inputMax, Double2 outputMin, Double2 outputMax)
        {
            return new Double2(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Remap(Double3 value, Double3 inputMin, Double3 inputMax, Double3 outputMin, Double3 outputMax)
        {
            return new Double3(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y), Remap(value.Z, inputMin.Z, inputMax.Z, outputMin.Z, outputMax.Z));
        }
        /// <summary>Remaps a vector from one range to another componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Remap(Double4 value, Double4 inputMin, Double4 inputMax, Double4 outputMin, Double4 outputMax)
        {
            return new Double4(Remap(value.X, inputMin.X, inputMax.X, outputMin.X, outputMax.X), Remap(value.Y, inputMin.Y, inputMax.Y, outputMin.Y, outputMax.Y), Remap(value.Z, inputMin.Z, inputMax.Z, outputMin.Z, outputMax.Z), Remap(value.W, inputMin.W, inputMax.W, outputMin.W, outputMax.W));
        }
        // Repeat functions
        /// <summary>Wraps the given value between 0 and length.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Repeat(float t, float length)
        {
            return Clamp(t - MathF.Floor(t / length) * length, 0f, length);
        }
        /// <summary>Wraps the given value between 0 and length.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Repeat(double t, double length)
        {
            return Clamp(t - Math.Floor(t / length) * length, 0, length);
        }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Repeat(Float2 t, Float2 length) { return new Float2(Repeat(t.X, length.X), Repeat(t.Y, length.Y)); }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Repeat(Float3 t, Float3 length) { return new Float3(Repeat(t.X, length.X), Repeat(t.Y, length.Y), Repeat(t.Z, length.Z)); }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Repeat(Float4 t, Float4 length) { return new Float4(Repeat(t.X, length.X), Repeat(t.Y, length.Y), Repeat(t.Z, length.Z), Repeat(t.W, length.W)); }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Repeat(Double2 t, Double2 length) { return new Double2(Repeat(t.X, length.X), Repeat(t.Y, length.Y)); }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Repeat(Double3 t, Double3 length) { return new Double3(Repeat(t.X, length.X), Repeat(t.Y, length.Y), Repeat(t.Z, length.Z)); }
        /// <summary>Wraps the given vector between 0 and length componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Repeat(Double4 t, Double4 length) { return new Double4(Repeat(t.X, length.X), Repeat(t.Y, length.Y), Repeat(t.Z, length.Z), Repeat(t.W, length.W)); }
        // Round functions
        /// <summary>Returns the round of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Round(float x) { return MathF.Round(x); }
        /// <summary>Returns the round of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Round(double x) { return Math.Round(x); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Round(Float2 x) { return new Float2(Round(x.X), Round(x.Y)); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Round(Float3 x) { return new Float3(Round(x.X), Round(x.Y), Round(x.Z)); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Round(Float4 x) { return new Float4(Round(x.X), Round(x.Y), Round(x.Z), Round(x.W)); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Round(Double2 x) { return new Double2(Round(x.X), Round(x.Y)); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Round(Double3 x) { return new Double3(Round(x.X), Round(x.Y), Round(x.Z)); }
        /// <summary>Returns the componentwise round of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Round(Double4 x) { return new Double4(Round(x.X), Round(x.Y), Round(x.Z), Round(x.W)); }
        // RoundToInt functions
        /// <summary>Rounds a value to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int RoundToInt(float x) { return (int)MathF.Round(x); }
        /// <summary>Rounds a value to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int RoundToInt(double x) { return (int)Math.Round(x); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 RoundToInt(Float2 x) { return new Int2(RoundToInt(x.X), RoundToInt(x.Y)); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 RoundToInt(Float3 x) { return new Int3(RoundToInt(x.X), RoundToInt(x.Y), RoundToInt(x.Z)); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 RoundToInt(Float4 x) { return new Int4(RoundToInt(x.X), RoundToInt(x.Y), RoundToInt(x.Z), RoundToInt(x.W)); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 RoundToInt(Double2 x) { return new Int2(RoundToInt(x.X), RoundToInt(x.Y)); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 RoundToInt(Double3 x) { return new Int3(RoundToInt(x.X), RoundToInt(x.Y), RoundToInt(x.Z)); }
        /// <summary>Rounds each component to the nearest integer.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 RoundToInt(Double4 x) { return new Int4(RoundToInt(x.X), RoundToInt(x.Y), RoundToInt(x.Z), RoundToInt(x.W)); }
        // Saturate functions
        /// <summary>Clamps a value between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Saturate(float x) { return Clamp(x, 0f, 1f); }
        /// <summary>Clamps a value between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Saturate(double x) { return Clamp(x, 0.0, 1.0); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Saturate(Float2 x) { return new Float2(Saturate(x.X), Saturate(x.Y)); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Saturate(Float3 x) { return new Float3(Saturate(x.X), Saturate(x.Y), Saturate(x.Z)); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Saturate(Float4 x) { return new Float4(Saturate(x.X), Saturate(x.Y), Saturate(x.Z), Saturate(x.W)); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Saturate(Double2 x) { return new Double2(Saturate(x.X), Saturate(x.Y)); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Saturate(Double3 x) { return new Double3(Saturate(x.X), Saturate(x.Y), Saturate(x.Z)); }
        /// <summary>Clamps each component of a vector between 0 and 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Saturate(Double4 x) { return new Double4(Saturate(x.X), Saturate(x.Y), Saturate(x.Z), Saturate(x.W)); }
        // Sign functions
        /// <summary>Returns the sign of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Sign(float x) { return MathF.Sign(x); }
        /// <summary>Returns the sign of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Sign(double x) { return Math.Sign(x); }
        /// <summary>Returns the sign of int x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static int Sign(int x) { return Math.Sign(x); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Sign(Float2 x) { return new Float2(Sign(x.X), Sign(x.Y)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Sign(Float3 x) { return new Float3(Sign(x.X), Sign(x.Y), Sign(x.Z)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Sign(Float4 x) { return new Float4(Sign(x.X), Sign(x.Y), Sign(x.Z), Sign(x.W)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Sign(Double2 x) { return new Double2(Sign(x.X), Sign(x.Y)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Sign(Double3 x) { return new Double3(Sign(x.X), Sign(x.Y), Sign(x.Z)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Sign(Double4 x) { return new Double4(Sign(x.X), Sign(x.Y), Sign(x.Z), Sign(x.W)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int2 Sign(Int2 x) { return new Int2(Sign(x.X), Sign(x.Y)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int3 Sign(Int3 x) { return new Int3(Sign(x.X), Sign(x.Y), Sign(x.Z)); }
        /// <summary>Returns the componentwise sign of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Int4 Sign(Int4 x) { return new Int4(Sign(x.X), Sign(x.Y), Sign(x.Z), Sign(x.W)); }
        // SignedAngleBetween functions
        /// <summary>Returns the signed angle in radians between two 2D vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float SignedAngleBetween(Float2 a, Float2 b)
        {
            return MathF.Atan2(a.X * b.Y - a.Y * b.X, a.X * b.X + a.Y * b.Y);
        }
        /// <summary>Returns the signed angle in radians between two 3D vectors around a reference axis.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float SignedAngleBetween(Float3 a, Float3 b, Float3 axis)
        {
            float angle = AngleBetween(a, b);
            Float3 cross = Cross(a, b);
            float sign = Dot(cross, axis) < 0f ? -1f : 1f;
            return angle * sign;
        }
        /// <summary>Returns the signed angle in radians between two 2D vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double SignedAngleBetween(Double2 a, Double2 b)
        {
            return Math.Atan2(a.X * b.Y - a.Y * b.X, a.X * b.X + a.Y * b.Y);
        }
        /// <summary>Returns the signed angle in radians between two 3D vectors around a reference axis.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double SignedAngleBetween(Double3 a, Double3 b, Double3 axis)
        {
            double angle = AngleBetween(a, b);
            Double3 cross = Cross(a, b);
            double sign = Dot(cross, axis) < 0 ? -1 : 1;
            return angle * sign;
        }
        // Sin functions
        /// <summary>Returns the sin of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Sin(float x) { return MathF.Sin(x); }
        /// <summary>Returns the sin of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Sin(double x) { return Math.Sin(x); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Sin(Float2 x) { return new Float2(Sin(x.X), Sin(x.Y)); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Sin(Float3 x) { return new Float3(Sin(x.X), Sin(x.Y), Sin(x.Z)); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Sin(Float4 x) { return new Float4(Sin(x.X), Sin(x.Y), Sin(x.Z), Sin(x.W)); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Sin(Double2 x) { return new Double2(Sin(x.X), Sin(x.Y)); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Sin(Double3 x) { return new Double3(Sin(x.X), Sin(x.Y), Sin(x.Z)); }
        /// <summary>Returns the componentwise sin of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Sin(Double4 x) { return new Double4(Sin(x.X), Sin(x.Y), Sin(x.Z), Sin(x.W)); }
        // Slerp functions
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Slerp(Float2 a, Float2 b, float t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Slerp(Float3 a, Float3 b, float t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Slerp(Float4 a, Float4 b, float t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Slerp(Double2 a, Double2 b, double t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Slerp(Double3 a, Double3 b, double t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        /// <summary>Spherically interpolates between two vectors.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Slerp(Double4 a, Double4 b, double t)
        {
            t = Saturate(t);
            return SlerpUnclamped(a, b, t);
        }
        // SlerpUnclamped functions
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 SlerpUnclamped(Float2 a, Float2 b, float t)
        {
            Float2 result;

            // Normalize the vectors
            Float2 normalizedA = Normalize(a);
            Float2 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            float dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0f)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1f - 1e-6f)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            float angle = MathF.Acos(Abs(dot));
            float sinAngle = MathF.Sin(angle);
            
            // Calculate the scale factors
            float scale1 = MathF.Sin((1f - t) * angle) / sinAngle;
            float scale2 = MathF.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 SlerpUnclamped(Float3 a, Float3 b, float t)
        {
            Float3 result;

            // Normalize the vectors
            Float3 normalizedA = Normalize(a);
            Float3 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            float dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0f)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1f - 1e-6f)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            float angle = MathF.Acos(Abs(dot));
            float sinAngle = MathF.Sin(angle);
            
            // Calculate the scale factors
            float scale1 = MathF.Sin((1f - t) * angle) / sinAngle;
            float scale2 = MathF.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 SlerpUnclamped(Float4 a, Float4 b, float t)
        {
            Float4 result;

            // Normalize the vectors
            Float4 normalizedA = Normalize(a);
            Float4 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            float dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0f)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1f - 1e-6f)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            float angle = MathF.Acos(Abs(dot));
            float sinAngle = MathF.Sin(angle);
            
            // Calculate the scale factors
            float scale1 = MathF.Sin((1f - t) * angle) / sinAngle;
            float scale2 = MathF.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 SlerpUnclamped(Double2 a, Double2 b, double t)
        {
            Double2 result;

            // Normalize the vectors
            Double2 normalizedA = Normalize(a);
            Double2 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            double dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1 - 1e-15)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            double angle = Math.Acos(Abs(dot));
            double sinAngle = Math.Sin(angle);
            
            // Calculate the scale factors
            double scale1 = Math.Sin((1 - t) * angle) / sinAngle;
            double scale2 = Math.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 SlerpUnclamped(Double3 a, Double3 b, double t)
        {
            Double3 result;

            // Normalize the vectors
            Double3 normalizedA = Normalize(a);
            Double3 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            double dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1 - 1e-15)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            double angle = Math.Acos(Abs(dot));
            double sinAngle = Math.Sin(angle);
            
            // Calculate the scale factors
            double scale1 = Math.Sin((1 - t) * angle) / sinAngle;
            double scale2 = Math.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        /// <summary>Spherically interpolates between two vectors without clamping t.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 SlerpUnclamped(Double4 a, Double4 b, double t)
        {
            Double4 result;

            // Normalize the vectors
            Double4 normalizedA = Normalize(a);
            Double4 normalizedB = Normalize(b);
            
            // Calculate the cosine of the angle between them
            double dot = Dot(normalizedA, normalizedB);
            
            // If the dot product is negative, slerp won't take the shorter path.
            // So negate one vector to get the shorter path.
            if (dot < 0)
            {
                normalizedB = -normalizedB;
                dot = -dot;
            }
            
            // If the vectors are close to identical, just use linear interpolation
            if (dot > 1 - 1e-15)
            {
                result = normalizedA + t * (normalizedB - normalizedA);
                return Normalize(result) * Lerp(Length(a), Length(b), t);
            }
            
            // Calculate angle and sin
            double angle = Math.Acos(Abs(dot));
            double sinAngle = Math.Sin(angle);
            
            // Calculate the scale factors
            double scale1 = Math.Sin((1 - t) * angle) / sinAngle;
            double scale2 = Math.Sin(t * angle) / sinAngle;
            
            // Interpolate
            result = scale1 * normalizedA + scale2 * normalizedB;
            return result * Lerp(Length(a), Length(b), t);
        }
        // SmoothLerp functions
        /// <summary>Smoothly interpolates between two values using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float SmoothLerp(float a, float b, float t) 
        {
            return Lerp(a, b, Smoothstep(0f, 1f, t));
        }
        /// <summary>Smoothly interpolates between two values using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double SmoothLerp(double a, double b, double t) 
        {
            return Lerp(a, b, Smoothstep(0, 1, t));
        }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 SmoothLerp(Float2 a, Float2 b, float t) { return new Float2(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t)); }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 SmoothLerp(Float3 a, Float3 b, float t) { return new Float3(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t), SmoothLerp(a.Z, b.Z, t)); }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 SmoothLerp(Float4 a, Float4 b, float t) { return new Float4(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t), SmoothLerp(a.Z, b.Z, t), SmoothLerp(a.W, b.W, t)); }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 SmoothLerp(Double2 a, Double2 b, double t) { return new Double2(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t)); }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 SmoothLerp(Double3 a, Double3 b, double t) { return new Double3(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t), SmoothLerp(a.Z, b.Z, t)); }
        /// <summary>Smoothly interpolates between two vectors using cubic Hermite interpolation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 SmoothLerp(Double4 a, Double4 b, double t) { return new Double4(SmoothLerp(a.X, b.X, t), SmoothLerp(a.Y, b.Y, t), SmoothLerp(a.Z, b.Z, t), SmoothLerp(a.W, b.W, t)); }
        // Smoothstep functions
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Smoothstep(float edge0, float edge1, float x)
        {
            float t = Saturate((x - edge0) / (edge1 - edge0));
            return t * t * (3f - 2f * t);
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Smoothstep(double edge0, double edge1, double x)
        {
            double t = Saturate((x - edge0) / (edge1 - edge0));
            return t * t * (3 - 2 * t);
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Smoothstep(Float2 edge0, Float2 edge1, Float2 x)
        {
            return new Float2(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y));
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Smoothstep(Float3 edge0, Float3 edge1, Float3 x)
        {
            return new Float3(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y), Smoothstep(edge0.Z, edge1.Z, x.Z));
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Smoothstep(Float4 edge0, Float4 edge1, Float4 x)
        {
            return new Float4(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y), Smoothstep(edge0.Z, edge1.Z, x.Z), Smoothstep(edge0.W, edge1.W, x.W));
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Smoothstep(Double2 edge0, Double2 edge1, Double2 x)
        {
            return new Double2(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y));
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Smoothstep(Double3 edge0, Double3 edge1, Double3 x)
        {
            return new Double3(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y), Smoothstep(edge0.Z, edge1.Z, x.Z));
        }
        /// <summary>Performs a smooth Hermite interpolation between 0 and 1 componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Smoothstep(Double4 edge0, Double4 edge1, Double4 x)
        {
            return new Double4(Smoothstep(edge0.X, edge1.X, x.X), Smoothstep(edge0.Y, edge1.Y, x.Y), Smoothstep(edge0.Z, edge1.Z, x.Z), Smoothstep(edge0.W, edge1.W, x.W));
        }
        // Sqrt functions
        /// <summary>Returns the sqrt of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Sqrt(float x) { return MathF.Sqrt(x); }
        /// <summary>Returns the sqrt of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Sqrt(double x) { return Math.Sqrt(x); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Sqrt(Float2 x) { return new Float2(Sqrt(x.X), Sqrt(x.Y)); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Sqrt(Float3 x) { return new Float3(Sqrt(x.X), Sqrt(x.Y), Sqrt(x.Z)); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Sqrt(Float4 x) { return new Float4(Sqrt(x.X), Sqrt(x.Y), Sqrt(x.Z), Sqrt(x.W)); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Sqrt(Double2 x) { return new Double2(Sqrt(x.X), Sqrt(x.Y)); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Sqrt(Double3 x) { return new Double3(Sqrt(x.X), Sqrt(x.Y), Sqrt(x.Z)); }
        /// <summary>Returns the componentwise sqrt of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Sqrt(Double4 x) { return new Double4(Sqrt(x.X), Sqrt(x.Y), Sqrt(x.Z), Sqrt(x.W)); }
        // Step functions
        /// <summary>Returns 0 if x < edge, otherwise returns 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Step(float edge, float x) { return x < edge ? 0f : 1f; }
        /// <summary>Returns 0 if x < edge, otherwise returns 1.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Step(double edge, double x) { return x < edge ? 0.0 : 1.0; }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Step(Float2 edge, Float2 x) { return new Float2(Step(edge.X, x.X), Step(edge.Y, x.Y)); }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Step(Float3 edge, Float3 x) { return new Float3(Step(edge.X, x.X), Step(edge.Y, x.Y), Step(edge.Z, x.Z)); }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Step(Float4 edge, Float4 x) { return new Float4(Step(edge.X, x.X), Step(edge.Y, x.Y), Step(edge.Z, x.Z), Step(edge.W, x.W)); }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Step(Double2 edge, Double2 x) { return new Double2(Step(edge.X, x.X), Step(edge.Y, x.Y)); }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Step(Double3 edge, Double3 x) { return new Double3(Step(edge.X, x.X), Step(edge.Y, x.Y), Step(edge.Z, x.Z)); }
        /// <summary>Returns 0 or 1 for each component based on the step function.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Step(Double4 edge, Double4 x) { return new Double4(Step(edge.X, x.X), Step(edge.Y, x.Y), Step(edge.Z, x.Z), Step(edge.W, x.W)); }
        // Tan functions
        /// <summary>Returns the tan of float x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float Tan(float x) { return MathF.Tan(x); }
        /// <summary>Returns the tan of double x.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double Tan(double x) { return Math.Tan(x); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 Tan(Float2 x) { return new Float2(Tan(x.X), Tan(x.Y)); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 Tan(Float3 x) { return new Float3(Tan(x.X), Tan(x.Y), Tan(x.Z)); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 Tan(Float4 x) { return new Float4(Tan(x.X), Tan(x.Y), Tan(x.Z), Tan(x.W)); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 Tan(Double2 x) { return new Double2(Tan(x.X), Tan(x.Y)); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 Tan(Double3 x) { return new Double3(Tan(x.X), Tan(x.Y), Tan(x.Z)); }
        /// <summary>Returns the componentwise tan of the vector.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 Tan(Double4 x) { return new Double4(Tan(x.X), Tan(x.Y), Tan(x.Z), Tan(x.W)); }
        // ToDegrees functions
        /// <summary>Converts radians to degrees.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ToDegrees(float radians) { return radians * 180f / MathF.PI; }
        /// <summary>Converts radians to degrees.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double ToDegrees(double radians) { return radians * 180 / Math.PI; }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 ToDegrees(Float2 radians) { return new Float2(ToDegrees(radians.X), ToDegrees(radians.Y)); }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 ToDegrees(Float3 radians) { return new Float3(ToDegrees(radians.X), ToDegrees(radians.Y), ToDegrees(radians.Z)); }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 ToDegrees(Float4 radians) { return new Float4(ToDegrees(radians.X), ToDegrees(radians.Y), ToDegrees(radians.Z), ToDegrees(radians.W)); }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 ToDegrees(Double2 radians) { return new Double2(ToDegrees(radians.X), ToDegrees(radians.Y)); }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 ToDegrees(Double3 radians) { return new Double3(ToDegrees(radians.X), ToDegrees(radians.Y), ToDegrees(radians.Z)); }
        /// <summary>Converts radians to degrees componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 ToDegrees(Double4 radians) { return new Double4(ToDegrees(radians.X), ToDegrees(radians.Y), ToDegrees(radians.Z), ToDegrees(radians.W)); }
        // ToRadians functions
        /// <summary>Converts degrees to radians.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static float ToRadians(float degrees) { return degrees * MathF.PI / 180f; }
        /// <summary>Converts degrees to radians.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static double ToRadians(double degrees) { return degrees * Math.PI / 180; }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2 ToRadians(Float2 degrees) { return new Float2(ToRadians(degrees.X), ToRadians(degrees.Y)); }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3 ToRadians(Float3 degrees) { return new Float3(ToRadians(degrees.X), ToRadians(degrees.Y), ToRadians(degrees.Z)); }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4 ToRadians(Float4 degrees) { return new Float4(ToRadians(degrees.X), ToRadians(degrees.Y), ToRadians(degrees.Z), ToRadians(degrees.W)); }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 ToRadians(Double2 degrees) { return new Double2(ToRadians(degrees.X), ToRadians(degrees.Y)); }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3 ToRadians(Double3 degrees) { return new Double3(ToRadians(degrees.X), ToRadians(degrees.Y), ToRadians(degrees.Z)); }
        /// <summary>Converts degrees to radians componentwise.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4 ToRadians(Double4 degrees) { return new Double4(ToRadians(degrees.X), ToRadians(degrees.Y), ToRadians(degrees.Z), ToRadians(degrees.W)); }
        // transpose functions

        /// <summary>Returns the transpose of a float2x2 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float2x2 Transpose(Float2x2 m)
        {
            return new Float2x2(new Float2(m.c0.X, m.c1.X),
            new Float2(m.c0.Y, m.c1.Y));
        }

        /// <summary>Returns the transpose of a float3x3 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float3x3 Transpose(Float3x3 m)
        {
            return new Float3x3(new Float3(m.c0.X, m.c1.X, m.c2.X),
            new Float3(m.c0.Y, m.c1.Y, m.c2.Y),
            new Float3(m.c0.Z, m.c1.Z, m.c2.Z));
        }

        /// <summary>Returns the transpose of a float4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Float4x4 Transpose(Float4x4 m)
        {
            return new Float4x4(new Float4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
            new Float4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y),
            new Float4(m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z),
            new Float4(m.c0.W, m.c1.W, m.c2.W, m.c3.W));
        }

        /// <summary>Returns the transpose of a double2x2 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2x2 Transpose(Double2x2 m)
        {
            return new Double2x2(new Double2(m.c0.X, m.c1.X),
            new Double2(m.c0.Y, m.c1.Y));
        }

        /// <summary>Returns the transpose of a double3x3 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double3x3 Transpose(Double3x3 m)
        {
            return new Double3x3(new Double3(m.c0.X, m.c1.X, m.c2.X),
            new Double3(m.c0.Y, m.c1.Y, m.c2.Y),
            new Double3(m.c0.Z, m.c1.Z, m.c2.Z));
        }

        /// <summary>Returns the transpose of a double4x4 matrix.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double4x4 Transpose(Double4x4 m)
        {
            return new Double4x4(new Double4(m.c0.X, m.c1.X, m.c2.X, m.c3.X),
            new Double4(m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y),
            new Double4(m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z),
            new Double4(m.c0.W, m.c1.W, m.c2.W, m.c3.W));
        }
    }
}
