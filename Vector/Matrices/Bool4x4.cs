//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-06-13 16:56:02
//

using System; 
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;
using Prowl.Vector;

namespace Prowl.Vector
{

/// <summary>A 4x4 matrix of bools.</summary>
[System.Serializable]
public partial struct Bool4x4 : System.IEquatable<Bool4x4>, IFormattable
{
	/// <summary>Column 0 of the matrix.</summary>
	public Bool4 c0;
	/// <summary>Column 1 of the matrix.</summary>
	public Bool4 c1;
	/// <summary>Column 2 of the matrix.</summary>
	public Bool4 c2;
	/// <summary>Column 3 of the matrix.</summary>
	public Bool4 c3;

	/// <summary>Bool4x4 identity transform.</summary>
	public static readonly Bool4x4 Identity = new Bool4x4(new Bool4(true, false, false, false), new Bool4(false, true, false, false), new Bool4(false, false, true, false), new Bool4(false, false, false, true));

	/// <summary>Bool4x4 zero value.</summary>
	public static readonly Bool4x4 Zero = new Bool4x4(new Bool4(false), new Bool4(false), new Bool4(false), new Bool4(false));

	/// <summary>Constructs a Bool4x4 matrix from 4 Bool4 vectors.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4x4(Bool4 col0, Bool4 col1, Bool4 col2, Bool4 col3)
	{
		this.c0 = col0;
		this.c1 = col1;
		this.c2 = col2;
		this.c3 = col3;
	}

	/// <summary>Constructs a Bool4x4 matrix from 16 bool values given in row-major order.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4x4(bool m00, bool m01, bool m02, bool m03, bool m10, bool m11, bool m12, bool m13, bool m20, bool m21, bool m22, bool m23, bool m30, bool m31, bool m32, bool m33)
	{
		this.c0 = new Bool4(m00, m10, m20, m30);
		this.c1 = new Bool4(m01, m11, m21, m31);
		this.c2 = new Bool4(m02, m12, m22, m32);
		this.c3 = new Bool4(m03, m13, m23, m33);
	}

	/// <summary>Returns a reference to the Bool4 (column) at a specified index.</summary>
	unsafe public ref Bool4 this[int index]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)index >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(index), $"Column index must be between 0 and 3, but was {index}.");

			fixed (Bool4* pC0 = &this.c0)
			{
				return ref pC0[index];
			}
		}
	}

	/// <summary>Returns the element at row and column indices.</summary>
	public bool this[int row, int column]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)column >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(column));
			return this[column][row];
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			if ((uint)column >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(column));
			var temp = this[column];
			temp[row] = value;
			this[column] = temp;
		}
	}
	// --- Component-wise Operators ---
	/// <summary>Returns the component-wise logical & of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator &(Bool4x4 lhs, Bool4x4 rhs) => new Bool4x4(lhs.c0 & rhs.c0, lhs.c1 & rhs.c1, lhs.c2 & rhs.c2, lhs.c3 & rhs.c3);

	/// <summary>Returns the component-wise logical | of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator |(Bool4x4 lhs, Bool4x4 rhs) => new Bool4x4(lhs.c0 | rhs.c0, lhs.c1 | rhs.c1, lhs.c2 | rhs.c2, lhs.c3 | rhs.c3);

	/// <summary>Returns the component-wise logical ^ of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator ^(Bool4x4 lhs, Bool4x4 rhs) => new Bool4x4(lhs.c0 ^ rhs.c0, lhs.c1 ^ rhs.c1, lhs.c2 ^ rhs.c2, lhs.c3 ^ rhs.c3);

	/// <summary>Returns the component-wise logical NOT of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator !(Bool4x4 val) => new Bool4x4(!val.c0, !val.c1, !val.c2, !val.c3);

	/// <summary>Returns true if all components are equal.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator ==(Bool4x4 lhs, Bool4x4 rhs) => lhs.c0 == rhs.c0 && lhs.c1 == rhs.c1 && lhs.c2 == rhs.c2 && lhs.c3 == rhs.c3;

	/// <summary>Returns true if any component is not equal.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator !=(Bool4x4 lhs, Bool4x4 rhs) => !(lhs == rhs);

	// --- Matrix Methods ---
	/// <summary>Gets the transpose of this matrix.</summary>
	public Bool4x4 Transpose
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Maths.Transpose(this);
	}

	/// <summary>Gets row 0 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4 GetRow0()
	{
		return new Bool4(c0.X, c1.X, c2.X, c3.X);
	}

	/// <summary>Sets row 0 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow0(Bool4 value)
	{
		c0.X = value.X;
		c1.X = value.Y;
		c2.X = value.Z;
		c3.X = value.W;
	}

	/// <summary>Gets row 1 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4 GetRow1()
	{
		return new Bool4(c0.Y, c1.Y, c2.Y, c3.Y);
	}

	/// <summary>Sets row 1 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow1(Bool4 value)
	{
		c0.Y = value.X;
		c1.Y = value.Y;
		c2.Y = value.Z;
		c3.Y = value.W;
	}

	/// <summary>Gets row 2 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4 GetRow2()
	{
		return new Bool4(c0.Z, c1.Z, c2.Z, c3.Z);
	}

	/// <summary>Sets row 2 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow2(Bool4 value)
	{
		c0.Z = value.X;
		c1.Z = value.Y;
		c2.Z = value.Z;
		c3.Z = value.W;
	}

	/// <summary>Gets row 3 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4 GetRow3()
	{
		return new Bool4(c0.W, c1.W, c2.W, c3.W);
	}

	/// <summary>Sets row 3 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow3(Bool4 value)
	{
		c0.W = value.X;
		c1.W = value.Y;
		c2.W = value.Z;
		c3.W = value.W;
	}

	/// <summary>Returns true if any component is true.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Any()
	{
		return c0.Any() || c1.Any() || c2.Any() || c3.Any();
	}

	/// <summary>Returns true if all components are true.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool All()
	{
		return c0.All() && c1.All() && c2.All() && c3.All();
	}

	/// <summary>Returns an array of components.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool[] ToArray()
	{
		bool[] array = new bool[16];
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++)
				array[i * 4 + j] = this[i, j];
		return array;
	}
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Equals(Bool4x4 rhs) { return this.c0.Equals(rhs.c0) && this.c1.Equals(rhs.c1) && this.c2.Equals(rhs.c2) && this.c3.Equals(rhs.c3); }

	public override bool Equals(object? o) { return o is Bool4x4 converted && Equals(converted); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override int GetHashCode()
	{
		unchecked // Overflow is fine, just wrap
		{
			int hash = 17;
			hash = hash * 23 + c0.GetHashCode();
			hash = hash * 23 + c1.GetHashCode();
			hash = hash * 23 + c2.GetHashCode();
			hash = hash * 23 + c3.GetHashCode();
			return hash;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override string ToString() { return ToString(null, CultureInfo.CurrentCulture); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public string ToString(string format) { return ToString(format, CultureInfo.CurrentCulture); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public string ToString(string format, IFormatProvider formatProvider)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("Bool4x4(");
		sb.Append(this.c0.X.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.X.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.X.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.X.ToString(formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.Y.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.Y.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.Y.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.Y.ToString(formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.Z.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.Z.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.Z.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.Z.ToString(formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.W.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.W.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.W.ToString(formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.W.ToString(formatProvider));
		sb.Append(")");
		return sb.ToString();
	}

}
}
