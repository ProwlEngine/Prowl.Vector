//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-10-10 14:13:41
//

using System; 
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;
using Prowl.Vector;

namespace Prowl.Vector
{

/// <summary>A 4x4 matrix of floats.</summary>
[System.Serializable]
public partial struct Float4x4 : System.IEquatable<Float4x4>, IFormattable
{
	/// <summary>Column 0 of the matrix.</summary>
	public Float4 c0;
	/// <summary>Column 1 of the matrix.</summary>
	public Float4 c1;
	/// <summary>Column 2 of the matrix.</summary>
	public Float4 c2;
	/// <summary>Column 3 of the matrix.</summary>
	public Float4 c3;

	/// <summary>Float4x4 identity transform.</summary>
	public static readonly Float4x4 Identity = new Float4x4(new Float4(1f, 0f, 0f, 0f), new Float4(0f, 1f, 0f, 0f), new Float4(0f, 0f, 1f, 0f), new Float4(0f, 0f, 0f, 1f));

	/// <summary>Float4x4 zero value.</summary>
	public static readonly Float4x4 Zero = new Float4x4(Float4.Zero, Float4.Zero, Float4.Zero, Float4.Zero);

	/// <summary>Gets or sets the translation component of the matrix.</summary>
	public Float4 Translation
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)] get => c3;
		[MethodImpl(MethodImplOptions.AggressiveInlining)] set => c3 = value;
	}

	/// <summary>Constructs a Float4x4 matrix from 4 Float4 vectors.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float4x4(Float4 col0, Float4 col1, Float4 col2, Float4 col3)
	{
		this.c0 = col0;
		this.c1 = col1;
		this.c2 = col2;
		this.c3 = col3;
	}

	/// <summary>Constructs a Float4x4 matrix from 16 float values given in row-major order.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float4x4(float m00, float m01, float m02, float m03, float m10, float m11, float m12, float m13, float m20, float m21, float m22, float m23, float m30, float m31, float m32, float m33)
	{
		this.c0 = new Float4(m00, m10, m20, m30);
		this.c1 = new Float4(m01, m11, m21, m31);
		this.c2 = new Float4(m02, m12, m22, m32);
		this.c3 = new Float4(m03, m13, m23, m33);
	}

	/// <summary>Constructs a Float4x4 matrix from a single float value by assigning it to every component.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float4x4(float v)
	{
		this.c0 = new Float4(v);
		this.c1 = new Float4(v);
		this.c2 = new Float4(v);
		this.c3 = new Float4(v);
	}

	/// <summary>Constructs a Float4x4 from a Double4x4 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float4x4(Double4x4 m)
	{
		this.c0 = new Float4(m.c0);
		this.c1 = new Float4(m.c1);
		this.c2 = new Float4(m.c2);
		this.c3 = new Float4(m.c3);
	}

	/// <summary>Constructs a Float4x4 from a Int4x4 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float4x4(Int4x4 m)
	{
		this.c0 = new Float4(m.c0);
		this.c1 = new Float4(m.c1);
		this.c2 = new Float4(m.c2);
		this.c3 = new Float4(m.c3);
	}

	/// <summary>Constructs a Float4x4 from a UInt4x4 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float4x4(UInt4x4 m)
	{
		this.c0 = new Float4(m.c0);
		this.c1 = new Float4(m.c1);
		this.c2 = new Float4(m.c2);
		this.c3 = new Float4(m.c3);
	}

	/// <summary>Returns a reference to the Float4 (column) at a specified index.</summary>
	unsafe public ref Float4 this[int index]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)index >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(index), $"Column index must be between 0 and 3, but was {index}.");

			fixed (Float4* pC0 = &this.c0)
			{
				return ref pC0[index];
			}
		}
	}

	/// <summary>Returns the element at row and column indices.</summary>
	public float this[int row, int column]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)column >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(column));
			return this[column][row];
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			if ((uint)column >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(column));
			var temp = this[column];
			temp[row] = value;
			this[column] = temp;
		}
	}
	// --- Component-wise Operators ---
	/// <summary>Returns the component-wise + of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator +(Float4x4 lhs, Float4x4 rhs) => new Float4x4(lhs.c0 + rhs.c0, lhs.c1 + rhs.c1, lhs.c2 + rhs.c2, lhs.c3 + rhs.c3);

	/// <summary>Returns the component-wise + of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator +(Float4x4 lhs, float rhs) => new Float4x4(lhs.c0 + rhs, lhs.c1 + rhs, lhs.c2 + rhs, lhs.c3 + rhs);

	/// <summary>Returns the component-wise + of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator +(float lhs, Float4x4 rhs) => new Float4x4(lhs + rhs.c0, lhs + rhs.c1, lhs + rhs.c2, lhs + rhs.c3);

	/// <summary>Returns the component-wise - of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator -(Float4x4 lhs, Float4x4 rhs) => new Float4x4(lhs.c0 - rhs.c0, lhs.c1 - rhs.c1, lhs.c2 - rhs.c2, lhs.c3 - rhs.c3);

	/// <summary>Returns the component-wise - of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator -(Float4x4 lhs, float rhs) => new Float4x4(lhs.c0 - rhs, lhs.c1 - rhs, lhs.c2 - rhs, lhs.c3 - rhs);

	/// <summary>Returns the component-wise - of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator -(float lhs, Float4x4 rhs) => new Float4x4(lhs - rhs.c0, lhs - rhs.c1, lhs - rhs.c2, lhs - rhs.c3);

	/// <summary>Returns the component-wise * of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator *(Float4x4 lhs, Float4x4 rhs) => new Float4x4(lhs.c0 * rhs.c0, lhs.c1 * rhs.c1, lhs.c2 * rhs.c2, lhs.c3 * rhs.c3);

	/// <summary>Returns the component-wise * of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator *(Float4x4 lhs, float rhs) => new Float4x4(lhs.c0 * rhs, lhs.c1 * rhs, lhs.c2 * rhs, lhs.c3 * rhs);

	/// <summary>Returns the component-wise * of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator *(float lhs, Float4x4 rhs) => new Float4x4(lhs * rhs.c0, lhs * rhs.c1, lhs * rhs.c2, lhs * rhs.c3);

	/// <summary>Returns the component-wise / of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator /(Float4x4 lhs, Float4x4 rhs) => new Float4x4(lhs.c0 / rhs.c0, lhs.c1 / rhs.c1, lhs.c2 / rhs.c2, lhs.c3 / rhs.c3);

	/// <summary>Returns the component-wise / of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator /(Float4x4 lhs, float rhs) => new Float4x4(lhs.c0 / rhs, lhs.c1 / rhs, lhs.c2 / rhs, lhs.c3 / rhs);

	/// <summary>Returns the component-wise / of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator /(float lhs, Float4x4 rhs) => new Float4x4(lhs / rhs.c0, lhs / rhs.c1, lhs / rhs.c2, lhs / rhs.c3);

	/// <summary>Returns the component-wise % of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator %(Float4x4 lhs, Float4x4 rhs) => new Float4x4(lhs.c0 % rhs.c0, lhs.c1 % rhs.c1, lhs.c2 % rhs.c2, lhs.c3 % rhs.c3);

	/// <summary>Returns the component-wise % of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator %(Float4x4 lhs, float rhs) => new Float4x4(lhs.c0 % rhs, lhs.c1 % rhs, lhs.c2 % rhs, lhs.c3 % rhs);

	/// <summary>Returns the component-wise % of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator %(float lhs, Float4x4 rhs) => new Float4x4(lhs % rhs.c0, lhs % rhs.c1, lhs % rhs.c2, lhs % rhs.c3);

	/// <summary>Returns the component-wise negation of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float4x4 operator -(Float4x4 val) => new Float4x4(-val.c0, -val.c1, -val.c2, -val.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise < comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <(Float4x4 lhs, Float4x4 rhs) => new Bool4x4(lhs.c0 < rhs.c0, lhs.c1 < rhs.c1, lhs.c2 < rhs.c2, lhs.c3 < rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise < comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <(Float4x4 lhs, float rhs) => new Bool4x4(lhs.c0 < rhs, lhs.c1 < rhs, lhs.c2 < rhs, lhs.c3 < rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise < comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <(float lhs, Float4x4 rhs) => new Bool4x4(lhs < rhs.c0, lhs < rhs.c1, lhs < rhs.c2, lhs < rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise <= comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <=(Float4x4 lhs, Float4x4 rhs) => new Bool4x4(lhs.c0 <= rhs.c0, lhs.c1 <= rhs.c1, lhs.c2 <= rhs.c2, lhs.c3 <= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise <= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <=(Float4x4 lhs, float rhs) => new Bool4x4(lhs.c0 <= rhs, lhs.c1 <= rhs, lhs.c2 <= rhs, lhs.c3 <= rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise <= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <=(float lhs, Float4x4 rhs) => new Bool4x4(lhs <= rhs.c0, lhs <= rhs.c1, lhs <= rhs.c2, lhs <= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise > comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >(Float4x4 lhs, Float4x4 rhs) => new Bool4x4(lhs.c0 > rhs.c0, lhs.c1 > rhs.c1, lhs.c2 > rhs.c2, lhs.c3 > rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise > comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >(Float4x4 lhs, float rhs) => new Bool4x4(lhs.c0 > rhs, lhs.c1 > rhs, lhs.c2 > rhs, lhs.c3 > rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise > comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >(float lhs, Float4x4 rhs) => new Bool4x4(lhs > rhs.c0, lhs > rhs.c1, lhs > rhs.c2, lhs > rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise >= comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >=(Float4x4 lhs, Float4x4 rhs) => new Bool4x4(lhs.c0 >= rhs.c0, lhs.c1 >= rhs.c1, lhs.c2 >= rhs.c2, lhs.c3 >= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise >= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >=(Float4x4 lhs, float rhs) => new Bool4x4(lhs.c0 >= rhs, lhs.c1 >= rhs, lhs.c2 >= rhs, lhs.c3 >= rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise >= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >=(float lhs, Float4x4 rhs) => new Bool4x4(lhs >= rhs.c0, lhs >= rhs.c1, lhs >= rhs.c2, lhs >= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise == comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator ==(Float4x4 lhs, Float4x4 rhs) => new Bool4x4(lhs.c0 == rhs.c0, lhs.c1 == rhs.c1, lhs.c2 == rhs.c2, lhs.c3 == rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise == comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator ==(Float4x4 lhs, float rhs) => new Bool4x4(lhs.c0 == rhs, lhs.c1 == rhs, lhs.c2 == rhs, lhs.c3 == rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise == comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator ==(float lhs, Float4x4 rhs) => new Bool4x4(lhs == rhs.c0, lhs == rhs.c1, lhs == rhs.c2, lhs == rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise != comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator !=(Float4x4 lhs, Float4x4 rhs) => new Bool4x4(lhs.c0 != rhs.c0, lhs.c1 != rhs.c1, lhs.c2 != rhs.c2, lhs.c3 != rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise != comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator !=(Float4x4 lhs, float rhs) => new Bool4x4(lhs.c0 != rhs, lhs.c1 != rhs, lhs.c2 != rhs, lhs.c3 != rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise != comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator !=(float lhs, Float4x4 rhs) => new Bool4x4(lhs != rhs.c0, lhs != rhs.c1, lhs != rhs.c2, lhs != rhs.c3);

	// --- Cross-Type Casting Operators ---
	/// <summary>Explicitly converts a Double4x4 to a Float4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static explicit operator Float4x4(Double4x4 m)
	{
		return new Float4x4((Float4)m.c0, (Float4)m.c1, (Float4)m.c2, (Float4)m.c3);
	}

	/// <summary>Implicitly converts a Int4x4 to a Float4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Float4x4(Int4x4 m)
	{
		return new Float4x4((Float4)m.c0, (Float4)m.c1, (Float4)m.c2, (Float4)m.c3);
	}

	/// <summary>Implicitly converts a UInt4x4 to a Float4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Float4x4(UInt4x4 m)
	{
		return new Float4x4((Float4)m.c0, (Float4)m.c1, (Float4)m.c2, (Float4)m.c3);
	}

	// --- System.Numerics Conversions ---
	/// <summary>Implicitly converts this Float4x4 to a System.Numerics.Matrix4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator System.Numerics.Matrix4x4(Float4x4 m)
	{
		return new System.Numerics.Matrix4x4(
			m.c0.X, m.c1.X, m.c2.X, m.c3.X,
			m.c0.Y, m.c1.Y, m.c2.Y, m.c3.Y,
			m.c0.Z, m.c1.Z, m.c2.Z, m.c3.Z,
			m.c0.W, m.c1.W, m.c2.W, m.c3.W);
	}

	/// <summary>Implicitly converts a System.Numerics.Matrix4x4 to this Float4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Float4x4(System.Numerics.Matrix4x4 m)
	{
		return new Float4x4(
			m.M11, m.M12, m.M13, m.M14,
			m.M21, m.M22, m.M23, m.M24,
			m.M31, m.M32, m.M33, m.M34,
			m.M41, m.M42, m.M43, m.M44);
	}

	// --- Matrix Methods ---
	/// <summary>Gets the transpose of this matrix.</summary>
	public Float4x4 Transpose
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Maths.Transpose(this);
	}

	/// <summary>Gets the determinant of this matrix.</summary>
	public float Determinant
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Maths.Determinant(this);
	}

	/// <summary>Gets row 0 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float4 GetRow0()
	{
		return new Float4(c0.X, c1.X, c2.X, c3.X);
	}

	/// <summary>Sets row 0 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow0(Float4 value)
	{
		c0.X = value.X;
		c1.X = value.Y;
		c2.X = value.Z;
		c3.X = value.W;
	}

	/// <summary>Gets row 1 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float4 GetRow1()
	{
		return new Float4(c0.Y, c1.Y, c2.Y, c3.Y);
	}

	/// <summary>Sets row 1 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow1(Float4 value)
	{
		c0.Y = value.X;
		c1.Y = value.Y;
		c2.Y = value.Z;
		c3.Y = value.W;
	}

	/// <summary>Gets row 2 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float4 GetRow2()
	{
		return new Float4(c0.Z, c1.Z, c2.Z, c3.Z);
	}

	/// <summary>Sets row 2 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow2(Float4 value)
	{
		c0.Z = value.X;
		c1.Z = value.Y;
		c2.Z = value.Z;
		c3.Z = value.W;
	}

	/// <summary>Gets row 3 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float4 GetRow3()
	{
		return new Float4(c0.W, c1.W, c2.W, c3.W);
	}

	/// <summary>Sets row 3 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow3(Float4 value)
	{
		c0.W = value.X;
		c1.W = value.Y;
		c2.W = value.Z;
		c3.W = value.W;
	}

	/// <summary>Returns an array of components.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float[] ToArray()
	{
		float[] array = new float[16];
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++)
				array[i * 4 + j] = this[i, j];
		return array;
	}
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Equals(Float4x4 rhs) { return this.c0.Equals(rhs.c0) && this.c1.Equals(rhs.c1) && this.c2.Equals(rhs.c2) && this.c3.Equals(rhs.c3); }

	public override bool Equals(object? o) { return o is Float4x4 converted && Equals(converted); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override int GetHashCode()
	{
		unchecked // Overflow is fine, just wrap
		{
			int hash = 17;
			hash = hash * 23 + c0.GetHashCode();
			hash = hash * 23 + c1.GetHashCode();
			hash = hash * 23 + c2.GetHashCode();
			hash = hash * 23 + c3.GetHashCode();
			return hash;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override string ToString() { return ToString(null, CultureInfo.CurrentCulture); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public string ToString(string format) { return ToString(format, CultureInfo.CurrentCulture); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public string ToString(string format, IFormatProvider formatProvider)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("Float4x4(");
		sb.Append(this.c0.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.W.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.W.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.W.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.W.ToString(format, formatProvider));
		sb.Append(")");
		return sb.ToString();
	}

}
}
