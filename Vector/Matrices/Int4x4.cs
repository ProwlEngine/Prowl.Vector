//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-10-10 14:02:57
//

using System; 
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;
using Prowl.Vector;

namespace Prowl.Vector
{

/// <summary>A 4x4 matrix of ints.</summary>
[System.Serializable]
public partial struct Int4x4 : System.IEquatable<Int4x4>, IFormattable
{
	/// <summary>Column 0 of the matrix.</summary>
	public Int4 c0;
	/// <summary>Column 1 of the matrix.</summary>
	public Int4 c1;
	/// <summary>Column 2 of the matrix.</summary>
	public Int4 c2;
	/// <summary>Column 3 of the matrix.</summary>
	public Int4 c3;

	/// <summary>Int4x4 identity transform.</summary>
	public static readonly Int4x4 Identity = new Int4x4(new Int4(1, 0, 0, 0), new Int4(0, 1, 0, 0), new Int4(0, 0, 1, 0), new Int4(0, 0, 0, 1));

	/// <summary>Int4x4 zero value.</summary>
	public static readonly Int4x4 Zero = new Int4x4(Int4.Zero, Int4.Zero, Int4.Zero, Int4.Zero);

	/// <summary>Constructs a Int4x4 matrix from 4 Int4 vectors.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Int4x4(Int4 col0, Int4 col1, Int4 col2, Int4 col3)
	{
		this.c0 = col0;
		this.c1 = col1;
		this.c2 = col2;
		this.c3 = col3;
	}

	/// <summary>Constructs a Int4x4 matrix from 16 int values given in row-major order.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Int4x4(int m00, int m01, int m02, int m03, int m10, int m11, int m12, int m13, int m20, int m21, int m22, int m23, int m30, int m31, int m32, int m33)
	{
		this.c0 = new Int4(m00, m10, m20, m30);
		this.c1 = new Int4(m01, m11, m21, m31);
		this.c2 = new Int4(m02, m12, m22, m32);
		this.c3 = new Int4(m03, m13, m23, m33);
	}

	/// <summary>Constructs a Int4x4 matrix from a single int value by assigning it to every component.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Int4x4(int v)
	{
		this.c0 = new Int4(v);
		this.c1 = new Int4(v);
		this.c2 = new Int4(v);
		this.c3 = new Int4(v);
	}

	/// <summary>Constructs a Int4x4 from a Float4x4 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Int4x4(Float4x4 m)
	{
		this.c0 = new Int4(m.c0);
		this.c1 = new Int4(m.c1);
		this.c2 = new Int4(m.c2);
		this.c3 = new Int4(m.c3);
	}

	/// <summary>Constructs a Int4x4 from a Double4x4 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Int4x4(Double4x4 m)
	{
		this.c0 = new Int4(m.c0);
		this.c1 = new Int4(m.c1);
		this.c2 = new Int4(m.c2);
		this.c3 = new Int4(m.c3);
	}

	/// <summary>Constructs a Int4x4 from a UInt4x4 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Int4x4(UInt4x4 m)
	{
		this.c0 = new Int4(m.c0);
		this.c1 = new Int4(m.c1);
		this.c2 = new Int4(m.c2);
		this.c3 = new Int4(m.c3);
	}

	/// <summary>Returns a reference to the Int4 (column) at a specified index.</summary>
	unsafe public ref Int4 this[int index]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)index >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(index), $"Column index must be between 0 and 3, but was {index}.");

			fixed (Int4* pC0 = &this.c0)
			{
				return ref pC0[index];
			}
		}
	}

	/// <summary>Returns the element at row and column indices.</summary>
	public int this[int row, int column]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)column >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(column));
			return this[column][row];
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			if ((uint)column >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(column));
			var temp = this[column];
			temp[row] = value;
			this[column] = temp;
		}
	}
	// --- Component-wise Operators ---
	/// <summary>Returns the component-wise + of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator +(Int4x4 lhs, Int4x4 rhs) => new Int4x4(lhs.c0 + rhs.c0, lhs.c1 + rhs.c1, lhs.c2 + rhs.c2, lhs.c3 + rhs.c3);

	/// <summary>Returns the component-wise + of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator +(Int4x4 lhs, int rhs) => new Int4x4(lhs.c0 + rhs, lhs.c1 + rhs, lhs.c2 + rhs, lhs.c3 + rhs);

	/// <summary>Returns the component-wise + of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator +(int lhs, Int4x4 rhs) => new Int4x4(lhs + rhs.c0, lhs + rhs.c1, lhs + rhs.c2, lhs + rhs.c3);

	/// <summary>Returns the component-wise - of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator -(Int4x4 lhs, Int4x4 rhs) => new Int4x4(lhs.c0 - rhs.c0, lhs.c1 - rhs.c1, lhs.c2 - rhs.c2, lhs.c3 - rhs.c3);

	/// <summary>Returns the component-wise - of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator -(Int4x4 lhs, int rhs) => new Int4x4(lhs.c0 - rhs, lhs.c1 - rhs, lhs.c2 - rhs, lhs.c3 - rhs);

	/// <summary>Returns the component-wise - of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator -(int lhs, Int4x4 rhs) => new Int4x4(lhs - rhs.c0, lhs - rhs.c1, lhs - rhs.c2, lhs - rhs.c3);

	/// <summary>Returns the component-wise * of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator *(Int4x4 lhs, Int4x4 rhs) => new Int4x4(lhs.c0 * rhs.c0, lhs.c1 * rhs.c1, lhs.c2 * rhs.c2, lhs.c3 * rhs.c3);

	/// <summary>Returns the component-wise * of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator *(Int4x4 lhs, int rhs) => new Int4x4(lhs.c0 * rhs, lhs.c1 * rhs, lhs.c2 * rhs, lhs.c3 * rhs);

	/// <summary>Returns the component-wise * of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator *(int lhs, Int4x4 rhs) => new Int4x4(lhs * rhs.c0, lhs * rhs.c1, lhs * rhs.c2, lhs * rhs.c3);

	/// <summary>Returns the component-wise / of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator /(Int4x4 lhs, Int4x4 rhs) => new Int4x4(lhs.c0 / rhs.c0, lhs.c1 / rhs.c1, lhs.c2 / rhs.c2, lhs.c3 / rhs.c3);

	/// <summary>Returns the component-wise / of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator /(Int4x4 lhs, int rhs) => new Int4x4(lhs.c0 / rhs, lhs.c1 / rhs, lhs.c2 / rhs, lhs.c3 / rhs);

	/// <summary>Returns the component-wise / of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator /(int lhs, Int4x4 rhs) => new Int4x4(lhs / rhs.c0, lhs / rhs.c1, lhs / rhs.c2, lhs / rhs.c3);

	/// <summary>Returns the component-wise % of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator %(Int4x4 lhs, Int4x4 rhs) => new Int4x4(lhs.c0 % rhs.c0, lhs.c1 % rhs.c1, lhs.c2 % rhs.c2, lhs.c3 % rhs.c3);

	/// <summary>Returns the component-wise % of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator %(Int4x4 lhs, int rhs) => new Int4x4(lhs.c0 % rhs, lhs.c1 % rhs, lhs.c2 % rhs, lhs.c3 % rhs);

	/// <summary>Returns the component-wise % of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator %(int lhs, Int4x4 rhs) => new Int4x4(lhs % rhs.c0, lhs % rhs.c1, lhs % rhs.c2, lhs % rhs.c3);

	/// <summary>Returns the component-wise & of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator &(Int4x4 lhs, Int4x4 rhs) => new Int4x4(lhs.c0 & rhs.c0, lhs.c1 & rhs.c1, lhs.c2 & rhs.c2, lhs.c3 & rhs.c3);

	/// <summary>Returns the component-wise | of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator |(Int4x4 lhs, Int4x4 rhs) => new Int4x4(lhs.c0 | rhs.c0, lhs.c1 | rhs.c1, lhs.c2 | rhs.c2, lhs.c3 | rhs.c3);

	/// <summary>Returns the component-wise ^ of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator ^(Int4x4 lhs, Int4x4 rhs) => new Int4x4(lhs.c0 ^ rhs.c0, lhs.c1 ^ rhs.c1, lhs.c2 ^ rhs.c2, lhs.c3 ^ rhs.c3);

	/// <summary>Returns the component-wise << of matrix by scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator <<(Int4x4 lhs, int rhs) => new Int4x4(lhs.c0 << rhs, lhs.c1 << rhs, lhs.c2 << rhs, lhs.c3 << rhs);

	/// <summary>Returns the component-wise >> of matrix by scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator >>(Int4x4 lhs, int rhs) => new Int4x4(lhs.c0 >> rhs, lhs.c1 >> rhs, lhs.c2 >> rhs, lhs.c3 >> rhs);

	/// <summary>Returns the component-wise bitwise NOT of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator ~(Int4x4 val) => new Int4x4(~val.c0, ~val.c1, ~val.c2, ~val.c3);

	/// <summary>Returns the component-wise negation of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Int4x4 operator -(Int4x4 val) => new Int4x4(-val.c0, -val.c1, -val.c2, -val.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise < comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <(Int4x4 lhs, Int4x4 rhs) => new Bool4x4(lhs.c0 < rhs.c0, lhs.c1 < rhs.c1, lhs.c2 < rhs.c2, lhs.c3 < rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise < comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <(Int4x4 lhs, int rhs) => new Bool4x4(lhs.c0 < rhs, lhs.c1 < rhs, lhs.c2 < rhs, lhs.c3 < rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise < comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <(int lhs, Int4x4 rhs) => new Bool4x4(lhs < rhs.c0, lhs < rhs.c1, lhs < rhs.c2, lhs < rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise <= comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <=(Int4x4 lhs, Int4x4 rhs) => new Bool4x4(lhs.c0 <= rhs.c0, lhs.c1 <= rhs.c1, lhs.c2 <= rhs.c2, lhs.c3 <= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise <= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <=(Int4x4 lhs, int rhs) => new Bool4x4(lhs.c0 <= rhs, lhs.c1 <= rhs, lhs.c2 <= rhs, lhs.c3 <= rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise <= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <=(int lhs, Int4x4 rhs) => new Bool4x4(lhs <= rhs.c0, lhs <= rhs.c1, lhs <= rhs.c2, lhs <= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise > comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >(Int4x4 lhs, Int4x4 rhs) => new Bool4x4(lhs.c0 > rhs.c0, lhs.c1 > rhs.c1, lhs.c2 > rhs.c2, lhs.c3 > rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise > comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >(Int4x4 lhs, int rhs) => new Bool4x4(lhs.c0 > rhs, lhs.c1 > rhs, lhs.c2 > rhs, lhs.c3 > rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise > comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >(int lhs, Int4x4 rhs) => new Bool4x4(lhs > rhs.c0, lhs > rhs.c1, lhs > rhs.c2, lhs > rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise >= comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >=(Int4x4 lhs, Int4x4 rhs) => new Bool4x4(lhs.c0 >= rhs.c0, lhs.c1 >= rhs.c1, lhs.c2 >= rhs.c2, lhs.c3 >= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise >= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >=(Int4x4 lhs, int rhs) => new Bool4x4(lhs.c0 >= rhs, lhs.c1 >= rhs, lhs.c2 >= rhs, lhs.c3 >= rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise >= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >=(int lhs, Int4x4 rhs) => new Bool4x4(lhs >= rhs.c0, lhs >= rhs.c1, lhs >= rhs.c2, lhs >= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise == comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator ==(Int4x4 lhs, Int4x4 rhs) => new Bool4x4(lhs.c0 == rhs.c0, lhs.c1 == rhs.c1, lhs.c2 == rhs.c2, lhs.c3 == rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise == comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator ==(Int4x4 lhs, int rhs) => new Bool4x4(lhs.c0 == rhs, lhs.c1 == rhs, lhs.c2 == rhs, lhs.c3 == rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise == comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator ==(int lhs, Int4x4 rhs) => new Bool4x4(lhs == rhs.c0, lhs == rhs.c1, lhs == rhs.c2, lhs == rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise != comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator !=(Int4x4 lhs, Int4x4 rhs) => new Bool4x4(lhs.c0 != rhs.c0, lhs.c1 != rhs.c1, lhs.c2 != rhs.c2, lhs.c3 != rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise != comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator !=(Int4x4 lhs, int rhs) => new Bool4x4(lhs.c0 != rhs, lhs.c1 != rhs, lhs.c2 != rhs, lhs.c3 != rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise != comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator !=(int lhs, Int4x4 rhs) => new Bool4x4(lhs != rhs.c0, lhs != rhs.c1, lhs != rhs.c2, lhs != rhs.c3);

	// --- Cross-Type Casting Operators ---
	/// <summary>Explicitly converts a Float4x4 to a Int4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static explicit operator Int4x4(Float4x4 m)
	{
		return new Int4x4((Int4)m.c0, (Int4)m.c1, (Int4)m.c2, (Int4)m.c3);
	}

	/// <summary>Explicitly converts a Double4x4 to a Int4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static explicit operator Int4x4(Double4x4 m)
	{
		return new Int4x4((Int4)m.c0, (Int4)m.c1, (Int4)m.c2, (Int4)m.c3);
	}

	/// <summary>Explicitly converts a UInt4x4 to a Int4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static explicit operator Int4x4(UInt4x4 m)
	{
		return new Int4x4((Int4)m.c0, (Int4)m.c1, (Int4)m.c2, (Int4)m.c3);
	}

	// --- Matrix Methods ---
	/// <summary>Gets the transpose of this matrix.</summary>
	public Int4x4 Transpose
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Maths.Transpose(this);
	}

	/// <summary>Gets row 0 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Int4 GetRow0()
	{
		return new Int4(c0.X, c1.X, c2.X, c3.X);
	}

	/// <summary>Sets row 0 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow0(Int4 value)
	{
		c0.X = value.X;
		c1.X = value.Y;
		c2.X = value.Z;
		c3.X = value.W;
	}

	/// <summary>Gets row 1 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Int4 GetRow1()
	{
		return new Int4(c0.Y, c1.Y, c2.Y, c3.Y);
	}

	/// <summary>Sets row 1 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow1(Int4 value)
	{
		c0.Y = value.X;
		c1.Y = value.Y;
		c2.Y = value.Z;
		c3.Y = value.W;
	}

	/// <summary>Gets row 2 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Int4 GetRow2()
	{
		return new Int4(c0.Z, c1.Z, c2.Z, c3.Z);
	}

	/// <summary>Sets row 2 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow2(Int4 value)
	{
		c0.Z = value.X;
		c1.Z = value.Y;
		c2.Z = value.Z;
		c3.Z = value.W;
	}

	/// <summary>Gets row 3 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Int4 GetRow3()
	{
		return new Int4(c0.W, c1.W, c2.W, c3.W);
	}

	/// <summary>Sets row 3 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow3(Int4 value)
	{
		c0.W = value.X;
		c1.W = value.Y;
		c2.W = value.Z;
		c3.W = value.W;
	}

	/// <summary>Returns an array of components.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public int[] ToArray()
	{
		int[] array = new int[16];
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++)
				array[i * 4 + j] = this[i, j];
		return array;
	}
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Equals(Int4x4 rhs) { return this.c0.Equals(rhs.c0) && this.c1.Equals(rhs.c1) && this.c2.Equals(rhs.c2) && this.c3.Equals(rhs.c3); }

	public override bool Equals(object? o) { return o is Int4x4 converted && Equals(converted); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override int GetHashCode()
	{
		unchecked // Overflow is fine, just wrap
		{
			int hash = 17;
			hash = hash * 23 + c0.GetHashCode();
			hash = hash * 23 + c1.GetHashCode();
			hash = hash * 23 + c2.GetHashCode();
			hash = hash * 23 + c3.GetHashCode();
			return hash;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override string ToString() { return ToString(null, CultureInfo.CurrentCulture); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public string ToString(string format) { return ToString(format, CultureInfo.CurrentCulture); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public string ToString(string format, IFormatProvider formatProvider)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("Int4x4(");
		sb.Append(this.c0.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.W.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.W.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.W.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.W.ToString(format, formatProvider));
		sb.Append(")");
		return sb.ToString();
	}

}
}
