//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-10-09 16:49:56
//

using System; 
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Text;
using Prowl.Vector;

namespace Prowl.Vector
{

/// <summary>A 4x4 matrix of uints.</summary>
[System.Serializable]
public partial struct UInt4x4 : System.IEquatable<UInt4x4>, IFormattable
{
	/// <summary>Column 0 of the matrix.</summary>
	public UInt4 c0;
	/// <summary>Column 1 of the matrix.</summary>
	public UInt4 c1;
	/// <summary>Column 2 of the matrix.</summary>
	public UInt4 c2;
	/// <summary>Column 3 of the matrix.</summary>
	public UInt4 c3;

	/// <summary>UInt4x4 identity transform.</summary>
	public static readonly UInt4x4 Identity = new UInt4x4(new UInt4(1u, 0u, 0u, 0u), new UInt4(0u, 1u, 0u, 0u), new UInt4(0u, 0u, 1u, 0u), new UInt4(0u, 0u, 0u, 1u));

	/// <summary>UInt4x4 zero value.</summary>
	public static readonly UInt4x4 Zero = new UInt4x4(UInt4.Zero, UInt4.Zero, UInt4.Zero, UInt4.Zero);

	/// <summary>Constructs a UInt4x4 matrix from 4 UInt4 vectors.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public UInt4x4(UInt4 col0, UInt4 col1, UInt4 col2, UInt4 col3)
	{
		this.c0 = col0;
		this.c1 = col1;
		this.c2 = col2;
		this.c3 = col3;
	}

	/// <summary>Constructs a UInt4x4 matrix from 16 uint values given in row-major order.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public UInt4x4(uint m00, uint m01, uint m02, uint m03, uint m10, uint m11, uint m12, uint m13, uint m20, uint m21, uint m22, uint m23, uint m30, uint m31, uint m32, uint m33)
	{
		this.c0 = new UInt4(m00, m10, m20, m30);
		this.c1 = new UInt4(m01, m11, m21, m31);
		this.c2 = new UInt4(m02, m12, m22, m32);
		this.c3 = new UInt4(m03, m13, m23, m33);
	}

	/// <summary>Constructs a UInt4x4 matrix from a single uint value by assigning it to every component.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public UInt4x4(uint v)
	{
		this.c0 = new UInt4(v);
		this.c1 = new UInt4(v);
		this.c2 = new UInt4(v);
		this.c3 = new UInt4(v);
	}

	/// <summary>Constructs a UInt4x4 from a Float4x4 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public UInt4x4(Float4x4 m)
	{
		this.c0 = new UInt4(m.c0);
		this.c1 = new UInt4(m.c1);
		this.c2 = new UInt4(m.c2);
		this.c3 = new UInt4(m.c3);
	}

	/// <summary>Constructs a UInt4x4 from a Double4x4 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public UInt4x4(Double4x4 m)
	{
		this.c0 = new UInt4(m.c0);
		this.c1 = new UInt4(m.c1);
		this.c2 = new UInt4(m.c2);
		this.c3 = new UInt4(m.c3);
	}

	/// <summary>Constructs a UInt4x4 from a Int4x4 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public UInt4x4(Int4x4 m)
	{
		this.c0 = new UInt4(m.c0);
		this.c1 = new UInt4(m.c1);
		this.c2 = new UInt4(m.c2);
		this.c3 = new UInt4(m.c3);
	}

	/// <summary>Returns a reference to the UInt4 (column) at a specified index.</summary>
	unsafe public ref UInt4 this[int index]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)index >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(index), $"Column index must be between 0 and 3, but was {index}.");

			fixed (UInt4* pC0 = &this.c0)
			{
				return ref pC0[index];
			}
		}
	}

	/// <summary>Returns the element at row and column indices.</summary>
	public uint this[int row, int column]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			if ((uint)column >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(column));
			return this[column][row];
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			if ((uint)column >= 4)
				throw new System.ArgumentOutOfRangeException(nameof(column));
			var temp = this[column];
			temp[row] = value;
			this[column] = temp;
		}
	}
	// --- Component-wise Operators ---
	/// <summary>Returns the component-wise + of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator +(UInt4x4 lhs, UInt4x4 rhs) => new UInt4x4(lhs.c0 + rhs.c0, lhs.c1 + rhs.c1, lhs.c2 + rhs.c2, lhs.c3 + rhs.c3);

	/// <summary>Returns the component-wise + of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator +(UInt4x4 lhs, uint rhs) => new UInt4x4(lhs.c0 + rhs, lhs.c1 + rhs, lhs.c2 + rhs, lhs.c3 + rhs);

	/// <summary>Returns the component-wise + of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator +(uint lhs, UInt4x4 rhs) => new UInt4x4(lhs + rhs.c0, lhs + rhs.c1, lhs + rhs.c2, lhs + rhs.c3);

	/// <summary>Returns the component-wise - of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator -(UInt4x4 lhs, UInt4x4 rhs) => new UInt4x4(lhs.c0 - rhs.c0, lhs.c1 - rhs.c1, lhs.c2 - rhs.c2, lhs.c3 - rhs.c3);

	/// <summary>Returns the component-wise - of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator -(UInt4x4 lhs, uint rhs) => new UInt4x4(lhs.c0 - rhs, lhs.c1 - rhs, lhs.c2 - rhs, lhs.c3 - rhs);

	/// <summary>Returns the component-wise - of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator -(uint lhs, UInt4x4 rhs) => new UInt4x4(lhs - rhs.c0, lhs - rhs.c1, lhs - rhs.c2, lhs - rhs.c3);

	/// <summary>Returns the component-wise * of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator *(UInt4x4 lhs, UInt4x4 rhs) => new UInt4x4(lhs.c0 * rhs.c0, lhs.c1 * rhs.c1, lhs.c2 * rhs.c2, lhs.c3 * rhs.c3);

	/// <summary>Returns the component-wise * of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator *(UInt4x4 lhs, uint rhs) => new UInt4x4(lhs.c0 * rhs, lhs.c1 * rhs, lhs.c2 * rhs, lhs.c3 * rhs);

	/// <summary>Returns the component-wise * of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator *(uint lhs, UInt4x4 rhs) => new UInt4x4(lhs * rhs.c0, lhs * rhs.c1, lhs * rhs.c2, lhs * rhs.c3);

	/// <summary>Returns the component-wise / of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator /(UInt4x4 lhs, UInt4x4 rhs) => new UInt4x4(lhs.c0 / rhs.c0, lhs.c1 / rhs.c1, lhs.c2 / rhs.c2, lhs.c3 / rhs.c3);

	/// <summary>Returns the component-wise / of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator /(UInt4x4 lhs, uint rhs) => new UInt4x4(lhs.c0 / rhs, lhs.c1 / rhs, lhs.c2 / rhs, lhs.c3 / rhs);

	/// <summary>Returns the component-wise / of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator /(uint lhs, UInt4x4 rhs) => new UInt4x4(lhs / rhs.c0, lhs / rhs.c1, lhs / rhs.c2, lhs / rhs.c3);

	/// <summary>Returns the component-wise % of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator %(UInt4x4 lhs, UInt4x4 rhs) => new UInt4x4(lhs.c0 % rhs.c0, lhs.c1 % rhs.c1, lhs.c2 % rhs.c2, lhs.c3 % rhs.c3);

	/// <summary>Returns the component-wise % of matrix and scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator %(UInt4x4 lhs, uint rhs) => new UInt4x4(lhs.c0 % rhs, lhs.c1 % rhs, lhs.c2 % rhs, lhs.c3 % rhs);

	/// <summary>Returns the component-wise % of scalar and matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator %(uint lhs, UInt4x4 rhs) => new UInt4x4(lhs % rhs.c0, lhs % rhs.c1, lhs % rhs.c2, lhs % rhs.c3);

	/// <summary>Returns the component-wise & of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator &(UInt4x4 lhs, UInt4x4 rhs) => new UInt4x4(lhs.c0 & rhs.c0, lhs.c1 & rhs.c1, lhs.c2 & rhs.c2, lhs.c3 & rhs.c3);

	/// <summary>Returns the component-wise | of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator |(UInt4x4 lhs, UInt4x4 rhs) => new UInt4x4(lhs.c0 | rhs.c0, lhs.c1 | rhs.c1, lhs.c2 | rhs.c2, lhs.c3 | rhs.c3);

	/// <summary>Returns the component-wise ^ of two matrices.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator ^(UInt4x4 lhs, UInt4x4 rhs) => new UInt4x4(lhs.c0 ^ rhs.c0, lhs.c1 ^ rhs.c1, lhs.c2 ^ rhs.c2, lhs.c3 ^ rhs.c3);

	/// <summary>Returns the component-wise << of matrix by scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator <<(UInt4x4 lhs, int rhs) => new UInt4x4(lhs.c0 << rhs, lhs.c1 << rhs, lhs.c2 << rhs, lhs.c3 << rhs);

	/// <summary>Returns the component-wise >> of matrix by scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator >>(UInt4x4 lhs, int rhs) => new UInt4x4(lhs.c0 >> rhs, lhs.c1 >> rhs, lhs.c2 >> rhs, lhs.c3 >> rhs);

	/// <summary>Returns the component-wise bitwise NOT of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static UInt4x4 operator ~(UInt4x4 val) => new UInt4x4(~val.c0, ~val.c1, ~val.c2, ~val.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise < comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <(UInt4x4 lhs, UInt4x4 rhs) => new Bool4x4(lhs.c0 < rhs.c0, lhs.c1 < rhs.c1, lhs.c2 < rhs.c2, lhs.c3 < rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise < comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <(UInt4x4 lhs, uint rhs) => new Bool4x4(lhs.c0 < rhs, lhs.c1 < rhs, lhs.c2 < rhs, lhs.c3 < rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise < comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <(uint lhs, UInt4x4 rhs) => new Bool4x4(lhs < rhs.c0, lhs < rhs.c1, lhs < rhs.c2, lhs < rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise <= comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <=(UInt4x4 lhs, UInt4x4 rhs) => new Bool4x4(lhs.c0 <= rhs.c0, lhs.c1 <= rhs.c1, lhs.c2 <= rhs.c2, lhs.c3 <= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise <= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <=(UInt4x4 lhs, uint rhs) => new Bool4x4(lhs.c0 <= rhs, lhs.c1 <= rhs, lhs.c2 <= rhs, lhs.c3 <= rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise <= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator <=(uint lhs, UInt4x4 rhs) => new Bool4x4(lhs <= rhs.c0, lhs <= rhs.c1, lhs <= rhs.c2, lhs <= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise > comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >(UInt4x4 lhs, UInt4x4 rhs) => new Bool4x4(lhs.c0 > rhs.c0, lhs.c1 > rhs.c1, lhs.c2 > rhs.c2, lhs.c3 > rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise > comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >(UInt4x4 lhs, uint rhs) => new Bool4x4(lhs.c0 > rhs, lhs.c1 > rhs, lhs.c2 > rhs, lhs.c3 > rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise > comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >(uint lhs, UInt4x4 rhs) => new Bool4x4(lhs > rhs.c0, lhs > rhs.c1, lhs > rhs.c2, lhs > rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise >= comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >=(UInt4x4 lhs, UInt4x4 rhs) => new Bool4x4(lhs.c0 >= rhs.c0, lhs.c1 >= rhs.c1, lhs.c2 >= rhs.c2, lhs.c3 >= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise >= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >=(UInt4x4 lhs, uint rhs) => new Bool4x4(lhs.c0 >= rhs, lhs.c1 >= rhs, lhs.c2 >= rhs, lhs.c3 >= rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise >= comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator >=(uint lhs, UInt4x4 rhs) => new Bool4x4(lhs >= rhs.c0, lhs >= rhs.c1, lhs >= rhs.c2, lhs >= rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise == comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator ==(UInt4x4 lhs, UInt4x4 rhs) => new Bool4x4(lhs.c0 == rhs.c0, lhs.c1 == rhs.c1, lhs.c2 == rhs.c2, lhs.c3 == rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise == comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator ==(UInt4x4 lhs, uint rhs) => new Bool4x4(lhs.c0 == rhs, lhs.c1 == rhs, lhs.c2 == rhs, lhs.c3 == rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise == comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator ==(uint lhs, UInt4x4 rhs) => new Bool4x4(lhs == rhs.c0, lhs == rhs.c1, lhs == rhs.c2, lhs == rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise != comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator !=(UInt4x4 lhs, UInt4x4 rhs) => new Bool4x4(lhs.c0 != rhs.c0, lhs.c1 != rhs.c1, lhs.c2 != rhs.c2, lhs.c3 != rhs.c3);

	/// <summary>Returns a Bool4x4 indicating component-wise != comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator !=(UInt4x4 lhs, uint rhs) => new Bool4x4(lhs.c0 != rhs, lhs.c1 != rhs, lhs.c2 != rhs, lhs.c3 != rhs);

	/// <summary>Returns a Bool4x4 indicating component-wise != comparison with scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4x4 operator !=(uint lhs, UInt4x4 rhs) => new Bool4x4(lhs != rhs.c0, lhs != rhs.c1, lhs != rhs.c2, lhs != rhs.c3);

	// --- Cross-Type Casting Operators ---
	/// <summary>Explicitly converts a Float4x4 to a UInt4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static explicit operator UInt4x4(Float4x4 m)
	{
		return new UInt4x4((UInt4)m.c0, (UInt4)m.c1, (UInt4)m.c2, (UInt4)m.c3);
	}

	/// <summary>Explicitly converts a Double4x4 to a UInt4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static explicit operator UInt4x4(Double4x4 m)
	{
		return new UInt4x4((UInt4)m.c0, (UInt4)m.c1, (UInt4)m.c2, (UInt4)m.c3);
	}

	/// <summary>Explicitly converts a Int4x4 to a UInt4x4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static explicit operator UInt4x4(Int4x4 m)
	{
		return new UInt4x4((UInt4)m.c0, (UInt4)m.c1, (UInt4)m.c2, (UInt4)m.c3);
	}

	// --- Matrix Methods ---
	/// <summary>Gets the transpose of this matrix.</summary>
	public UInt4x4 Transpose
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get => Maths.Transpose(this);
	}

	/// <summary>Gets row 0 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public UInt4 GetRow0()
	{
		return new UInt4(c0.X, c1.X, c2.X, c3.X);
	}

	/// <summary>Sets row 0 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow0(UInt4 value)
	{
		c0.X = value.X;
		c1.X = value.Y;
		c2.X = value.Z;
		c3.X = value.W;
	}

	/// <summary>Gets row 1 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public UInt4 GetRow1()
	{
		return new UInt4(c0.Y, c1.Y, c2.Y, c3.Y);
	}

	/// <summary>Sets row 1 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow1(UInt4 value)
	{
		c0.Y = value.X;
		c1.Y = value.Y;
		c2.Y = value.Z;
		c3.Y = value.W;
	}

	/// <summary>Gets row 2 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public UInt4 GetRow2()
	{
		return new UInt4(c0.Z, c1.Z, c2.Z, c3.Z);
	}

	/// <summary>Sets row 2 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow2(UInt4 value)
	{
		c0.Z = value.X;
		c1.Z = value.Y;
		c2.Z = value.Z;
		c3.Z = value.W;
	}

	/// <summary>Gets row 3 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public UInt4 GetRow3()
	{
		return new UInt4(c0.W, c1.W, c2.W, c3.W);
	}

	/// <summary>Sets row 3 of the matrix.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public void SetRow3(UInt4 value)
	{
		c0.W = value.X;
		c1.W = value.Y;
		c2.W = value.Z;
		c3.W = value.W;
	}

	/// <summary>Returns an array of components.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public uint[] ToArray()
	{
		uint[] array = new uint[16];
		for (int i = 0; i < 4; i++)
			for (int j = 0; j < 4; j++)
				array[i * 4 + j] = this[i, j];
		return array;
	}
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Equals(UInt4x4 rhs) { return this.c0.Equals(rhs.c0) && this.c1.Equals(rhs.c1) && this.c2.Equals(rhs.c2) && this.c3.Equals(rhs.c3); }

	public override bool Equals(object? o) { return o is UInt4x4 converted && Equals(converted); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override int GetHashCode()
	{
		unchecked // Overflow is fine, just wrap
		{
			int hash = 17;
			hash = hash * 23 + c0.GetHashCode();
			hash = hash * 23 + c1.GetHashCode();
			hash = hash * 23 + c2.GetHashCode();
			hash = hash * 23 + c3.GetHashCode();
			return hash;
		}
	}

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public override string ToString() { return ToString(null, CultureInfo.CurrentCulture); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public string ToString(string format) { return ToString(format, CultureInfo.CurrentCulture); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public string ToString(string format, IFormatProvider formatProvider)
	{
		StringBuilder sb = new StringBuilder();
		sb.Append("UInt4x4(");
		sb.Append(this.c0.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.X.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.Y.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.Z.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append("  ");
		sb.Append(this.c0.W.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c1.W.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c2.W.ToString(format, formatProvider));
		sb.Append(", ");
		sb.Append(this.c3.W.ToString(format, formatProvider));
		sb.Append(")");
		return sb.ToString();
	}

}
}
