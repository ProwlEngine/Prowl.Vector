//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-10-08 21:36:15
//

// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace Prowl.Vector.Spatial
{
    /// <summary>
    /// Represents a 2D affine transformation matrix. Provides a rich API for manipulating
    /// position, rotation, and scale, suitable for 2D object transformations.
    /// The matrix is in the form:
    /// | A C E |
    /// | B D F |
    /// | 0 0 1 |
    /// </summary>
    public struct Transform2DD : IEquatable<Transform2DD>, IFormattable
    {
        public double A, B, C, D, E, F;

        /// <summary>A transform with default values, representing no transformation.</summary>
        public static readonly Transform2DD Identity = new Transform2DD(1.0, 0.0, 0.0, 1.0, 0.0, 0.0);

        /// <summary>Initializes a new transform with the specified coefficients.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Transform2DD(double a, double b, double c, double d, double e, double f)
        {
            A = a; B = b; C = c; D = d; E = e; F = f;
        }

        #region High-Level Properties

        /// <summary>
        /// Gets or sets the position (translation) of the transform.
        /// </summary>
        public Double2 Position
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => new Double2(E, F);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set { E = value.X; F = value.Y; }
        }

        /// <summary>
        /// Gets or sets the rotation of the transform in degrees.
        /// When setting, this preserves the existing scale and translation.
        /// </summary>
        public double Rotation
        {
            get => Maths.Atan2(B, A) * (double)Maths.Rad2Deg;
            set
            {
                // Preserve scale and translation
                var scale = this.Scale;
                var position = this.Position;
                var rad = value * (double)Maths.Deg2Rad;
                var cs = Maths.Cos(rad);
                var sn = Maths.Sin(rad);

                A = cs * scale.X;
                B = sn * scale.X;
                C = -sn * scale.Y;
                D = cs * scale.Y;
                E = position.X;
                F = position.Y;
            }
        }

        /// <summary>
        /// Gets or sets the scale of the transform.
        /// When setting, this preserves the existing rotation and translation.
        /// </summary>
        public Double2 Scale
        {
            get => new Double2(Maths.Sqrt(A * A + B * B), Maths.Sqrt(C * C + D * D));
            set
            {
                // Preserve rotation and translation
                var rotation = this.Rotation;
                var position = this.Position;
                var rad = rotation * (double)Maths.Deg2Rad;
                var cs = Maths.Cos(rad);
                var sn = Maths.Sin(rad);

                A = cs * value.X;
                B = sn * value.X;
                C = -sn * value.Y;
                D = cs * value.Y;
                E = position.X;
                F = position.Y;
            }
        }

        /// <summary>
        /// Gets the normalized right-facing direction vector of the transform's local space (+X axis).
        /// </summary>
        public Double2 Right => new Double2(A, B).Normalized;

        /// <summary>
        /// Gets the normalized up-facing direction vector of the transform's local space (+Y axis).
        /// </summary>
        public Double2 Up => new Double2(C, D).Normalized;

        #endregion

        #region Imperative Transformations

        /// <summary>Applies a translation to the current transform.</summary>
        /// <param name="translation">The vector to translate by.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Translate(Double2 translation)
        {
            this = this * CreateTranslation(translation.X, translation.Y);
        }

        /// <summary>Applies a rotation (in degrees) to the current transform, relative to its own origin.</summary>
        /// <param name="degrees">The angle to rotate by, in degrees.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rotate(double degrees)
        {
            this = this * CreateRotation(degrees);
        }

        /// <summary>Applies a rotation (in degrees) to the current transform around a world-space pivot point.</summary>
        /// <param name="pivot">The world-space point to rotate around.</param>
        /// <param name="degrees">The angle to rotate by, in degrees.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RotateAround(Double2 pivot, double degrees)
        {
            this = CreateTranslation(pivot) * CreateRotation(degrees) * CreateTranslation(-pivot) * this;
        }
        
        /// <summary>Applies a scale to the current transform, relative to its own origin.</summary>
        /// <param name="scale">The vector to scale by.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void AddScale(Double2 scale)
        {
            this = this * CreateScale(scale.X, scale.Y);
        }

        /// <summary>Applies a scale to the current transform around a world-space pivot point.</summary>
        /// <param name="pivot">The world-space point to scale around.</param>
        /// <param name="scale">The vector to scale by.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void ScaleAround(Double2 pivot, Double2 scale)
        {
            this = CreateTranslation(pivot) * CreateScale(scale.X, scale.Y) * CreateTranslation(-pivot) * this;
        }

        #endregion
        
        #region Game Logic & Space Transformations

        /// <summary>
        /// Rotates the transform to face a target point in world space.
        /// The local right-facing axis (+X) will point towards the target.
        /// </summary>
        /// <param name="worldTarget">The world-space position to look at.</param>
        public void LookAt(Double2 worldTarget)
        {
            var direction = (worldTarget - this.Position).Normalized;
            this.Rotation = Maths.Atan2(direction.Y, direction.X) * (double)Maths.Rad2Deg;
        }

        /// <summary>
        /// Gets the angle in degrees from this transform's position to a world target.
        /// </summary>
        /// <param name="worldTarget">The world-space position.</param>
        /// <returns>The angle in degrees.</returns>
        public double GetAngleTo(Double2 worldTarget)
        {
            var direction = (worldTarget - this.Position).Normalized;
            return Maths.Atan2(direction.Y, direction.X) * (double)Maths.Rad2Deg;
        }
        
        /// <summary>Transforms a point from local space to world space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double2 TransformPoint(Double2 localPoint) => new Double2(localPoint.X * A + localPoint.Y * C + E, localPoint.X * B + localPoint.Y * D + F);
        
        /// <summary>Transforms a point from world space to local space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double2 InverseTransformPoint(Double2 worldPoint) => this.Inverse() * worldPoint;

        /// <summary>Transforms a direction from local space to world space (ignoring translation).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double2 TransformDirection(Double2 localDirection) => new Double2(localDirection.X * A + localDirection.Y * C, localDirection.X * B + localDirection.Y * D);

        /// <summary>Transforms a direction from world space to local space (ignoring translation).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double2 InverseTransformDirection(Double2 worldDirection)
        {
            var inv = this.Inverse();
            return new Double2(worldDirection.X * inv.A + worldDirection.Y * inv.C, worldDirection.X * inv.B + worldDirection.Y * inv.D);
        }

        #endregion

        #region Core Matrix Operations

        /// <summary>Checks if this transform is the identity matrix.</summary>
        public bool IsIdentity => A == 1.0 && B == 0.0 && C == 0.0 && D == 1.0 && E == 0.0 && F == 0.0;

        /// <summary>Checks if this transform only contains translation.</summary>
        public bool IsIdentityOrTranslation => A == 1.0 && B == 0.0 && C == 0.0 && D == 1.0;

        /// <summary>Checks if this transform can be inverted.</summary>
        public bool IsInvertible => Maths.Abs(A * D - C * B) > double.Epsilon;

        /// <summary>Returns the inverse of this transform.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Transform2DD Inverse()
        {
            if (IsIdentityOrTranslation)
                return CreateTranslation(-E, -F);

            var det = A * D - C * B;
            if (Maths.Abs(det) <= double.Epsilon)
                return Identity;

            var invDet = 1.0 / det;
            return new Transform2DD(
                D * invDet, -B * invDet,
                -C * invDet, A * invDet,
                (C * F - D * E) * invDet,
                (B * E - A * F) * invDet
            );
        }

        /// <summary>Converts this 2D transform to a 4x4 matrix, suitable for 3D rendering pipelines.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double4x4 ToMatrix4x4()
        {
            return new Double4x4(
                new Double4(A, B, 0.0, 0.0),
                new Double4(C, D, 0.0, 0.0),
                new Double4(0.0, 0.0, 1.0, 0.0),
                new Double4(E, F, 0.0, 1.0)
            );
        }

        /// <summary>Linearly interpolates between two transforms. Note: this can cause shearing on intermediate steps if there are large rotational differences.</summary>
        public static Transform2DD Lerp(Transform2DD start, Transform2DD end, double amount)
        {
            amount = Maths.Clamp(amount, 0.0, 1.0);
            return new Transform2DD(
                start.A + (end.A - start.A) * amount,
                start.B + (end.B - start.B) * amount,
                start.C + (end.C - start.C) * amount,
                start.D + (end.D - start.D) * amount,
                start.E + (end.E - start.E) * amount,
                start.F + (end.F - start.F) * amount
            );
        }

        #endregion

        #region Static Factory Methods

        /// <summary>Creates a translation transform.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD CreateTranslation(Double2 translation) => new Transform2DD(1.0, 0.0, 0.0, 1.0, translation.X, translation.Y);

        /// <summary>Creates a translation transform.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD CreateTranslation(double tx, double ty) => new Transform2DD(1.0, 0.0, 0.0, 1.0, tx, ty);

        /// <summary>Creates a rotation transform with the angle specified in degrees.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD CreateRotation(double angleInDegrees) => CreateRotationRadians(angleInDegrees * (double)Maths.Deg2Rad);

        /// <summary>Creates a rotation transform with the angle specified in radians.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD CreateRotationRadians(double angleInRadians)
        {
            var cs = Maths.Cos(angleInRadians);
            var sn = Maths.Sin(angleInRadians);
            return new Transform2DD(cs, sn, -sn, cs, 0.0, 0.0);
        }
        
        /// <summary>Creates a uniform scale transform.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD CreateScale(double s) => new Transform2DD(s, 0.0, 0.0, s, 0.0, 0.0);
        
        /// <summary>Creates a non-uniform scale transform.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD CreateScale(double sx, double sy) => new Transform2DD(sx, 0.0, 0.0, sy, 0.0, 0.0);

        /// <summary>Creates a skew transform along the X-axis.</summary>
        /// <param name="angleInDegrees">The angle in degrees to skew by.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD CreateSkewX(double angleInDegrees)
        {
            return new Transform2DD(1.0, 0.0, Maths.Tan(angleInDegrees * (double)Maths.Deg2Rad), 1.0, 0.0, 0.0);
        }

        /// <summary>Creates a skew transform along the Y-axis.</summary>
        /// <param name="angleInDegrees">The angle in degrees to skew by.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD CreateSkewY(double angleInDegrees)
        {
            return new Transform2DD(1.0, Maths.Tan(angleInDegrees * (double)Maths.Deg2Rad), 0.0, 1.0, 0.0, 0.0);
        }

        /// <summary>Creates a skew transform along the X-axis around a pivot point.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD CreateSkewX(double angleInDegrees, Double2 origin)
        {
            return CreateTranslation(origin) * CreateSkewX(angleInDegrees) * CreateTranslation(-origin);
        }

        /// <summary>Creates a skew transform along the Y-axis around a pivot point.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD CreateSkewY(double angleInDegrees, Double2 origin)
        {
            return CreateTranslation(origin) * CreateSkewY(angleInDegrees) * CreateTranslation(-origin);
        }

        #endregion

        #region Operators

        /// <summary>Multiplies two transforms together (concatenates them).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform2DD operator *(Transform2DD left, Transform2DD right)
        {
            // Note: This is the standard affine matrix multiplication order.
            // It's equivalent to:
            // | A' C' E' |   | A C E |   | a c e |
            // | B' D' F' | = | B D F | * | b d f |
            // | 0  0  1  |   | 0 0 1 |   | 0 0 1 |
            return new Transform2DD(
                left.A * right.A + left.C * right.B,
                left.B * right.A + left.D * right.B,
                left.A * right.C + left.C * right.D,
                left.B * right.C + left.D * right.D,
                left.A * right.E + left.C * right.F + left.E,
                left.B * right.E + left.D * right.F + left.F
            );
        }

        /// <summary>Transforms a 2D vector by a transform.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Double2 operator *(Transform2DD transform, Double2 point) => transform.TransformPoint(point);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator ==(Transform2DD left, Transform2DD right) => left.Equals(right);
        
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool operator !=(Transform2DD left, Transform2DD right) => !left.Equals(right);

        #endregion

        #region Overrides & Implementations

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Transform2DD other)
        {
            return A == other.A && B == other.B && C == other.C &&
                   D == other.D && E == other.E && F == other.F;
        }

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj) => obj is Transform2DD other && Equals(other);

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode() => HashCode.Combine(A, B, C, D, E, F);

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string ToString() => ToString(null, CultureInfo.CurrentCulture);
        
        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public string ToString(string? format, IFormatProvider? formatProvider)
        {
            return string.Format(formatProvider, "Transform2DD(Position: {0}, Rotation: {1}, Scale: {2})", 
                Position.ToString(format, formatProvider), Rotation.ToString(format, formatProvider), Scale.ToString(format, formatProvider));
        }

        #endregion
    }
}
