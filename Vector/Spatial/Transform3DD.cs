//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-10-08 21:36:15
//

// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace Prowl.Vector.Spatial
{
    /// <summary>
    /// Represents a 3D transformation matrix. Provides a rich API for manipulating
    /// position, rotation, and scale, suitable for 3D object transformations.
    /// </summary>
    public struct Transform3DD : IEquatable<Transform3DD>
    {
        /// <summary>The position of the transform in 3D space.</summary>
        public Double3 position;
        
        /// <summary>The rotation of the transform as a standard float-based quaternion.</summary>
        public Quaternion rotation;

        /// <summary>The scale of the transform.</summary>
        public Double3 scale;
        
        /// <summary>A transform with default values (position 0, no rotation, scale 1).</summary>
        public static readonly Transform3DD Identity = new Transform3DD(Double3.Zero, Quaternion.Identity, Double3.One);

        /// <summary>
        /// Initializes a new transform with specified position, rotation, and scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Transform3DD(Double3 position, Quaternion rotation, Double3 scale)
        {
            this.position = position;
            this.rotation = rotation;
            this.scale = scale;
        }

        #region High-Level Properties
        
        /// <summary>
        /// The rotation as Euler angles in degrees (order ZYXr).
        /// This is useful for inspector UIs and simple rotational adjustments.
        /// </summary>
        public Double3 eulerAngles
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => (Double3)rotation.eulerAngles;
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => rotation.eulerAngles = (Float3)value;
        }

        /// <summary>The forward direction of this transform (+Z axis in local space).</summary>
        public Double3 forward => Maths.Mul(rotation, Double3.UnitZ);

        /// <summary>The up direction of this transform (+Y axis in local space).</summary>
        public Double3 up => Maths.Mul(rotation, Double3.UnitY);

        /// <summary>The right direction of this transform (+X axis in local space).</summary>
        public Double3 right => Maths.Mul(rotation, Double3.UnitX);

        #endregion

        #region Matrix Conversions

        /// <summary>
        /// Gets the 4x4 matrix representing this transform (local to world).
        /// </summary>
        public Double4x4 ToMatrix()
        {
            return Double4x4.CreateTRS(position, rotation, scale);
        }

        /// <summary>
        /// Gets the inverse 4x4 matrix representing this transform (world to local).
        /// </summary>
        public Double4x4 ToInverseMatrix()
        {
            // Inverse TRS is inv(T) * inv(R) * inv(S)
            var invScale = new Double3(1.0 / scale.X, 1.0 / scale.Y, 1.0 / scale.Z);
            var invRot = Maths.Inverse(rotation);
            var invPos = -(Maths.Mul(invRot, position));

            return Double4x4.CreateTRS(invPos, invRot, invScale);
        }

        /// <summary>
        /// Creates a transform from a 4x4 matrix.
        /// Note: This decomposition assumes the matrix is a valid TRS matrix and does not support shear.
        /// </summary>
        public static Transform3DD FromMatrix(Double4x4 m)
        {
            Double3 scale = new Double3(
                new Double3(m.c0.X, m.c0.Y, m.c0.Z).Length,
                new Double3(m.c1.X, m.c1.Y, m.c1.Z).Length,
                new Double3(m.c2.X, m.c2.Y, m.c2.Z).Length
            );

            // Handle negative scale by flipping and adjusting rotation
            if (Maths.Determinant(m) < 0.0)
            {
                scale.X = -scale.X;
            }

            var invScale = new Double3(1.0 / scale.X, 1.0 / scale.Y, 1.0 / scale.Z);
            var rotMatrix = new Float3x3(
                (Float3)(m.c0.XYZ * invScale.X),
                (Float3)(m.c1.XYZ * invScale.Y),
                (Float3)(m.c2.XYZ * invScale.Z)
            );
            
            return new Transform3DD(m.c3.XYZ, Maths.FromMatrix(rotMatrix), scale);
        }

        #endregion

        #region Space Transformations

        /// <summary>Transforms a point from local space to world space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 TransformPoint(Double3 point)
        {
            return position + Maths.Mul(rotation, (scale * point));
        }

        /// <summary>Transforms a point from world space to local space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 InverseTransformPoint(Double3 point)
        {
            var invRot = Maths.Inverse(rotation);
            var invScale = new Double3(1.0 / scale.X, 1.0 / scale.Y, 1.0 / scale.Z);
            return invScale * Maths.Mul(invRot, (point - position));
        }

        /// <summary>Transforms a direction from local space to world space (unaffected by scale or position).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 TransformDirection(Double3 direction)
        {
            return Maths.Mul(rotation, direction);
        }

        /// <summary>Transforms a direction from world space to local space (unaffected by scale or position).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 InverseTransformDirection(Double3 direction)
        {
            return Maths.Mul(Maths.Inverse(rotation), direction);
        }

        /// <summary>Transforms a vector from local space to world space (affected by rotation and scale, but not position).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 TransformVector(Double3 vector)
        {
            return Maths.Mul(rotation, (scale * vector));
        }
        
        /// <summary>Transforms a vector from world space to local space (affected by rotation and scale, but not position).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 InverseTransformVector(Double3 vector)
        {
            var invRot = Maths.Inverse(rotation);
            var invScale = new Double3(1.0 / scale.X, 1.0 / scale.Y, 1.0 / scale.Z);
            return invScale * Maths.Mul(invRot, vector);
        }
        
        #endregion

        #region Imperative Transformations

        /// <summary>Moves the transform in the direction and distance of translation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Translate(Double3 translation, bool relativeToSelf = true)
        {
            if (relativeToSelf)
                position += Maths.Mul(rotation, translation);
            else
                position += translation;
        }

        /// <summary>Applies a rotation of eulerAngles (in degrees) around the z, x and y axes, in that order.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rotate(Double3 eulerAngles, bool relativeToSelf = true)
        {
            Rotate(Quaternion.FromEuler((Float3)eulerAngles), relativeToSelf);
        }

        /// <summary>Applies a rotation of angle (in degrees) around an axis.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rotate(Quaternion rot, bool relativeToSelf = true)
        {
            if (relativeToSelf)
                rotation = Maths.Mul(rotation, rot);
            else
                rotation = Maths.Mul(rot, rotation);
        }

        /// <summary>Rotates the transform around a point in world space.</summary>
        /// <param name="point">The world-space point to rotate around.</param>
        /// <param name="axis">The axis to rotate around.</param>
        /// <param name="angleDegrees">The angle in degrees.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RotateAround(Double3 point, Double3 axis, double angleDegrees)
        {
            var rot = Maths.AxisAngle((Float3)axis.Normalized, (float)(angleDegrees * Maths.Deg2Rad));
            var vector = position - point;
            vector = (Double3)(Maths.Mul(rot, (Float3)vector));
            position = point + vector;
            rotation = Maths.Mul(rot, rotation);
        }
        
        /// <summary>
        /// Rotates the transform so the forward vector points at the target's current position.
        /// </summary>
        /// <param name="target">The target position to look at.</param>
        /// <param name="worldUp">The vector that defines "up" in world space.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LookAt(Double3 target, Double3 worldUp)
        {
            rotation = Maths.LookRotation((Float3)(target - position), (Float3)worldUp);
        }

        #endregion

        #region Public Methods

        /// <summary>Linearly interpolates between two transforms.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform3DD Lerp(Transform3DD a, Transform3DD b, double t)
        {
            t = Maths.Clamp(t, 0.0, 1.0);
            return new Transform3DD(
                Maths.Lerp(a.position, b.position, t),
                Maths.Nlerp(a.rotation, b.rotation, (float)t),
                Maths.Lerp(a.scale, b.scale, t)
            );
        }

        #endregion
        
        #region Overrides

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Transform3DD other)
        {
            return position.Equals(other.position) &&
                   rotation.Equals(other.rotation) &&
                   scale.Equals(other.scale);
        }

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is Transform3DD other && Equals(other);
        }

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode()
        {
            return HashCode.Combine(position, rotation, scale);
        }
        
        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string ToString()
        {
            return $"Transform3DD(Position: {position}, Rotation: {rotation}, Scale: {scale})";
        }

        public static bool operator ==(Transform3DD left, Transform3DD right) => left.Equals(right);
        public static bool operator !=(Transform3DD left, Transform3DD right) => !left.Equals(right);
        
        #endregion
    }
}
