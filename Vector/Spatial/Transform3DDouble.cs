//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-06-11 13:05:30
//

// This file is part of the Prowl Game Engine
// Licensed under the MIT License. See the LICENSE file in the project root for details.

using System;
using System.Globalization;
using System.Runtime.CompilerServices;

namespace Prowl.Vector.Spatial
{
    /// <summary>
    /// Represents a 3D transformation matrix. Provides a rich API for manipulating
    /// position, rotation, and scale, suitable for 3D object transformations.
    /// </summary>
    public struct Transform3DDouble : IEquatable<Transform3DDouble>
    {
        /// <summary>The position of the transform in 3D space.</summary>
        public Double3 position;

        /// <summary>The rotation of the transform as a quaternion.</summary>
        public QuaternionDouble rotation;

        /// <summary>The scale of the transform.</summary>
        public Double3 scale;

        /// <summary>A transform with default values (position 0, no rotation, scale 1).</summary>
        public static readonly Transform3DDouble Identity = new(Double3.Zero, QuaternionDouble.Identity, Double3.One);

        /// <summary>
        /// Initializes a new transform with specified position, rotation, and scale.
        /// </summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Transform3DDouble(Double3 position, QuaternionDouble rotation, Double3 scale)
        {
            this.position = position;
            this.rotation = rotation;
            this.scale = scale;
        }

        #region High-Level Properties

        /// <summary>
        /// The rotation as Euler angles in degrees (order ZYXr).
        /// This is useful for inspector UIs and simple rotational adjustments.
        /// </summary>
        public Double3 eulerAngles
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get => rotation.ToEulerDegrees(EulerOrder.ZYXr);
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set => rotation = QuaternionDouble.FromEulerDegrees(value, EulerOrder.ZYXr);
        }

        /// <summary>The forward direction of this transform (+Z axis in local space).</summary>
        public Double3 forward => rotation * Double3.UnitZ;

        /// <summary>The up direction of this transform (+Y axis in local space).</summary>
        public Double3 up => rotation * Double3.UnitY;

        /// <summary>The right direction of this transform (+X axis in local space).</summary>
        public Double3 right => rotation * Double3.UnitX;

        #endregion

        #region Matrix Conversions

        /// <summary>
        /// Gets the 4x4 matrix representing this transform (local to world).
        /// </summary>
        public Double4x4 ToMatrix()
        {
            return Double4x4.CreateTRS(position, rotation, scale);
        }

        /// <summary>
        /// Gets the inverse 4x4 matrix representing this transform (world to local).
        /// </summary>
        public Double4x4 ToInverseMatrix()
        {
            // Inverse TRS is inv(T) * inv(R) * inv(S)
            var invScale = new Double3(1.0 / scale.X, 1.0 / scale.Y, 1.0 / scale.Z);
            var invRot = rotation.Inverse();
            var invPos = -(invRot * position);

            return Double4x4.CreateTRS(invPos, invRot, invScale);
        }

        /// <summary>
        /// Creates a transform from a 4x4 matrix.
        /// Note: This decomposition assumes the matrix is a valid TRS matrix and does not support shear.
        /// </summary>
        public static Transform3DDouble FromMatrix(Double4x4 m)
        {
            Double3 scale = new Double3(
                new Double3(m.c0.X, m.c0.Y, m.c0.Z).Length,
                new Double3(m.c1.X, m.c1.Y, m.c1.Z).Length,
                new Double3(m.c2.X, m.c2.Y, m.c2.Z).Length
            );

            // Handle negative scale by flipping and adjusting rotation
            if (m.Determinant() < 0.0)
            {
                scale.X = -scale.X;
            }

            var invScale = new Double3(1.0 / scale.X, 1.0 / scale.Y, 1.0 / scale.Z);
            var rotMatrix = new Double3x3(
                m.c0.XYZ * invScale.X,
                m.c1.XYZ * invScale.Y,
                m.c2.XYZ * invScale.Z
            );
            
            return new Transform3DDouble(m.c3.XYZ, Maths.FromMatrix(rotMatrix), scale);
        }

        #endregion

        #region Space Transformations

        /// <summary>Transforms a point from local space to world space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 TransformPoint(Double3 point)
        {
            return position + rotation * (scale * point);
        }

        /// <summary>Transforms a point from world space to local space.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 InverseTransformPoint(Double3 point)
        {
            var invRot = rotation.Inverse();
            var invScale = new Double3(1.0 / scale.X, 1.0 / scale.Y, 1.0 / scale.Z);
            return invScale * (invRot * (point - position));
        }

        /// <summary>Transforms a direction from local space to world space (unaffected by scale or position).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 TransformDirection(Double3 direction)
        {
            return rotation * direction;
        }

        /// <summary>Transforms a direction from world space to local space (unaffected by scale or position).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 InverseTransformDirection(Double3 direction)
        {
            return rotation.Inverse() * direction;
        }

        /// <summary>Transforms a vector from local space to world space (affected by rotation and scale, but not position).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 TransformVector(Double3 vector)
        {
            return rotation * (scale * vector);
        }
        
        /// <summary>Transforms a vector from world space to local space (affected by rotation and scale, but not position).</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Double3 InverseTransformVector(Double3 vector)
        {
            var invRot = rotation.Inverse();
            var invScale = new Double3(1.0 / scale.X, 1.0 / scale.Y, 1.0 / scale.Z);
            return invScale * (invRot * vector);
        }
        
        #endregion

        #region Imperative Transformations

        /// <summary>Moves the transform in the direction and distance of translation.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Translate(Double3 translation, bool relativeToSelf = true)
        {
            if (relativeToSelf)
                position += rotation * translation;
            else
                position += translation;
        }

        /// <summary>Applies a rotation of eulerAngles (in degrees) around the z, x and y axes, in that order.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rotate(Double3 eulerAngles, bool relativeToSelf = true)
        {
            Rotate(QuaternionDouble.FromEulerDegrees(eulerAngles, EulerOrder.ZYXr), relativeToSelf);
        }

        /// <summary>Applies a rotation of angle (in degrees) around an axis.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void Rotate(QuaternionDouble rot, bool relativeToSelf = true)
        {
            if (relativeToSelf)
                rotation = rotation * rot;
            else
                rotation = rot * rotation;
        }

        /// <summary>Rotates the transform around a point in world space.</summary>
        /// <param name="point">The world-space point to rotate around.</param>
        /// <param name="axis">The axis to rotate around.</param>
        /// <param name="angleDegrees">The angle in degrees.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void RotateAround(Double3 point, Double3 axis, double angleDegrees)
        {
            var rot = QuaternionDouble.AxisAngle(axis.Normalized, angleDegrees * (double)Maths.Deg2Rad);
            var vector = position - point;
            vector = rot * vector;
            position = point + vector;
            rotation = rot * rotation;
        }
        
        /// <summary>
        /// Rotates the transform so the forward vector points at the target's current position.
        /// </summary>
        /// <param name="target">The target position to look at.</param>
        /// <param name="worldUp">The vector that defines "up" in world space.</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void LookAt(Double3 target, Double3 worldUp)
        {
            rotation = QuaternionDouble.LookRotationSafe(target - position, worldUp);
        }

        #endregion

        #region Public Methods

        /// <summary>Linearly interpolates between two transforms.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Transform3DDouble Lerp(Transform3DDouble a, Transform3DDouble b, double t)
        {
            t = Maths.Clamp(t, 0.0, 1.0);
            return new Transform3DDouble(
                Maths.Lerp(a.position, b.position, t),
                QuaternionDouble.Nlerp(a.rotation, b.rotation, t),
                Maths.Lerp(a.scale, b.scale, t)
            );
        }

        #endregion
        
        #region Overrides

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Transform3DDouble other)
        {
            return position.Equals(other.position) &&
                   rotation.Equals(other.rotation) &&
                   scale.Equals(other.scale);
        }

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override bool Equals(object? obj)
        {
            return obj is Transform3DDouble other && Equals(other);
        }

        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override int GetHashCode()
        {
            return HashCode.Combine(position, rotation, scale);
        }
        
        /// <inheritdoc/>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public override string ToString()
        {
            return $"Transform3DDouble(Position: {position}, Rotation: {rotation}, Scale: {scale})";
        }

        public static bool operator ==(Transform3DDouble left, Transform3DDouble right) => left.Equals(right);
        public static bool operator !=(Transform3DDouble left, Transform3DDouble right) => !left.Equals(right);
        
        #endregion
    }
}
