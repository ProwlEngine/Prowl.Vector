//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-05-14 10:54:52
//

using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Linq;

namespace Prowl.Vector
{
    /// <summary>
    /// Represents a 2-component vector using bool precision.
    /// </summary>
    [System.Serializable]
    public partial struct Bool2 : IEquatable<Bool2>, IFormattable
    {
        public bool X, Y;

        // --- Constructors ---
        /// <summary>Initializes all components to a single scalar value.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bool2(bool scalar) : this(scalar, scalar) { }

        /// <summary>Initializes with specified component values.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bool2(bool x, bool y)
        {
            X = x;
            Y = y;
        }

        /// <summary>Initializes by copying components from another Bool2.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bool2(Bool2 v) : this(v.X, v.Y) { }

        /// <summary>Initializes from an array.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bool2(bool[] array)
        {
            if (array == null) throw new ArgumentNullException(nameof(array));
            if (array.Length < 2) throw new ArgumentException("Array must contain at least 2 elements.", nameof(array));
            X = array[0];
            Y = array[1];
        }

        // --- Collection Constructors ---
        /// <summary>Initializes from an IEnumerable collection.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bool2(IEnumerable<bool> values)
        {
            var array = values.ToArray();
            if (array.Length < 2) throw new ArgumentException("Collection must contain at least 2 elements.", nameof(values));
            X = array[0];
            Y = array[1];
        }

        /// <summary>Initializes from a ReadOnlySpan.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bool2(ReadOnlySpan<bool> span)
        {
            if (span.Length < 2) throw new ArgumentException("Span must contain at least 2 elements.", nameof(span));
            X = span[0];
            Y = span[1];
        }

        /// <summary>Initializes from a Span.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public Bool2(Span<bool> span)
        {
            if (span.Length < 2) throw new ArgumentException("Span must contain at least 2 elements.", nameof(span));
            X = span[0];
            Y = span[1];
        }

        // --- Static Properties ---
        /// <summary>Gets the zero vector.</summary>
        public static Bool2 Zero { get { return new Bool2(false, false); } }
        /// <summary>Gets the one vector.</summary>
        public static Bool2 One { get { return new Bool2(true, true); } }
        /// <summary>Gets the unit vector along the X-axis.</summary>
        public static Bool2 UnitX { get { return new Bool2(true, false); } }
        /// <summary>Gets the unit vector along the Y-axis.</summary>
        public static Bool2 UnitY { get { return new Bool2(false, true); } }

        // --- Indexer ---
        /// <summary>Gets or sets the component at the specified index.</summary>
        public bool this[int index]
        {
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            get
            {
                switch (index)
                {
                    case 0: return X;
                    case 1: return Y;
                    default: throw new IndexOutOfRangeException(string.Format("Index must be between 0 and 1, but was {0}", index));
                }
            }
            [MethodImpl(MethodImplOptions.AggressiveInlining)]
            set
            {
                switch (index)
                {
                    case 0: X = value; break;
                    case 1: Y = value; break;
                    default: throw new IndexOutOfRangeException(string.Format("Index must be between 0 and 1, but was {0}", index));
                }
            }
        }

        // --- Vector-to-Vector Operators ---
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bool2 operator &(Bool2 a, Bool2 b) { return new Bool2(a.X && b.X, a.Y && b.Y); }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bool2 operator |(Bool2 a, Bool2 b) { return new Bool2(a.X || b.X, a.Y || b.Y); }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bool2 operator ^(Bool2 a, Bool2 b) { return new Bool2(a.X ^ b.X, a.Y ^ b.Y); }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Bool2 operator !(Bool2 v) { return new Bool2(!v.X, !v.Y); }

        // --- Methods ---
        /// <summary>Returns true if any component is true.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Any() { return X || Y; }

        /// <summary>Returns true if all components are true.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool All() { return X && Y; }

        /// <summary>Returns true if all components are false.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool None() { return !X && !Y; }

        /// <summary>Returns an array of components.</summary>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool[] ToArray() { return new bool[] { X, Y }; }
        /// <summary>Returns an array of components.</summary>
        public override bool Equals(object obj) { return obj is Bool2 && Equals((Bool2)obj); }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public bool Equals(Bool2 other) { return X == other.X && Y == other.Y; }

        public override int GetHashCode() { return X.GetHashCode() ^ (Y.GetHashCode() << 2); }

        public override string ToString()
        {
            return ToString(CultureInfo.CurrentCulture);
        }

        public string ToString(IFormatProvider formatProvider)
        {
            string separator = (formatProvider is CultureInfo) ? ((CultureInfo)formatProvider).TextInfo.ListSeparator : ", ";
            return "(" + X.ToString() + separator + Y.ToString() + ")";
        }

        public string ToString(string format) { return ToString(CultureInfo.CurrentCulture); }

        public string ToString(string format, IFormatProvider formatProvider)
        {
            // Format is ignored for boolean vectors
            return ToString(formatProvider);
        }
    }
}
