//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-07-02 18:02:04
//

using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Linq;

namespace Prowl.Vector
{

/// <summary>
/// Represents a 4-component vector using bool precision.
/// </summary>
[System.Serializable]
public partial struct Bool4 : IEquatable<Bool4>, IFormattable
{
	public bool X, Y, Z, W;

	// --- Constructors ---
	/// <summary>Initializes all components to a single scalar value.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(bool scalar) : this(scalar, scalar, scalar, scalar) { }

	/// <summary>Initializes with specified component values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(bool x, bool y, bool z, bool w)
	{
		X = x;
		Y = y;
		Z = z;
		W = w;
	}

	/// <summary>Initializes by copying components from another Bool4.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(Bool4 v) : this(v.X, v.Y, v.Z, v.W) { }

	/// <summary>Initializes from an array.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(bool[] array)
	{
		if (array == null) throw new ArgumentNullException(nameof(array));
		if (array.Length < 4) throw new ArgumentException("Array must contain at least 4 elements.", nameof(array));
		X = array[0];
		Y = array[1];
		Z = array[2];
		W = array[3];
	}

	/// <summary>Initializes from a Bool2 and Z, W components.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(Bool2 xy, bool z, bool w) : this(xy.X, xy.Y, z, w) { }

	/// <summary>Initializes from X component, a Bool2, and W component.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(bool x, Bool2 yz, bool w) : this(x, yz.X, yz.Y, w) { }

	/// <summary>Initializes from X, Y components and a Bool2.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(bool x, bool y, Bool2 zw) : this(x, y, zw.X, zw.Y) { }

	/// <summary>Initializes from two Bool2 vectors.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(Bool2 xy, Bool2 zw) : this(xy.X, xy.Y, zw.X, zw.Y) { }

	/// <summary>Initializes from a Bool3 and W component.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(Bool3 xyz, bool w) : this(xyz.X, xyz.Y, xyz.Z, w) { }

	/// <summary>Initializes from X component and a Bool3.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(bool x, Bool3 yzw) : this(x, yzw.X, yzw.Y, yzw.Z) { }

	// --- Collection Constructors ---
	/// <summary>Initializes from an IEnumerable collection.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(IEnumerable<bool> values)
	{
		var array = values.ToArray();
		if (array.Length < 4) throw new ArgumentException("Collection must contain at least 4 elements.", nameof(values));
		X = array[0];
		Y = array[1];
		Z = array[2];
		W = array[3];
	}

	/// <summary>Initializes from a ReadOnlySpan.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(ReadOnlySpan<bool> span)
	{
		if (span.Length < 4) throw new ArgumentException("Span must contain at least 4 elements.", nameof(span));
		X = span[0];
		Y = span[1];
		Z = span[2];
		W = span[3];
	}

	/// <summary>Initializes from a Span.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool4(Span<bool> span)
	{
		if (span.Length < 4) throw new ArgumentException("Span must contain at least 4 elements.", nameof(span));
		X = span[0];
		Y = span[1];
		Z = span[2];
		W = span[3];
	}

	// --- Static Properties ---
	/// <summary>Gets the zero vector.</summary>
	public static Bool4 Zero { get { return new Bool4(false, false, false, false); } }
	/// <summary>Gets the one vector.</summary>
	public static Bool4 One { get { return new Bool4(true, true, true, true); } }
	/// <summary>Gets the unit vector along the X-axis.</summary>
	public static Bool4 UnitX { get { return new Bool4(true, false, false, false); } }
	/// <summary>Gets the unit vector along the Y-axis.</summary>
	public static Bool4 UnitY { get { return new Bool4(false, true, false, false); } }
	/// <summary>Gets the unit vector along the Z-axis.</summary>
	public static Bool4 UnitZ { get { return new Bool4(false, false, true, false); } }
	/// <summary>Gets the unit vector along the W-axis.</summary>
	public static Bool4 UnitW { get { return new Bool4(false, false, false, true); } }

	// --- Indexer ---
	/// <summary>Gets or sets the component at the specified index.</summary>
	public bool this[int index]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			switch (index)
			{
				case 0: return X;
				case 1: return Y;
				case 2: return Z;
				case 3: return W;
				default: throw new IndexOutOfRangeException(string.Format("Index must be between 0 and 3, but was {0}", index));
			}
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			switch (index)
			{
				case 0: X = value; break;
				case 1: Y = value; break;
				case 2: Z = value; break;
				case 3: W = value; break;
				default: throw new IndexOutOfRangeException(string.Format("Index must be between 0 and 3, but was {0}", index));
			}
		}
	}

	// --- Vector-to-Vector Operators ---
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4 operator &(Bool4 a, Bool4 b) { return new Bool4(a.X && b.X, a.Y && b.Y, a.Z && b.Z, a.W && b.W); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4 operator |(Bool4 a, Bool4 b) { return new Bool4(a.X || b.X, a.Y || b.Y, a.Z || b.Z, a.W || b.W); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4 operator ^(Bool4 a, Bool4 b) { return new Bool4(a.X ^ b.X, a.Y ^ b.Y, a.Z ^ b.Z, a.W ^ b.W); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool4 operator !(Bool4 v) { return new Bool4(!v.X, !v.Y, !v.Z, !v.W); }

	// --- Equality Operators (Return Single Bool) ---
	/// <summary>Returns true if all components of both vectors are equal.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator ==(Bool4 lhs, Bool4 rhs) { return lhs.X == rhs.X && lhs.Y == rhs.Y && lhs.Z == rhs.Z && lhs.W == rhs.W; }

	/// <summary>Returns true if any component of the vectors are not equal.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static bool operator !=(Bool4 lhs, Bool4 rhs) { return !(lhs == rhs); }

	// --- Methods ---
	/// <summary>Returns true if any component is true.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Any() { return X || Y || Z || W; }

	/// <summary>Returns true if all components are true.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool All() { return X && Y && Z && W; }

	/// <summary>Returns true if all components are false.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool None() { return !X && !Y && !Z && !W; }

	/// <summary>Returns an array of components.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool[] ToArray() { return new bool[] { X, Y, Z, W }; }
	/// <summary>Returns an array of components.</summary>
	public override bool Equals(object? obj) { return obj is Bool4 && Equals((Bool4)obj); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Equals(Bool4 other) { return X == other.X && Y == other.Y && Z == other.Z && W == other.W; }

	public override int GetHashCode() { return X.GetHashCode() ^ (Y.GetHashCode() << 2) ^ (Z.GetHashCode() >> 2) ^ (W.GetHashCode() >> 1); }

	public override string ToString()
	{
		return ToString(CultureInfo.CurrentCulture);
	}

	public string ToString(IFormatProvider formatProvider)
	{
		string separator = (formatProvider is CultureInfo) ? ((CultureInfo)formatProvider).TextInfo.ListSeparator : ", ";
		return "(" + X.ToString() + separator + Y.ToString() + separator + Z.ToString() + separator + W.ToString() + ")";
	}

	public string ToString(string format) { return ToString(CultureInfo.CurrentCulture); }

	public string ToString(string format, IFormatProvider formatProvider)
	{
		// Format is ignored for boolean vectors
		return ToString(formatProvider);
	}
}
}
