//
// THIS FILE IS AUTO-GENERATED
//
// Do not modify this file directly. All changes will be lost when the code is regenerated.
// To make changes to this vector type, modify the SourceGenerator project and regenerate the code.
//
// Generated by: Prowl.Vector's SourceGenerator Console Application
// Date: 2025-06-11 14:12:57
//

using System;
using System.Globalization;
using System.Runtime.CompilerServices;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;

namespace Prowl.Vector
{

/// <summary>
/// Represents a 2-component vector using float precision.
/// </summary>
[System.Serializable]
public partial struct Float2 : IEquatable<Float2>, IFormattable
{
	public float X, Y;

	// --- Constructors ---
	/// <summary>Initializes all components to a single scalar value.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(float scalar) : this(scalar, scalar) { }

	/// <summary>Initializes with specified component values.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(float x, float y)
	{
		X = x;
		Y = y;
	}

	/// <summary>Initializes by copying components from another Float2.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(Float2 v) : this(v.X, v.Y) { }

	/// <summary>Initializes from an array.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(float[] array)
	{
		if (array == null) throw new ArgumentNullException(nameof(array));
		if (array.Length < 2) throw new ArgumentException("Array must contain at least 2 elements.", nameof(array));
		X = array[0];
		Y = array[1];
	}

	// --- Type Conversion Constructors ---
	/// <summary>Initializes from a Double2 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(Double2 v) : this((float)v.X, (float)v.Y) { }

	/// <summary>Initializes from a Int2 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(Int2 v) : this((float)v.X, (float)v.Y) { }

	/// <summary>Initializes from a Byte2 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(Byte2 v) : this((float)v.X, (float)v.Y) { }

	/// <summary>Initializes from a UShort2 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(UShort2 v) : this((float)v.X, (float)v.Y) { }

	/// <summary>Initializes from a UInt2 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(UInt2 v) : this((float)v.X, (float)v.Y) { }

	/// <summary>Initializes from a ULong2 with type conversion.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(ULong2 v) : this((float)v.X, (float)v.Y) { }

	// --- Collection Constructors ---
	/// <summary>Initializes from an IEnumerable collection.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(IEnumerable<float> values)
	{
		var array = values.ToArray();
		if (array.Length < 2) throw new ArgumentException("Collection must contain at least 2 elements.", nameof(values));
		X = array[0];
		Y = array[1];
	}

	/// <summary>Initializes from a ReadOnlySpan.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(ReadOnlySpan<float> span)
	{
		if (span.Length < 2) throw new ArgumentException("Span must contain at least 2 elements.", nameof(span));
		X = span[0];
		Y = span[1];
	}

	/// <summary>Initializes from a Span.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Float2(Span<float> span)
	{
		if (span.Length < 2) throw new ArgumentException("Span must contain at least 2 elements.", nameof(span));
		X = span[0];
		Y = span[1];
	}

	// --- Static Properties ---
	/// <summary>Gets the zero vector.</summary>
	public static Float2 Zero { get { return new Float2(0f, 0f); } }
	/// <summary>Gets the one vector.</summary>
	public static Float2 One { get { return new Float2(1f, 1f); } }
	/// <summary>Gets the unit vector along the X-axis.</summary>
	public static Float2 UnitX { get { return new Float2(1f, 0f); } }
	/// <summary>Gets the unit vector along the Y-axis.</summary>
	public static Float2 UnitY { get { return new Float2(0f, 1f); } }

	// --- Properties ---
	/// <summary>Gets the magnitude (length) of the vector.</summary>
	public float Length
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get { return MathF.Sqrt(LengthSquared); }
	}

	/// <summary>Gets the squared magnitude (length) of the vector.</summary>
	public float LengthSquared
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get { return X * X + Y * Y; }
	}

	/// <summary>Gets a normalized version of this vector.</summary>
	public Float2 Normalized
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			float lenSq = LengthSquared;
			if (lenSq <= float.Epsilon * float.Epsilon)
			{
				return Zero;
			}
			float invLength = 1f / MathF.Sqrt(lenSq);
			return new Float2(X * invLength, Y * invLength);
		}
	}

	// --- Indexer ---
	/// <summary>Gets or sets the component at the specified index.</summary>
	public float this[int index]
	{
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		get
		{
			switch (index)
			{
				case 0: return X;
				case 1: return Y;
				default: throw new IndexOutOfRangeException(string.Format("Index must be between 0 and 1, but was {0}", index));
			}
		}
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		set
		{
			switch (index)
			{
				case 0: X = value; break;
				case 1: Y = value; break;
				default: throw new IndexOutOfRangeException(string.Format("Index must be between 0 and 1, but was {0}", index));
			}
		}
	}

	// --- Vector-to-Vector Operators ---
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(Float2 a, Float2 b) { return new Float2(a.X + b.X, a.Y + b.Y); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(Float2 a, Float2 b) { return new Float2(a.X - b.X, a.Y - b.Y); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(Float2 a, Float2 b) { return new Float2(a.X * b.X, a.Y * b.Y); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(Float2 a, Float2 b) { return new Float2(a.X / b.X, a.Y / b.Y); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(Float2 a, Float2 b) { return new Float2(a.X % b.X, a.Y % b.Y); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(Float2 v) { return new Float2(-v.X, -v.Y); }

	// --- Scalar-Vector Operators ---
	/// <summary>float + Float2 operator. Vector components are (scalar + v.X, scalar + v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(float scalar, Float2 v)
	{
		return new Float2((float)(scalar + v.X), (float)(scalar + v.Y));
	}

	/// <summary>Float2 + float operator. Vector components are (v.X + scalar, v.Y + scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(Float2 v, float scalar)
	{
		return new Float2((float)(v.X + scalar), (float)(v.Y + scalar));
	}

	/// <summary>float - Float2 operator. Vector components are (scalar - v.X, scalar - v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(float scalar, Float2 v)
	{
		return new Float2((float)(scalar - v.X), (float)(scalar - v.Y));
	}

	/// <summary>Float2 - float operator. Vector components are (v.X - scalar, v.Y - scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(Float2 v, float scalar)
	{
		return new Float2((float)(v.X - scalar), (float)(v.Y - scalar));
	}

	/// <summary>float * Float2 operator. Vector components are (scalar * v.X, scalar * v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(float scalar, Float2 v)
	{
		return new Float2((float)(scalar * v.X), (float)(scalar * v.Y));
	}

	/// <summary>Float2 * float operator. Vector components are (v.X * scalar, v.Y * scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(Float2 v, float scalar)
	{
		return new Float2((float)(v.X * scalar), (float)(v.Y * scalar));
	}

	/// <summary>float / Float2 operator. Vector components are (v.X / scalar, v.Y / scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(Float2 v, float scalar)
	{
		return new Float2((float)(v.X / scalar), (float)(v.Y / scalar));
	}

	/// <summary>float / Float2 operator. Vector components are (scalar / v.X, scalar / v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(float scalar, Float2 v)
	{
		return new Float2((float)(scalar / v.X), (float)(scalar / v.Y));
	}

	/// <summary>Float2 % float operator. Vector components are (v.X % scalar, v.Y % scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(Float2 v, float scalar)
	{
		return new Float2((float)(v.X % scalar), (float)(v.Y % scalar));
	}

	/// <summary>float % Float2 operator. Vector components are (scalar % v.X, scalar % v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(float scalar, Float2 v)
	{
		return new Float2((float)(scalar % v.X), (float)(scalar % v.Y));
	}

	/// <summary>double + Float2 operator. Vector components are (scalar + v.X, scalar + v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(double scalar, Float2 v)
	{
		return new Float2((float)(scalar + v.X), (float)(scalar + v.Y));
	}

	/// <summary>Float2 + double operator. Vector components are (v.X + scalar, v.Y + scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(Float2 v, double scalar)
	{
		return new Float2((float)(v.X + scalar), (float)(v.Y + scalar));
	}

	/// <summary>double - Float2 operator. Vector components are (scalar - v.X, scalar - v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(double scalar, Float2 v)
	{
		return new Float2((float)(scalar - v.X), (float)(scalar - v.Y));
	}

	/// <summary>Float2 - double operator. Vector components are (v.X - scalar, v.Y - scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(Float2 v, double scalar)
	{
		return new Float2((float)(v.X - scalar), (float)(v.Y - scalar));
	}

	/// <summary>double * Float2 operator. Vector components are (scalar * v.X, scalar * v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(double scalar, Float2 v)
	{
		return new Float2((float)(scalar * v.X), (float)(scalar * v.Y));
	}

	/// <summary>Float2 * double operator. Vector components are (v.X * scalar, v.Y * scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(Float2 v, double scalar)
	{
		return new Float2((float)(v.X * scalar), (float)(v.Y * scalar));
	}

	/// <summary>double / Float2 operator. Vector components are (v.X / scalar, v.Y / scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(Float2 v, double scalar)
	{
		return new Float2((float)(v.X / scalar), (float)(v.Y / scalar));
	}

	/// <summary>double / Float2 operator. Vector components are (scalar / v.X, scalar / v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(double scalar, Float2 v)
	{
		return new Float2((float)(scalar / v.X), (float)(scalar / v.Y));
	}

	/// <summary>Float2 % double operator. Vector components are (v.X % scalar, v.Y % scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(Float2 v, double scalar)
	{
		return new Float2((float)(v.X % scalar), (float)(v.Y % scalar));
	}

	/// <summary>double % Float2 operator. Vector components are (scalar % v.X, scalar % v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(double scalar, Float2 v)
	{
		return new Float2((float)(scalar % v.X), (float)(scalar % v.Y));
	}

	/// <summary>int + Float2 operator. Vector components are (scalar + v.X, scalar + v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(int scalar, Float2 v)
	{
		return new Float2((float)(scalar + v.X), (float)(scalar + v.Y));
	}

	/// <summary>Float2 + int operator. Vector components are (v.X + scalar, v.Y + scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(Float2 v, int scalar)
	{
		return new Float2((float)(v.X + scalar), (float)(v.Y + scalar));
	}

	/// <summary>int - Float2 operator. Vector components are (scalar - v.X, scalar - v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(int scalar, Float2 v)
	{
		return new Float2((float)(scalar - v.X), (float)(scalar - v.Y));
	}

	/// <summary>Float2 - int operator. Vector components are (v.X - scalar, v.Y - scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(Float2 v, int scalar)
	{
		return new Float2((float)(v.X - scalar), (float)(v.Y - scalar));
	}

	/// <summary>int * Float2 operator. Vector components are (scalar * v.X, scalar * v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(int scalar, Float2 v)
	{
		return new Float2((float)(scalar * v.X), (float)(scalar * v.Y));
	}

	/// <summary>Float2 * int operator. Vector components are (v.X * scalar, v.Y * scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(Float2 v, int scalar)
	{
		return new Float2((float)(v.X * scalar), (float)(v.Y * scalar));
	}

	/// <summary>int / Float2 operator. Vector components are (v.X / scalar, v.Y / scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(Float2 v, int scalar)
	{
		return new Float2((float)(v.X / scalar), (float)(v.Y / scalar));
	}

	/// <summary>int / Float2 operator. Vector components are (scalar / v.X, scalar / v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(int scalar, Float2 v)
	{
		return new Float2((float)(scalar / v.X), (float)(scalar / v.Y));
	}

	/// <summary>Float2 % int operator. Vector components are (v.X % scalar, v.Y % scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(Float2 v, int scalar)
	{
		return new Float2((float)(v.X % scalar), (float)(v.Y % scalar));
	}

	/// <summary>int % Float2 operator. Vector components are (scalar % v.X, scalar % v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(int scalar, Float2 v)
	{
		return new Float2((float)(scalar % v.X), (float)(scalar % v.Y));
	}

	/// <summary>byte + Float2 operator. Vector components are (scalar + v.X, scalar + v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(byte scalar, Float2 v)
	{
		return new Float2((float)(scalar + v.X), (float)(scalar + v.Y));
	}

	/// <summary>Float2 + byte operator. Vector components are (v.X + scalar, v.Y + scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(Float2 v, byte scalar)
	{
		return new Float2((float)(v.X + scalar), (float)(v.Y + scalar));
	}

	/// <summary>byte - Float2 operator. Vector components are (scalar - v.X, scalar - v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(byte scalar, Float2 v)
	{
		return new Float2((float)(scalar - v.X), (float)(scalar - v.Y));
	}

	/// <summary>Float2 - byte operator. Vector components are (v.X - scalar, v.Y - scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(Float2 v, byte scalar)
	{
		return new Float2((float)(v.X - scalar), (float)(v.Y - scalar));
	}

	/// <summary>byte * Float2 operator. Vector components are (scalar * v.X, scalar * v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(byte scalar, Float2 v)
	{
		return new Float2((float)(scalar * v.X), (float)(scalar * v.Y));
	}

	/// <summary>Float2 * byte operator. Vector components are (v.X * scalar, v.Y * scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(Float2 v, byte scalar)
	{
		return new Float2((float)(v.X * scalar), (float)(v.Y * scalar));
	}

	/// <summary>byte / Float2 operator. Vector components are (v.X / scalar, v.Y / scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(Float2 v, byte scalar)
	{
		return new Float2((float)(v.X / scalar), (float)(v.Y / scalar));
	}

	/// <summary>byte / Float2 operator. Vector components are (scalar / v.X, scalar / v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(byte scalar, Float2 v)
	{
		return new Float2((float)(scalar / v.X), (float)(scalar / v.Y));
	}

	/// <summary>Float2 % byte operator. Vector components are (v.X % scalar, v.Y % scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(Float2 v, byte scalar)
	{
		return new Float2((float)(v.X % scalar), (float)(v.Y % scalar));
	}

	/// <summary>byte % Float2 operator. Vector components are (scalar % v.X, scalar % v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(byte scalar, Float2 v)
	{
		return new Float2((float)(scalar % v.X), (float)(scalar % v.Y));
	}

	/// <summary>ushort + Float2 operator. Vector components are (scalar + v.X, scalar + v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(ushort scalar, Float2 v)
	{
		return new Float2((float)(scalar + v.X), (float)(scalar + v.Y));
	}

	/// <summary>Float2 + ushort operator. Vector components are (v.X + scalar, v.Y + scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(Float2 v, ushort scalar)
	{
		return new Float2((float)(v.X + scalar), (float)(v.Y + scalar));
	}

	/// <summary>ushort - Float2 operator. Vector components are (scalar - v.X, scalar - v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(ushort scalar, Float2 v)
	{
		return new Float2((float)(scalar - v.X), (float)(scalar - v.Y));
	}

	/// <summary>Float2 - ushort operator. Vector components are (v.X - scalar, v.Y - scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(Float2 v, ushort scalar)
	{
		return new Float2((float)(v.X - scalar), (float)(v.Y - scalar));
	}

	/// <summary>ushort * Float2 operator. Vector components are (scalar * v.X, scalar * v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(ushort scalar, Float2 v)
	{
		return new Float2((float)(scalar * v.X), (float)(scalar * v.Y));
	}

	/// <summary>Float2 * ushort operator. Vector components are (v.X * scalar, v.Y * scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(Float2 v, ushort scalar)
	{
		return new Float2((float)(v.X * scalar), (float)(v.Y * scalar));
	}

	/// <summary>ushort / Float2 operator. Vector components are (v.X / scalar, v.Y / scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(Float2 v, ushort scalar)
	{
		return new Float2((float)(v.X / scalar), (float)(v.Y / scalar));
	}

	/// <summary>ushort / Float2 operator. Vector components are (scalar / v.X, scalar / v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(ushort scalar, Float2 v)
	{
		return new Float2((float)(scalar / v.X), (float)(scalar / v.Y));
	}

	/// <summary>Float2 % ushort operator. Vector components are (v.X % scalar, v.Y % scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(Float2 v, ushort scalar)
	{
		return new Float2((float)(v.X % scalar), (float)(v.Y % scalar));
	}

	/// <summary>ushort % Float2 operator. Vector components are (scalar % v.X, scalar % v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(ushort scalar, Float2 v)
	{
		return new Float2((float)(scalar % v.X), (float)(scalar % v.Y));
	}

	/// <summary>uint + Float2 operator. Vector components are (scalar + v.X, scalar + v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(uint scalar, Float2 v)
	{
		return new Float2((float)(scalar + v.X), (float)(scalar + v.Y));
	}

	/// <summary>Float2 + uint operator. Vector components are (v.X + scalar, v.Y + scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(Float2 v, uint scalar)
	{
		return new Float2((float)(v.X + scalar), (float)(v.Y + scalar));
	}

	/// <summary>uint - Float2 operator. Vector components are (scalar - v.X, scalar - v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(uint scalar, Float2 v)
	{
		return new Float2((float)(scalar - v.X), (float)(scalar - v.Y));
	}

	/// <summary>Float2 - uint operator. Vector components are (v.X - scalar, v.Y - scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(Float2 v, uint scalar)
	{
		return new Float2((float)(v.X - scalar), (float)(v.Y - scalar));
	}

	/// <summary>uint * Float2 operator. Vector components are (scalar * v.X, scalar * v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(uint scalar, Float2 v)
	{
		return new Float2((float)(scalar * v.X), (float)(scalar * v.Y));
	}

	/// <summary>Float2 * uint operator. Vector components are (v.X * scalar, v.Y * scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(Float2 v, uint scalar)
	{
		return new Float2((float)(v.X * scalar), (float)(v.Y * scalar));
	}

	/// <summary>uint / Float2 operator. Vector components are (v.X / scalar, v.Y / scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(Float2 v, uint scalar)
	{
		return new Float2((float)(v.X / scalar), (float)(v.Y / scalar));
	}

	/// <summary>uint / Float2 operator. Vector components are (scalar / v.X, scalar / v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(uint scalar, Float2 v)
	{
		return new Float2((float)(scalar / v.X), (float)(scalar / v.Y));
	}

	/// <summary>Float2 % uint operator. Vector components are (v.X % scalar, v.Y % scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(Float2 v, uint scalar)
	{
		return new Float2((float)(v.X % scalar), (float)(v.Y % scalar));
	}

	/// <summary>uint % Float2 operator. Vector components are (scalar % v.X, scalar % v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(uint scalar, Float2 v)
	{
		return new Float2((float)(scalar % v.X), (float)(scalar % v.Y));
	}

	/// <summary>ulong + Float2 operator. Vector components are (scalar + v.X, scalar + v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(ulong scalar, Float2 v)
	{
		return new Float2((float)(scalar + v.X), (float)(scalar + v.Y));
	}

	/// <summary>Float2 + ulong operator. Vector components are (v.X + scalar, v.Y + scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator +(Float2 v, ulong scalar)
	{
		return new Float2((float)(v.X + scalar), (float)(v.Y + scalar));
	}

	/// <summary>ulong - Float2 operator. Vector components are (scalar - v.X, scalar - v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(ulong scalar, Float2 v)
	{
		return new Float2((float)(scalar - v.X), (float)(scalar - v.Y));
	}

	/// <summary>Float2 - ulong operator. Vector components are (v.X - scalar, v.Y - scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator -(Float2 v, ulong scalar)
	{
		return new Float2((float)(v.X - scalar), (float)(v.Y - scalar));
	}

	/// <summary>ulong * Float2 operator. Vector components are (scalar * v.X, scalar * v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(ulong scalar, Float2 v)
	{
		return new Float2((float)(scalar * v.X), (float)(scalar * v.Y));
	}

	/// <summary>Float2 * ulong operator. Vector components are (v.X * scalar, v.Y * scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator *(Float2 v, ulong scalar)
	{
		return new Float2((float)(v.X * scalar), (float)(v.Y * scalar));
	}

	/// <summary>ulong / Float2 operator. Vector components are (v.X / scalar, v.Y / scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(Float2 v, ulong scalar)
	{
		return new Float2((float)(v.X / scalar), (float)(v.Y / scalar));
	}

	/// <summary>ulong / Float2 operator. Vector components are (scalar / v.X, scalar / v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator /(ulong scalar, Float2 v)
	{
		return new Float2((float)(scalar / v.X), (float)(scalar / v.Y));
	}

	/// <summary>Float2 % ulong operator. Vector components are (v.X % scalar, v.Y % scalar).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(Float2 v, ulong scalar)
	{
		return new Float2((float)(v.X % scalar), (float)(v.Y % scalar));
	}

	/// <summary>ulong % Float2 operator. Vector components are (scalar % v.X, scalar % v.Y).</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 operator %(ulong scalar, Float2 v)
	{
		return new Float2((float)(scalar % v.X), (float)(scalar % v.Y));
	}

	// --- Component-wise Comparison Operators (Return Boolean Vector) ---
	/// <summary>Returns a Bool2 indicating the result of component-wise < comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator <(Float2 a, Float2 b) { return new Bool2(a.X < b.X, a.Y < b.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise < comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator <(Float2 a, float scalar) { return new Bool2(a.X < scalar, a.Y < scalar); }

	/// <summary>Returns a Bool2 indicating the result of component-wise < comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator <(float scalar, Float2 a) { return new Bool2(scalar < a.X, scalar < a.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise <= comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator <=(Float2 a, Float2 b) { return new Bool2(a.X <= b.X, a.Y <= b.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise <= comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator <=(Float2 a, float scalar) { return new Bool2(a.X <= scalar, a.Y <= scalar); }

	/// <summary>Returns a Bool2 indicating the result of component-wise <= comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator <=(float scalar, Float2 a) { return new Bool2(scalar <= a.X, scalar <= a.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise > comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator >(Float2 a, Float2 b) { return new Bool2(a.X > b.X, a.Y > b.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise > comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator >(Float2 a, float scalar) { return new Bool2(a.X > scalar, a.Y > scalar); }

	/// <summary>Returns a Bool2 indicating the result of component-wise > comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator >(float scalar, Float2 a) { return new Bool2(scalar > a.X, scalar > a.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise >= comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator >=(Float2 a, Float2 b) { return new Bool2(a.X >= b.X, a.Y >= b.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise >= comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator >=(Float2 a, float scalar) { return new Bool2(a.X >= scalar, a.Y >= scalar); }

	/// <summary>Returns a Bool2 indicating the result of component-wise >= comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator >=(float scalar, Float2 a) { return new Bool2(scalar >= a.X, scalar >= a.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise == comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator ==(Float2 a, Float2 b) { return new Bool2(a.X == b.X, a.Y == b.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise == comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator ==(Float2 a, float scalar) { return new Bool2(a.X == scalar, a.Y == scalar); }

	/// <summary>Returns a Bool2 indicating the result of component-wise == comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator ==(float scalar, Float2 a) { return new Bool2(scalar == a.X, scalar == a.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise != comparison.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator !=(Float2 a, Float2 b) { return new Bool2(a.X != b.X, a.Y != b.Y); }

	/// <summary>Returns a Bool2 indicating the result of component-wise != comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator !=(Float2 a, float scalar) { return new Bool2(a.X != scalar, a.Y != scalar); }

	/// <summary>Returns a Bool2 indicating the result of component-wise != comparison with a scalar.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Bool2 operator !=(float scalar, Float2 a) { return new Bool2(scalar != a.X, scalar != a.Y); }

	// --- Casting ---
	/// <summary>Implicitly converts this Float2 to a System.Numerics.Vector2.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Vector2(Float2 value) => new Vector2(value.X, value.Y);

	/// <summary>Implicitly converts a System.Numerics.Vector2 to this Float2.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Float2(Vector2 value) => new Float2(value.X, value.Y);

	// --- Cross-Dimensions Casting Operators ---
	// --- Cross-Type Casting Operators ---
	/// <summary>Explicitly converts a Double2 to a Float2.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static explicit operator Float2(Double2 v) => new Float2(v);

	/// <summary>Implicitly converts a Int2 to a Float2.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Float2(Int2 v) => new Float2(v);

	/// <summary>Implicitly converts a Byte2 to a Float2.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Float2(Byte2 v) => new Float2(v);

	/// <summary>Implicitly converts a UShort2 to a Float2.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Float2(UShort2 v) => new Float2(v);

	/// <summary>Implicitly converts a UInt2 to a Float2.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Float2(UInt2 v) => new Float2(v);

	/// <summary>Implicitly converts a ULong2 to a Float2.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static implicit operator Float2(ULong2 v) => new Float2(v);

	// --- Methods ---
	/// <summary>Returns a boolean vector indicating which components are less than the corresponding components of another vector.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 LessThan(Float2 other) { return new Bool2(X < other.X, Y < other.Y); }

	/// <summary>Returns a boolean vector indicating which components are less than or equal to the corresponding components of another vector.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 LessThanOrEqual(Float2 other) { return new Bool2(X <= other.X, Y <= other.Y); }

	/// <summary>Returns a boolean vector indicating which components are greater than the corresponding components of another vector.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 GreaterThan(Float2 other) { return new Bool2(X > other.X, Y > other.Y); }

	/// <summary>Returns a boolean vector indicating which components are greater than or equal to the corresponding components of another vector.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 GreaterThanOrEqual(Float2 other) { return new Bool2(X >= other.X, Y >= other.Y); }

	/// <summary>Selects components from two vectors based on a boolean mask.</summary>
	/// <param name="mask">Boolean vector mask for selection.</param>
	/// <param name="trueValue">Vector to select from when mask component is true.</param>
	/// <param name="falseValue">Vector to select from when mask component is false.</param>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public static Float2 Select(Bool2 mask, Float2 trueValue, Float2 falseValue)
	{
		return new Float2(mask.X ? trueValue.X : falseValue.X, mask.Y ? trueValue.Y : falseValue.Y);
	}

	/// <summary>Returns a boolean vector indicating which components are within the specified range.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 InRange(Float2 min, Float2 max)
	{
		return new Bool2(X >= min.X && X <= max.X, Y >= min.Y && Y <= max.Y);
	}

	/// <summary>Returns a boolean vector indicating which components are equal to the corresponding components of another vector.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 EqualTo(Float2 other) { return new Bool2(X == other.X, Y == other.Y); }

	/// <summary>Returns a boolean vector indicating which components are not equal to the corresponding components of another vector.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 NotEqualTo(Float2 other) { return new Bool2(X != other.X, Y != other.Y); }

	/// <summary>Returns a boolean vector indicating which components are approximately equal to the corresponding components of another vector.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 ApproximatelyEqualTo(Float2 other) { return new Bool2(MathF.Abs(X - other.X) <= float.Epsilon, MathF.Abs(Y - other.Y) <= float.Epsilon); }

	/// <summary>Returns a boolean vector indicating which components are approximately equal to the corresponding components of another vector with a custom tolerance.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 ApproximatelyEqualTo(Float2 other, float tolerance)
	{
		return new Bool2(MathF.Abs(X - other.X) <= tolerance, MathF.Abs(Y - other.Y) <= tolerance);
	}

	/// <summary>Returns a boolean vector indicating which components are less than a scalar value.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 LessThan(float scalar) { return new Bool2(X < scalar, Y < scalar); }

	/// <summary>Returns a boolean vector indicating which components are greater than a scalar value.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 GreaterThan(float scalar) { return new Bool2(X > scalar, Y > scalar); }

	/// <summary>Returns a boolean vector indicating which components are equal to a scalar value.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public Bool2 EqualTo(float scalar) { return new Bool2(X == scalar, Y == scalar); }

	/// <summary>Returns an array of components.</summary>
	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public float[] ToArray() { return new float[] { X, Y }; }
	/// <summary>Returns an array of components.</summary>
	public override bool Equals(object? obj) { return obj is Float2 && Equals((Float2)obj); }

	[MethodImpl(MethodImplOptions.AggressiveInlining)]
	public bool Equals(Float2 other) { return X == other.X && Y == other.Y; }

	public override int GetHashCode() { return X.GetHashCode() ^ (Y.GetHashCode() << 2); }

	public override string ToString() { return ToString("G", CultureInfo.CurrentCulture); }

	public string ToString(string format) { return ToString(format, CultureInfo.CurrentCulture); }

	public string ToString(string format, IFormatProvider formatProvider)
	{
		string separator = (formatProvider is CultureInfo) ? ((CultureInfo)formatProvider).TextInfo.ListSeparator : ", ";
		return "(" + X.ToString(format, formatProvider) + separator + Y.ToString(format, formatProvider) + ")";
	}
}
}
